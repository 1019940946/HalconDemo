<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<c>* ****************************************************************************</c>
<c>* </c>
<c>* Explore the Power of HALCON</c>
<c>* (c) 2005-2014 MVTec Software GmbH</c>
<c>* </c>
<c>* ****************************************************************************</c>
<c>* </c>
<c>* This example program will give you an impression of the power</c>
<c>* of HALCON. It is a compilation of selected applications and</c>
<c>* solutions from many different industries and application areas.</c>
<c>* Each application runs live in HALCON HDevelop.</c>
<c>* </c>
<c>* All applications and solutions that are shown in</c>
<c>* explore_halcon.hdev are also available as individual HDevelop</c>
<c>* programs. They can serve as templates to shorten the development</c>
<c>* time of your application.</c>
<c>* </c>
<c>* Please note that they are only a small subset of the hundreds of</c>
<c>* examples that are included in the HALCON software. All HALCON</c>
<c>* examples can be found with the Example Browser of HDevelop.</c>
<c>* </c>
<c>* ****************************************************************************</c>
<c>* </c>
<c>* Attention: Due to space restrictions, the downloaded HALCON</c>
<c>* installation potentially does not include the pre-generated models</c>
<c>* used for the following application procedures:</c>
<c>* (A) p_do_cookie_box</c>
<c>* (B) p_do_3d_matching_clamps</c>
<c>* In this case, for using these application procedures also in</c>
<c>* "Explore the Power of HALCON", the models have to be generated</c>
<c>* by running the corresponding HDevelop example programs once:</c>
<c>* (A) Applications/Object-Recognition-2D/locate_cookie_box.hdev (cookie_box_model.dsm)</c>
<c>* (B) Applications/Position-Recognition-3D/3d_matching_clamps.hdev (clamp_sloped_35.sm3)</c>
<c>* </c>
<c>* When starting the application, the procedure do_check_for_model_files</c>
<c>* checks for the presence of these two model files. If any of these</c>
<c>* files are missing by the time you run explore_halcon.hdev, the</c>
<c>* respective procedure will be omitted.</c>
<c>* </c>
<c>* </c>
<l>do_check_for_model_files (CookieModelExists, ClampsModelExists)</l>
<l>mCount := CookieModelExists + ClampsModelExists</l>
<c>* </c>
<c>* </c>
<c>* To run this application continuously, simply uncomment the while statement:</c>
<l>* while (1)</l>
<c>    * </c>
<l>    p_show_intro (MainWindowHandle)</l>
<c>    * </c>
<l>    p_initialize (StatusWindowHandle)</l>
<l>    NumCurrent := 0</l>
<l>    NumTotal := 37 + mCount</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Metrology', 'Measure Geometric Shapes', 'Measure Geometric Shapes Using a Metrology Model', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_metrology_model ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Optical Character Recognition', 'Read Expiration Date', 'Read Expiration Date on Medical Packages', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_find_text_expiration_date ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('Object Identification', 'Using Sample Based', 'Identification', 'Identify Wine Bottles', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_apply_sample_identifier_wine_bottle ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Inspection', 'Using Bead Inspection Model', 'Bead Inspection', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_bead_inspection ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', '3D Reconstruction', 'and 3D Surface Comparison', 'Measure a Metal Part and Compare it to a Reference', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_compare_surface_sheet_of_light ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Inspection', 'Using GMM Classifier', 'Inspect Pill Types in a Blister', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_blister_mixed ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('Multi-View Stereo', 'Reconstruction and ', '3D Surface-Based Matching', 'Locate Pipe Joints from a Pile', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_locate_pipe_joints_stereo ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Identification', 'Read Data Codes', 'Read Distorted ECC200 Codes', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_ecc200_finder_pattern_tolerance ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Robot Vision', 'for Automotive Industry', 'Track an Engine Part', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_track_engine_part ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Identification', 'Read Bar Codes', 'Read Different Bar Codes', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_find_barcode ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Read Braille Characters', 'Using Photometric Stereo', 'Read Braille Characters on a Pharmaceutical Package', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_read_braille_photometric_stereo ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Camera Calibration', 'with Scheimpflug Lens', 'Calibrate a Camera with Telecentric Tilt Lens', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_calibrate_cameras_telecentric_tilt ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Inspection for', 'Packaging Industry', 'Inspect Bottle Mouth for Damages', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_bottle_mouth ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    if (ClampsModelExists)</l>
<l>        NumCurrent := NumCurrent + 1</l>
<l>        p_show_status_window ('', '3D Matching', 'Based on a CAD Model', 'Find Objects in Arbitrary 3D Poses', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>        p_do_3d_matching_clamps ()</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Optical Character Recognition', 'Text Line Orientation', 'Detect Rotated Dot Prints', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_textline_orientation ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Local Deformable Matching', 'for Food Industry', 'Locate Cocoa Packages', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_find_cocoa_package_local_deformable ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Surface Inspection', 'Using Photometric Stereo', 'Inspect the Texture of Leather Samples', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_inspect_leather_photometric_stereo ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Segmentation', 'Using a GMM Classifier', 'Detect Errors in a Mesh', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_novelty_detection_gmm ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Optical Flow', '', 'Detect Moving Objects', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_optical_flow_bicycle ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Print Inspection', '', 'Print Inspection using a Variation Model', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_variation_model_illumination ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Board Inspection', '', 'Inspect the Radius of Bonding Balls', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_balls ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    if (CookieModelExists)</l>
<l>        NumCurrent := NumCurrent + 1</l>
<l>        p_show_status_window ('', 'Descriptor-based', 'Matching', 'Determine Pose of Cookie Box', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>        p_do_cookie_box ()</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Optical Character Recognition', '', 'Extract the ID Number of Parcels', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_ocr_color ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Identification', '2D Data Codes', 'Read ECC 200, Aztec, QR and Micro QR Data Codes and PDF417', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_2dbarcode ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'PCB Inspection', '', 'Detect Defects on a Printed Circuit Board', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_pcb ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Shape-Based Matching under', 'Perspective Distortions', 'Locate Metal Parts in 3D World Coordinates', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_world_plane ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Color Image Processing', '', 'Segment Fuses using Color Information', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_color_fuses ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Image Mosaicking', 'Using Bundle Adjustment', 'Create Image Mosaic of a Die', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_mosaicking ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Inspection', 'of Non-Planar Surfaces', 'Rectify the Surface of a Can', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_grid_rectification ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Completeness Check', '', 'Inspect a Punching Die of Razors', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_razor_blades ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Medical Image Analysis', 'Subpixel Line Detection', 'Find and Measure Vessels in an Angiographic Image', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_angio ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Industrial Inspection', '', 'Measure the Radius of Steel Balls', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_circles ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', '3D Reconstruction', '', 'Inspect a Resistor Using Depth From Focus', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_resistors ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Remote Sensing', '', 'Extract Roads from an Aerial Image', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_roads ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Shape Recognition', 'Using Shape-Based Matching', 'Recognize Multiple Metal Parts', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_multiple_parts ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Surveillance', '', 'Monitor Cars and People on a Crossing', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_xing ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Print Inspection', '', 'Inspect the Print on a Pen Clip', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_print_check ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', '3D Measurement', '', 'Get the 3D Position of Circular Holes', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_3d_position_of_circles ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    NumCurrent := NumCurrent + 1</l>
<l>    p_show_status_window ('', 'Wood Inspection', '', 'Determine the Age of a Tree', NumCurrent, NumTotal, StatusWindowHandle, MainWindowHandle)</l>
<l>    p_do_wood ()</l>
<l>    wait_seconds (1)</l>
<c>    * </c>
<l>    dev_close_window ()</l>
<l>    p_show_end (StatusWindowHandle)</l>
<c>    * </c>
<l>* endwhile</l>
<c>* </c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="p_initialize">
<interface>
<oc>
<par name="StatusWindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Path := 'explore_halcon/'</l>
<l>dev_update_off ()</l>
<c>* </c>
<l>read_image (StatusBackground, Path + 'explore_halcon_bg')</l>
<l>get_image_size (StatusBackground, ImgWidth, ImgHeight)</l>
<l>dev_open_window (0, 648, ImgWidth, ImgHeight, 'black', StatusWindowHandle)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_initialize">
<parameters>
<parameter id="StatusWindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_show_status_window">
<interface>
<ic>
<par name="TitleCurrent0" base_type="ctrl" dimension="0"/>
<par name="TitleCurrent1" base_type="ctrl" dimension="0"/>
<par name="TitleCurrent2" base_type="ctrl" dimension="0"/>
<par name="TitleCurrentApplication" base_type="ctrl" dimension="0"/>
<par name="NumCurrent" base_type="ctrl" dimension="0"/>
<par name="NumTotal" base_type="ctrl" dimension="0"/>
<par name="StatusWindow" base_type="ctrl" dimension="0"/>
<par name="MainWindow" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Show status window and current titles</c>
<c>* </c>
<l>Path := 'explore_halcon/'</l>
<l>BarGap := 2</l>
<c>* </c>
<l>p_set_font (StatusWindow)</l>
<l>dev_set_window (StatusWindow)</l>
<c>* </c>
<l>read_image (StatusBackground, Path + 'explore_halcon_bg')</l>
<l>get_image_size (StatusBackground, ImgWidth, ImgHeight)</l>
<l>dev_set_part (0, 0, ImgHeight - 1, ImgWidth - 1)</l>
<l>dev_display (StatusBackground)</l>
<c>* </c>
<c>* MVTec blue</c>
<l>dev_set_color ('#003075')</l>
<l>dev_set_line_width (1)</l>
<c>* </c>
<l>Step := (ImgWidth - BarGap) / NumTotal</l>
<l>WidthBar := NumTotal * Step - BarGap</l>
<l>StartColumn := (ImgWidth - WidthBar) / 2</l>
<l>Row1 := gen_tuple_const(NumTotal,140)</l>
<l>Column1 := [StartColumn:Step:StartColumn + (NumTotal - 1) * Step]</l>
<l>Row2 := gen_tuple_const(NumTotal,150)</l>
<l>Column2 := Column1 + (Step - BarGap)</l>
<c>* </c>
<l>dev_set_draw ('fill')</l>
<l>gen_rectangle1 (Rectangle, Row1[0:NumCurrent - 1], Column1[0:NumCurrent - 1], Row2[0:NumCurrent - 1], Column2[0:NumCurrent - 1])</l>
<l>dev_display (Rectangle)</l>
<l>if (NumCurrent &lt; NumTotal)</l>
<l>    dev_set_draw ('margin')</l>
<l>    gen_rectangle1 (Rectangle, Row1[NumCurrent:NumTotal - 1], Column1[NumCurrent:NumTotal - 1], Row2[NumCurrent:NumTotal - 1], Column2[NumCurrent:NumTotal - 1])</l>
<l>    dev_display (Rectangle)</l>
<l>endif</l>
<c>* </c>
<l>set_tposition (StatusWindow, 165, 12)</l>
<l>write_string (StatusWindow, TitleCurrent0)</l>
<l>set_tposition (StatusWindow, 190, 12)</l>
<l>write_string (StatusWindow, TitleCurrent1)</l>
<l>set_tposition (StatusWindow, 215, 12)</l>
<l>write_string (StatusWindow, TitleCurrent2)</l>
<c>* </c>
<c>* </c>
<l>dev_set_window (MainWindow)</l>
<l>read_image (Background, Path + 'explore_halcon_next_demo')</l>
<l>get_image_size (Background, Width, Height)</l>
<l>dev_set_window_extents (0, 0, 640, 480)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (Background)</l>
<l>p_set_font (MainWindow)</l>
<l>get_string_extents (MainWindow, TitleCurrentApplication, Ascent, Descent, Width, Height)</l>
<l>dev_set_part (0, 0, 479, 639)</l>
<l>PosRow := 194 - Height / 2.</l>
<l>PosCol := (640 - Width) / 2.</l>
<l>dev_set_color ('#003075')</l>
<l>set_tposition (MainWindow, PosRow, PosCol)</l>
<l>write_string (MainWindow, TitleCurrentApplication)</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_show_status_window">
<short lang="en_US">Show status window with current titles</short>
<parameters>
<parameter id="MainWindow"/>
<parameter id="NumCurrent"/>
<parameter id="NumTotal"/>
<parameter id="StatusWindow"/>
<parameter id="TitleCurrent0"/>
<parameter id="TitleCurrent1"/>
<parameter id="TitleCurrent2"/>
<parameter id="TitleCurrentApplication"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_ocr_color">
<interface/>
<body>
<c>* </c>
<c>* OCR (numbers) with color segmentation</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>read_image (Image, 'ocr/color_form_01')</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<c>* </c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_draw ('margin')</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>read_ocr_class_mlp ('Industrial_0-9_NoRej', OCRHandle)</l>
<l>ImgNr := 1</l>
<l>for I := 1 to 40 by 1</l>
<l>    read_image (Image, 'ocr/color_form_0' + ImgNr)</l>
<c>    * </c>
<c>    * Detect foreground</c>
<c>    * </c>
<l>    mean_image (Image, Mean, 3, 3)</l>
<l>    decompose3 (Mean, Red, Green, Blue)</l>
<l>    threshold (Green, ForegroundRaw, 0, 220)</l>
<l>    clip_region (ForegroundRaw, Foreground, 3, 3, Height - 4, Width - 4)</l>
<c>    * </c>
<c>    * Divide colors</c>
<c>    * </c>
<l>    reduce_domain (Red, Foreground, RedReduced)</l>
<l>    reduce_domain (Green, Foreground, GreenReduced)</l>
<l>    sub_image (RedReduced, GreenReduced, ImageSub, 2, 128)</l>
<l>    mean_image (ImageSub, ImageMean, 3, 3)</l>
<l>    binary_threshold (ImageMean, Cluster1, 'smooth_histo', 'dark', UsedThreshold)</l>
<l>    difference (Foreground, Cluster1, Cluster2)</l>
<l>    concat_obj (Cluster1, Cluster2, Cluster)</l>
<l>    opening_circle (Cluster, Opening, 2.5)</l>
<l>    smallest_rectangle1 (Opening, Row1, Column1, Row2, Column2)</l>
<l>    WidthCluster := Column2 - Column1 + 1</l>
<l>    if (WidthCluster[0] &gt; WidthCluster[1])</l>
<l>        select_obj (Opening, NumberRegion, 2)</l>
<l>    else</l>
<l>        select_obj (Opening, NumberRegion, 1)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Expand Numbers</c>
<c>    * </c>
<l>    closing_rectangle1 (NumberRegion, NumberCand, 1, 20)</l>
<l>    difference (Image, NumberCand, NoNumbers)</l>
<l>    connection (NumberRegion, NumberParts)</l>
<l>    intensity (NumberParts, Green, MeanIntensity, Deviation)</l>
<l>    expand_gray_ref (NumberParts, Green, NoNumbers, Numbers, 20, 'image', MeanIntensity, 48)</l>
<l>    union1 (Numbers, NumberRegion)</l>
<l>    connection (NumberRegion, Numbers)</l>
<c>    * </c>
<c>    * Fine tuning</c>
<c>    * </c>
<l>    fill_up_shape (Numbers, RegionFillUp, 'area', 1, 100)</l>
<l>    opening_circle (RegionFillUp, FinalNumbersUnsorted, 3.5)</l>
<l>    sort_region (FinalNumbersUnsorted, FinalNumbers, 'character', 'true', 'row')</l>
<l>    dev_set_color ('black')</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, 'Extract ID number of parcel', 'window', -1, -1, 'black', 'true')</l>
<l>    if (I &lt; 3)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    else</l>
<l>*         wait_seconds (0.25)</l>
<l>    endif</l>
<l>    dev_display (FinalNumbers)</l>
<l>    count_obj (FinalNumbers, NumNumbers)</l>
<l>    union1 (FinalNumbers, NumberRegion)</l>
<l>    difference (Image, NumberRegion, NoNumbers)</l>
<l>    paint_region (NoNumbers, Green, ImageOCRRaw, 255, 'fill')</l>
<l>    paint_region (NumberRegion, ImageOCRRaw, ImageOCR, 0, 'fill')</l>
<c>    * </c>
<c>    * OCR</c>
<c>    * </c>
<l>    do_ocr_multi_class_mlp (FinalNumbers, ImageOCR, OCRHandle, RecChar, Confidence)</l>
<l>    disp_message (WindowHandle, 'Extracted ID: ' + sum(RecChar), 'window', 400, -1, 'black', 'true')</l>
<l>    if (I &lt; 3)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    else</l>
<l>*         wait_seconds (0.25)</l>
<l>    endif</l>
<l>    ImgNr := ImgNr + 1</l>
<l>    if (ImgNr &gt; 8)</l>
<l>        ImgNr := 1</l>
<l>    endif</l>
<l>endfor</l>
<l>clear_ocr_class_mlp (OCRHandle)</l>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_ocr_color">
<short lang="en_US">OCR (numbers) with color segmentation</short>
<parameters/>
</docu>
</procedure>
<procedure name="p_do_circles">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<l>read_image (Image, 'double_circle')</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<c>* </c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Measure the radius of steel balls', 'window', -1, -1, 'black', 'true')</l>
<l>fast_threshold (Image, Region, 0, 120, 7)</l>
<l>boundary (Region, RegionBorder, 'inner')</l>
<l>clip_region_rel (RegionBorder, RegionClipped, 5, 5, 5, 5)</l>
<l>dilation_circle (RegionClipped, RegionDilation, 2.5)</l>
<l>reduce_domain (Image, RegionDilation, ImageReduced)</l>
<l>edges_sub_pix (ImageReduced, Edges, 'canny', 2, 20, 60)</l>
<l>segment_contours_xld (Edges, ContoursSplit, 'lines_circles', 5, 4, 3)</l>
<l>count_obj (ContoursSplit, Number)</l>
<l>dev_set_draw ('margin')</l>
<l>J := 0</l>
<l>for I := 1 to Number by 1</l>
<l>    dev_set_line_width (3)</l>
<l>    select_obj (ContoursSplit, ObjectSelected, I)</l>
<l>    get_contour_global_attrib_xld (ObjectSelected, 'cont_approx', Attrib)</l>
<l>    if (Attrib &gt; 0)</l>
<l>        fit_circle_contour_xld (ObjectSelected, 'ahuber', -1, 2, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>        gen_ellipse_contour_xld (ContEllipse, Row, Column, 0, Radius, Radius, 0, 4 * acos(0), 'positive', 1.0)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (ContEllipse)</l>
<l>        if (I == 1)</l>
<l>            dev_set_line_width (1)</l>
<l>            dev_set_color ('blue')</l>
<l>            disp_line (WindowHandle, 169, 458, 188, 379)</l>
<l>            disp_message (WindowHandle, 'Radius: ' + Radius$'5.2f' + ' px', 'image', 145, 390, 'black', 'true')</l>
<c>            * </c>
<l>        endif</l>
<l>        if (I == 3)</l>
<l>            dev_set_line_width (1)</l>
<l>            dev_set_color ('blue')</l>
<l>            disp_line (WindowHandle, 268, 181, 356, 213)</l>
<l>            disp_message (WindowHandle, 'Radius: ' + Radius$'5.2f' + ' px', 'window', 244, 91, 'black', 'true')</l>
<l>        endif</l>
<l>        if (Radius &lt; 100)</l>
<l>            dev_set_line_width (1)</l>
<l>            dev_set_color ('blue')</l>
<l>            disp_line (WindowHandle, 316, 373, 123, 293)</l>
<l>            disp_message (WindowHandle, 'Radius: ' + Radius$'5.2f' + ' px', 'window', 100, 200, 'black', 'true')</l>
<l>            dev_open_window (205, 20, 256, 256, 'black', WindowHandle1)</l>
<l>            dev_set_part (round(Row - (Radius + 5)), round(Column - (Radius + 5)), round(Row + (Radius + 5)), round(Column + (Radius + 5)))</l>
<l>            dev_display (Image)</l>
<l>            dev_set_line_width (3)</l>
<l>            dev_set_color ('green')</l>
<l>            dev_display (ContEllipse)</l>
<l>            wait_seconds (4)</l>
<l>            dev_close_window ()</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>        endif</l>
<l>        J := J + 1</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (4)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_circles">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_razor_blades">
<interface/>
<body>
<c>* </c>
<c>* ------------------------------------------------------------------------------------------------</c>
<c>* This example program uses shape-based matching to align ROIs for the measure</c>
<c>* tool, which then inspects individual razor blades.</c>
<c>* The program can be run in two modes: (1) with the full affine transformation</c>
<c>* (2) using translate_measure</c>
<c>* Modify the next line to switch between the modes.</c>
<l>USING_TRANSLATE_MEASURE := 0</l>
<c>* ------------------------------------------------------------------------------------------------</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* image acquisition and window size</c>
<l>read_image (ModelImage, 'razors1')</l>
<l>get_image_size (ModelImage, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_display (ModelImage)</l>
<c>* </c>
<c>* colors and other settings for the visualization</c>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<c>* -------------------  start of the application  ----------------</c>
<c>* -&gt; select the model object</c>
<l>Row1 := 46</l>
<l>Column1 := 57</l>
<l>Row2 := 79</l>
<l>Column2 := 94</l>
<l>gen_rectangle1 (ROIPart1, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (ROIPart2, Row1 + 364, Column1 + 13, Row2 + 364, Column2 + 13)</l>
<l>union2 (ROIPart1, ROIPart2, ModelROI)</l>
<l>area_center (ModelROI, Area, CenterROIRow, CenterROIColumn)</l>
<l>dev_display (ModelImage)</l>
<l>disp_message (WindowHandle, 'Inspect a punching die of razors', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>dev_display (ModelImage)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (ModelROI)</l>
<l>disp_message (WindowHandle, 'Define a model', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (2)</l>
<c>* -&gt; create the model</c>
<l>reduce_domain (ModelImage, ModelROI, ImageROI)</l>
<l>create_shape_model (ImageROI, 4, 0, 0, 'auto', 'none', 'use_polarity', 30, 10, ModelID)</l>
<l>inspect_shape_model (ImageROI, ShapeModelImage, ShapeModelRegion, 1, 30)</l>
<l>gen_contours_skeleton_xld (ShapeModelRegion, ShapeModel, 1, 'filter')</l>
<l>dev_clear_window ()</l>
<l>disp_message (WindowHandle, 'Model contour', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_color ('blue')</l>
<l>dev_display (ShapeModelRegion)</l>
<l>wait_seconds (2)</l>
<c>* step 1: create variables describing  the measurement ROIs and display them</c>
<l>Rect1Row := 244</l>
<l>Rect1Col := 73</l>
<l>DistColRect1Rect2 := 17</l>
<l>Rect2Row := Rect1Row</l>
<l>Rect2Col := Rect1Col + DistColRect1Rect2</l>
<l>RectPhi := rad(90)</l>
<l>RectLength1 := 122</l>
<l>RectLength2 := 2</l>
<l>gen_rectangle2 (MeasureROI1, Rect1Row, Rect1Col, RectPhi, RectLength1, RectLength2)</l>
<l>gen_rectangle2 (MeasureROI2, Rect2Row, Rect2Col, RectPhi, RectLength1, RectLength2)</l>
<l>dev_display (ModelImage)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (MeasureROI1)</l>
<l>dev_display (MeasureROI2)</l>
<l>if (USING_TRANSLATE_MEASURE != 0)</l>
<c>    * -&gt; measure objects are created only once in advance and then translated later</c>
<l>    gen_measure_rectangle2 (Rect1Row, Rect1Col, RectPhi, RectLength1, RectLength2, Width, Height, 'bilinear', MeasureHandle1)</l>
<l>    gen_measure_rectangle2 (Rect2Row, Rect2Col, RectPhi, RectLength1, RectLength2, Width, Height, 'bilinear', MeasureHandle2)</l>
<l>endif</l>
<c>* step 2: move the reference point to the center of the first measure rectangle</c>
<l>DistRect1CenterRow := Rect1Row - CenterROIRow</l>
<l>DistRect1CenterCol := Rect1Col - CenterROIColumn</l>
<l>set_shape_model_origin (ModelID, DistRect1CenterRow, DistRect1CenterCol)</l>
<l>disp_message (WindowHandle, 'Define measurement rectangles', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (2)</l>
<c>* step 3: find the objects in another image</c>
<l>read_image (SearchImage, 'razors2')</l>
<l>dev_display (SearchImage)</l>
<l>disp_message (WindowHandle, 'Perform the quality measurement', 'window', 12, 12, 'black', 'true')</l>
<l>set_tposition (WindowHandle, 16, 12)</l>
<l>* write_string (WindowHandle, 'Quality inspection of a punching die of razors')</l>
<l>find_shape_model (SearchImage, ModelID, 0, 0, 0.8, 0, 0.5, 'interpolation', 0, 0.7, RowCheck, ColumnCheck, AngleCheck, Score)</l>
<l>tuple_sort_index (ColumnCheck, Indices)</l>
<l>tuple_select (ColumnCheck, Indices, ColumnCheck)</l>
<l>tuple_select (RowCheck, Indices, RowCheck)</l>
<l>tuple_select (AngleCheck, Indices, AngleCheck)</l>
<l>if (|Score| &gt; 0)</l>
<l>    for I := 0 to |Score| - 1 by 1</l>
<c>        * step 4: determine the affine transformation</c>
<l>        vector_angle_to_rigid (Rect1Row, Rect1Col, 0, RowCheck[I], ColumnCheck[I], AngleCheck[I], MovementOfObject)</l>
<l>        affine_trans_contour_xld (ShapeModel, ModelAtNewPosition, MovementOfObject)</l>
<l>        dev_set_color ('blue')</l>
<l>        dev_display (ModelAtNewPosition)</l>
<c>        * step 5: measure width and distance of the teeth</c>
<c>        * -&gt; display the moved ROIs</c>
<l>        affine_trans_region (MeasureROI1, MeasureROI1AtNewPosition, MovementOfObject, 'constant')</l>
<l>        affine_trans_region (MeasureROI2, MeasureROI2AtNewPosition, MovementOfObject, 'constant')</l>
<l>        dev_set_color ('yellow')</l>
<l>        dev_display (MeasureROI1AtNewPosition)</l>
<l>        dev_display (MeasureROI2AtNewPosition)</l>
<l>        if (USING_TRANSLATE_MEASURE != 0)</l>
<c>            * -&gt; translate the already created measure objects</c>
<l>            translate_measure (MeasureHandle1, RowCheck[I], ColumnCheck[I])</l>
<l>            translate_measure (MeasureHandle2, RowCheck[I], ColumnCheck[I] + DistColRect1Rect2)</l>
<l>            measure_pairs (SearchImage, MeasureHandle1, 2, 25, 'negative', 'all', RowEdge11, ColEdge11, Amp11, RowEdge21, ColEdge21, Amp21, Width1, Distance1)</l>
<l>            measure_pairs (SearchImage, MeasureHandle2, 2, 25, 'negative', 'all', RowEdge12, ColEdge12, Amp12, RowEdge22, ColEdge22, Amp22, Width2, Distance2)</l>
<l>        else</l>
<c>            * -&gt; create new measure objects and destroy them after the measurement</c>
<l>            RectPhiCheck := RectPhi + AngleCheck[I]</l>
<l>            gen_measure_rectangle2 (RowCheck[I], ColumnCheck[I], RectPhiCheck, RectLength1, RectLength2, Width, Height, 'bilinear', MeasureHandle1)</l>
<c>            * -&gt; transform the center of the second measure ROIs</c>
<l>            affine_trans_point_2d (MovementOfObject, Rect2Row + 0.5, Rect2Col + 0.5, Rect2RowTmp, Rect2ColTmp)</l>
<l>            Rect2RowCheck := Rect2RowTmp - 0.5</l>
<l>            Rect2ColCheck := Rect2ColTmp - 0.5</l>
<l>            gen_measure_rectangle2 (Rect2RowCheck, Rect2ColCheck, RectPhiCheck, RectLength1, RectLength2, Width, Height, 'bilinear', MeasureHandle2)</l>
<l>            measure_pairs (SearchImage, MeasureHandle1, 2, 25, 'negative', 'all', RowEdge11, ColEdge11, Amp11, RowEdge21, ColEdge21, Amp21, Width1, Distance1)</l>
<l>            measure_pairs (SearchImage, MeasureHandle2, 2, 25, 'negative', 'all', RowEdge12, ColEdge12, Amp12, RowEdge22, ColEdge22, Amp22, Width2, Distance2)</l>
<l>            close_measure (MeasureHandle1)</l>
<l>            close_measure (MeasureHandle2)</l>
<l>        endif</l>
<c>        * step 6: check for too short or missing teeth</c>
<l>        NumberTeeth1 := |Width1|</l>
<l>        NumberTeeth2 := |Width2|</l>
<l>        dev_set_color ('red')</l>
<l>        Status := true</l>
<l>        if (NumberTeeth1 &lt; 37)</l>
<l>            for J := 0 to NumberTeeth1 - 2 by 1</l>
<l>                if (Distance1[J] &gt; 4.0)</l>
<l>                    RowFault := round(0.5 * (RowEdge11[J + 1] + RowEdge21[J]))</l>
<l>                    ColFault := round(0.5 * (ColEdge11[J + 1] + ColEdge21[J]))</l>
<l>                    disp_rectangle2 (WindowHandle, RowFault, ColFault, 0, 4, 4)</l>
<l>                    set_tposition (WindowHandle, RowEdge11[NumberTeeth1 - 1] - 30, ColEdge11[NumberTeeth1 - 1] - 12)</l>
<l>                    write_string (WindowHandle, 'nok')</l>
<l>                    dev_open_window (RowFault - 40, ColFault + 30, 80, 80, 'black', WindowHandleZoom)</l>
<l>                    dev_set_part (RowFault - 10, ColFault - 10, RowFault + 10, ColFault + 10)</l>
<l>                    dev_display (SearchImage)</l>
<l>                    disp_rectangle2 (WindowHandleZoom, RowFault, ColFault, 0, 4, 4)</l>
<l>                    wait_seconds (4)</l>
<l>                    dev_close_window ()</l>
<l>                    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>                    Status := false</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>        if (NumberTeeth2 &lt; 37)</l>
<l>            for J := 0 to NumberTeeth2 - 2 by 1</l>
<l>                if (Distance2[J] &gt; 4.0)</l>
<l>                    RowFault := round(0.5 * (RowEdge12[J + 1] + RowEdge22[J]))</l>
<l>                    ColFault := round(0.5 * (ColEdge12[J + 1] + ColEdge22[J]))</l>
<l>                    disp_rectangle2 (WindowHandle, RowFault, ColFault, 0, 4, 4)</l>
<l>                    set_tposition (WindowHandle, RowEdge12[NumberTeeth2 - 1] - 30, ColEdge12[NumberTeeth2 - 1] - 25)</l>
<l>                    write_string (WindowHandle, 'nok')</l>
<l>                    dev_open_window (RowFault - 40, ColFault + 30, 80, 80, 'black', WindowHandleZoom)</l>
<l>                    dev_set_part (RowFault - 10, ColFault - 10, RowFault + 10, ColFault + 10)</l>
<l>                    dev_display (SearchImage)</l>
<l>                    disp_rectangle2 (WindowHandleZoom, RowFault, ColFault, 0, 4, 4)</l>
<l>                    dev_set_window (WindowHandle)</l>
<l>                    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>                    wait_seconds (3)</l>
<l>                    dev_set_window (WindowHandleZoom)</l>
<l>                    dev_close_window ()</l>
<l>                    Status := false</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        if (Status)</l>
<l>            dev_set_color ('green')</l>
<l>            set_tposition (WindowHandle, RowEdge11[NumberTeeth1 - 1] - 30, ColEdge11[NumberTeeth1 - 1] - 3)</l>
<l>            write_string (WindowHandle, 'ok')</l>
<l>        endif</l>
<l>        dev_set_color ('yellow')</l>
<l>        wait_seconds (0.3)</l>
<l>    endfor</l>
<l>endif</l>
<c>* -------------------  end of the application  -----------------</c>
<c>* clean up</c>
<l>if (USING_TRANSLATE_MEASURE != 0)</l>
<l>    close_measure (MeasureHandle1)</l>
<l>    close_measure (MeasureHandle2)</l>
<l>endif</l>
<l>clear_shape_model (ModelID)</l>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_razor_blades">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_pcb">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<l>read_image (Image, 'pcb')</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<c>* </c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (Image)</l>
<l>p_set_font (WindowHandle)</l>
<l>disp_message (WindowHandle, 'Detect defects on a Printed Circuit Board', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<l>dev_set_color ('black')</l>
<c>* detect defects...</c>
<l>gray_opening_shape (Image, ImageOpening, 7, 7, 'octagon')</l>
<l>gray_closing_shape (Image, ImageClosing, 7, 7, 'octagon')</l>
<l>dyn_threshold (ImageOpening, ImageClosing, RegionDynThresh, 75, 'not_equal')</l>
<l>connection (RegionDynThresh, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 3, 99999)</l>
<l>dev_open_window (220, 380, 256, 256, 'black', WindowHandle1)</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<l>for I := 1 to Number by 1</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('red')</l>
<l>    select_obj (SelectedRegions, ObjectSelected, I)</l>
<l>    dev_display (SelectedRegions)</l>
<l>    area_center (ObjectSelected, Area, Row, Column)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_set_line_width (3)</l>
<l>    disp_rectangle1 (WindowHandle, round(Row - 11), round(Column - 11), round(Row + 11), round(Column + 11))</l>
<l>    dev_set_line_width (2)</l>
<l>    disp_message (WindowHandle, 'Detect defects on a Printed Circuit Board', 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_window (WindowHandle1)</l>
<l>    dev_set_part (round(Row - 10), round(Column - 10), round(Row + 10), round(Column + 10))</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (ObjectSelected)</l>
<l>    if (I &lt; 10)</l>
<l>        wait_seconds (0.9)</l>
<l>    else</l>
<l>        wait_seconds (0.1)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (1)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_close_window ()</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_pcb">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_resistors">
<interface/>
<body>
<c>* </c>
<c>* Extract depth using multiple focus levels</c>
<c>* </c>
<l>Names := []</l>
<l>for I := 1 to 10 by 1</l>
<l>    Names := [Names,'dff/focus_' + (I$'.2')]</l>
<l>endfor</l>
<l>dev_update_off ()</l>
<l>read_image (Image, Names)</l>
<l>channels_to_image (Image, Image)</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<l>p_set_font (WindowHandle)</l>
<c>* Access a channel of a multichannel image</c>
<l>dev_set_color ('red')</l>
<l>for I := 1 to 10 by 1</l>
<l>    access_channel (Image, Image1, I)</l>
<l>    dev_display (Image1)</l>
<l>    disp_message (WindowHandle, 'Reconstruct the height by depth from focus', 'window', 12, 12, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Image ' + I, 'window', 42, 12, 'black', 'true')</l>
<l>    wait_seconds (0.3)</l>
<l>endfor</l>
<l>depth_from_focus (Image, Depth, Confidence, 'highpass', 'next_maximum')</l>
<c>* Smooth by averaging</c>
<l>mean_image (Depth, DepthHighConf, 11, 11)</l>
<l>select_grayvalues_from_channels (Image, DepthHighConf, Selected)</l>
<l>scale_image_max (DepthHighConf, ImageScaleMax)</l>
<l>mean_image (ImageScaleMax, DepthMean, 51, 51)</l>
<l>threshold (DepthMean, Resistor, 158, 255)</l>
<l>connection (Resistor, ConnectedRes)</l>
<c>* Select regions of a given shape</c>
<l>select_shape_std (ConnectedRes, FinalRes, 'max_area', 0)</l>
<l>threshold (DepthMean, Solder, 125, 158)</l>
<l>connection (Solder, ConnectedSol)</l>
<l>select_shape_std (ConnectedSol, SelectedSol, 'max_area', 0)</l>
<c>* Fill up holes</c>
<l>fill_up (SelectedSol, FillUpSol)</l>
<l>opening_circle (FillUpSol, FinalSol, 7.5)</l>
<l>dev_display (Selected)</l>
<l>disp_message (WindowHandle, 'Reconstructed sharp image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>dev_set_color ('black')</l>
<l>dev_clear_window ()</l>
<l>append_channel (DepthMean, Selected, ImageExtended)</l>
<l>try</l>
<l>    dev_set_paint (['3d_plot','texture',4,0.9,0.03,0.45,-0.1,0.4,-0.03,-0.08,0.01])</l>
<l>catch (Exception)</l>
<l>    dev_set_paint (['3d_plot_lines',5,1,110,160,450,0,0])</l>
<l>endtry</l>
<l>dev_display (ImageExtended)</l>
<l>disp_message (WindowHandle, 'Extracted height information', 'window', 12, 12, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Top of SMD', 'image', 90, 130, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Solder', 'image', 220, 160, 'black', 'true')</l>
<l>dev_set_color ('yellow')</l>
<l>disp_line (WindowHandle, 146, 358, 112, 285)</l>
<l>disp_line (WindowHandle, 263, 368, 239, 264)</l>
<l>wait_seconds (5)</l>
<l>dev_set_paint ('default')</l>
<l>dev_display (Selected)</l>
<l>dev_set_line_width (2)</l>
<l>dev_set_draw ('margin')</l>
<l>disp_message (WindowHandle, 'Solder', 'image', 254, 90, 'black', 'true')</l>
<l>dev_set_color ('blue')</l>
<l>dev_display (FinalSol)</l>
<l>dev_set_color ('orange')</l>
<l>dev_display (FinalRes)</l>
<l>disp_message (WindowHandle, 'Top of solder', 'image', 120, 15, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Processed height information', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_color ('yellow')</l>
<l>dev_set_line_width (2)</l>
<l>disp_line (WindowHandle, 114, 208, 122, 191)</l>
<l>disp_line (WindowHandle, 254, 232, 263, 195)</l>
<l>wait_seconds (4)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_resistors">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_balls">
<interface/>
<body>
<c>* </c>
<c>* Inspection of Ball Bonding</c>
<c>* </c>
<l>ImageNames := ['die/die_02','die/die_03','die/die_04','die/die_07']</l>
<l>read_image (Bond, ImageNames[0])</l>
<l>get_image_size (Bond, Width, Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_update_off ()</l>
<c>* </c>
<l>p_set_font (WindowHandle)</l>
<l>get_system ('store_empty_region', StoreEmpty)</l>
<l>set_system ('store_empty_region', 'false')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<l>for k := 1 to 1 by 1</l>
<l>    for I := 0 to |ImageNames| - 1 by 1</l>
<l>        read_image (Bond, ImageNames[I])</l>
<l>        dev_display (Bond)</l>
<l>        min_max_gray (Bond, Bond, 0, Min, Max, Range)</l>
<l>        threshold (Bond, Bright, Max - 80, 255)</l>
<l>        shape_trans (Bright, Die, 'rectangle2')</l>
<l>        dev_set_color ('yellow')</l>
<l>        dev_display (Die)</l>
<l>        reduce_domain (Bond, Die, DieGrey)</l>
<l>        min_max_gray (Die, Bond, 0, Min, Max, Range)</l>
<l>        threshold (DieGrey, Wires, 0, Min + 30)</l>
<l>        fill_up_shape (Wires, WiresFilled, 'area', 1, 100)</l>
<l>        opening_circle (WiresFilled, Balls, 9.5)</l>
<l>        connection (Balls, SingleBalls)</l>
<l>        select_shape_std (SingleBalls, Rect, 'rectangle1', 90)</l>
<l>        difference (SingleBalls, Rect, IntermediateBalls)</l>
<l>        gen_empty_region (Forbidden)</l>
<l>        expand_gray (IntermediateBalls, Bond, Forbidden, RegionExpand, 4, 'image', 6)</l>
<l>        opening_circle (RegionExpand, RoundBalls, 15.5)</l>
<l>        sort_region (RoundBalls, FinalBalls, 'first_point', 'true', 'column')</l>
<l>        smallest_circle (FinalBalls, Row, Column, Radius)</l>
<l>        NumBalls := |Radius|</l>
<l>        Diameter := 2 * Radius</l>
<l>        meanDiameter := sum(Diameter) / NumBalls</l>
<l>        mimDiameter := min(Diameter)</l>
<l>*         dev_display (RoundBalls)</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_set_color ('light gray')</l>
<l>        gen_rectangle1 (Rectangle, Height / 2 - 54 + 3, Width / 2 + 3, Height / 2 - 54 + (|Radius| + 1) * 24 + 3, Width / 2 + 250 + 3)</l>
<l>        dev_display (Rectangle)</l>
<l>        dev_set_color ('white')</l>
<l>        gen_rectangle1 (Rectangle, Height / 2 - 54, Width / 2, Height / 2 - 54 + (|Radius| + 1) * 24, Width / 2 + 250)</l>
<l>        dev_display (Rectangle)</l>
<l>        dev_set_draw ('margin')</l>
<l>        dev_set_color ('black')</l>
<l>        disp_line (WindowHandle, 224, 365, 224, 611)</l>
<l>        disp_line (WindowHandle, 201, 415, 201 + (|Radius| + 1) * 24, 415)</l>
<l>        set_tposition (WindowHandle, Height / 2 - 54, Width / 2)</l>
<l>        write_string (WindowHandle, 'No     Radius')</l>
<l>        for J := 0 to |Radius| - 1 by 1</l>
<l>            select_obj (FinalBalls, ObjectSelected, J + 1)</l>
<l>            dev_set_color ('white')</l>
<l>            set_tposition (WindowHandle, Row[J] - 10, Column[J] - 10)</l>
<l>            write_string (WindowHandle, J + 1)</l>
<l>            dev_set_color ('black')</l>
<l>            set_tposition (WindowHandle, Height / 2 - 30 + J * 24, Width / 2)</l>
<l>            write_string (WindowHandle, (J + 1)$'2d' + '   ' + Radius[J]$'.3f')</l>
<l>            if (Radius[J] &lt; 17)</l>
<l>                dev_set_color ('red')</l>
<l>                write_string (WindowHandle, ' (nok)')</l>
<l>            else</l>
<l>                dev_set_color ('forest green')</l>
<l>                write_string (WindowHandle, '  (ok)')</l>
<l>                dev_set_color ('green')</l>
<l>            endif</l>
<l>            dev_display (ObjectSelected)</l>
<l>        endfor</l>
<l>        disp_message (WindowHandle, 'Inspect the radius of bonding balls on a die', 'window', 12, 12, 'black', 'true')</l>
<l>        wait_seconds (3)</l>
<l>    endfor</l>
<l>endfor</l>
<l>set_system ('store_empty_region', StoreEmpty)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_balls">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_world_plane">
<interface/>
<body>
<c>* </c>
<c>* This example program shows how to recognize planar objects using HALCON's</c>
<c>* shape-based matching if the camera is not mounted perpendicular to the plane</c>
<c>* in which the objects lie. Tho recognize the objects, the images are rectified, i.e.,</c>
<c>* the perspective distortions are removed from the images.  To do so, the camera</c>
<c>* is calibrated and the plane in which the objects lie is obtained from the external</c>
<c>* camera parameters of the image in which the calibration target lies on this plane</c>
<c>* Once this plane is known, the image of the model object can be rectified and</c>
<c>* hence the model can be generated in the world plane, i.e., without distortions.</c>
<c>* Similarly, the search images are also rectified, and hence the shape-based</c>
<c>* matching becomes invariant to perspective distortions.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, 481, 645)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c>* Perform the camera calibration</c>
<l>CaltabName := 'caltab_30mm.descr'</l>
<l>StartCamPar := [0.008,0,0.0000073,0.0000073,323,241,646,482]</l>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, 'area_scan_division', StartCamPar)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CaltabName)</l>
<l>NumImages := 15</l>
<l>for I := 1 to NumImages by 1</l>
<l>    read_image (Image, 'radius-gauges/calib-' + I$'02d')</l>
<l>    dev_display (Image)</l>
<l>    Message := 'Find calibration plate in\nall calibration images (' + I + '/' + NumImages + ')'</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<c>    * Find the calibration plate</c>
<l>    find_calib_object (Image, CalibDataID, 0, 0, I - 1, [], [])</l>
<l>    get_calib_data (CalibDataID, 'camera', 0, 'init_params', StartCamPar)</l>
<l>    get_calib_data_observ_points (CalibDataID, 0, 0, I - 1, Row, Column, Index, Pose)</l>
<l>    get_calib_data_observ_contours (Contours, CalibDataID, 'caltab', 0, 0, I - 1)</l>
<l>    gen_cross_contour_xld (Cross, Row, Column, 6, 0.785398)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (Contours)</l>
<l>    dev_set_color ('yellow')</l>
<l>    dev_display (Cross)</l>
<l>    wait_seconds (0.1)</l>
<l>endfor</l>
<l>calibrate_cameras (CalibDataID, Error)</l>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam)</l>
<l>wait_seconds (3)</l>
<l>read_image (Image, 'radius-gauges/calib-01')</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Recognize metal parts in 3D', 'window', -1, -1, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Image defining the reference plane', 'window', 45, -1, 'black', 'true')</l>
<l>wait_seconds (2)</l>
<c>* The pose of the calibration target in the first image defines a plane that is</c>
<c>* parallel to the plane in which the objects lie.  This pose can be used to see how</c>
<c>* much the camera is rotated with respect to this plane.</c>
<l>get_calib_data (CalibDataID, 'calib_obj_pose', [0,0], 'pose', PoseCalib)</l>
<c>* The pose of the calibration target in the first image defines a plane that is offset</c>
<c>* from the plane in which the objects lie by the thickness of the calibration target.</c>
<c>* Therefore, we need to shift the origin of the pose in the z direction by the</c>
<c>* thickness. Note that the thickness of the calibration target used for this</c>
<c>* example is 0.63 mm. If you adapt this example program to your application, it</c>
<c>* is necessary to determine the thickness of your specific calibration target and to</c>
<c>* use this value instead. Furthermore, we need to shift the origin so that the top left corner</c>
<c>* of the image lies approximately in the top left corner of the rectified image.</c>
<l>set_origin_pose (PoseCalib, -0.066, -0.048, 0.00063, Pose)</l>
<c>* We also need to define the pixel spacing in the rectified image.  In this case,</c>
<c>* we set it to 0.2mm (i.e., 0.0002m).</c>
<l>PixelDist := 0.0002</l>
<c>* We now can compute the mapping function to rectify the image because it does</c>
<c>* not change (the camera does not move with respect to the world plane).</c>
<l>gen_image_to_world_plane_map (Map, CamParam, Pose, 646, 482, 596, 448, PixelDist, 'bilinear')</l>
<c>* We also compute the transformation from the world coordinate system, i.e., the</c>
<c>* coordinate system of the plane, to the camera coordinate system.  This</c>
<c>* transformation is later used to visualize the recognized objects in the distorted</c>
<c>* (i.e., original, unrectified) images.</c>
<l>pose_to_hom_mat3d (Pose, HomMat3D)</l>
<c>* Now that we are able to rectify the images, we can create the shape model.</c>
<l>read_image (Image, 'radius-gauges/radius-gauges-00')</l>
<l>dev_display (Image)</l>
<c>* Display the pose of the world plane.</c>
<l>disp_message (WindowHandle, 'Recognize metal parts in 3D', 'window', -1, -1, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Model image (generating shape model...)', 'window', 45, -1, 'black', 'true')</l>
<l>Message := ['Rotation of the camera:','x axis: ' + PoseCalib[3]$'7.1f' + '°','y axis: ' + PoseCalib[4]$'7.1f' + '°','z axis: ' + PoseCalib[5]$'7.1f' + '°']</l>
<l>disp_message (WindowHandle, Message, 'window', 350, -1, 'black', 'true')</l>
<c>* We rectify the model image and create the shape model in the rectified image.</c>
<l>map_image (Image, Map, ImageRectified)</l>
<l>gen_rectangle1 (Rectangle, 120, 220, 340, 450)</l>
<l>area_center (Rectangle, Area, RowRef, ColumnRef)</l>
<l>reduce_domain (ImageRectified, Rectangle, ImageReduced)</l>
<l>inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 1, 30)</l>
<c>* For visualization purposes, we also create a contour that corresponds to the</c>
<c>* outer boundary of the object.  This is done because the model contains a hole,</c>
<c>* and hence consists of multiple contours.  This allows us to visualize the</c>
<c>* recognized models in the original images in a simplified manner.</c>
<l>gen_contours_skeleton_xld (ModelRegions, Model, 1, 'filter')</l>
<l>select_contours_xld (Model, ModelBorder, 'length', 200, 1000, -0.5, 0.5)</l>
<l>create_shape_model (ImageReduced, 5, 0, rad(360), 'auto', 'none', 'use_polarity', 30, 5, ModelID)</l>
<c>* Now we are going to visualize the model in the original image.  To do so, we</c>
<c>* read out the coordinates of the model points.</c>
<l>get_contour_xld (ModelBorder, Ys, Xs)</l>
<c>* Since we have rectified the image, the pixel coordinates correspond to 0.2mm</c>
<c>* increments.  Since the projection operator expects coordinates in meters, we</c>
<c>* need to multiply them by the pixel distance.</c>
<l>X := Xs * PixelDist</l>
<l>Y := Ys * PixelDist</l>
<l>Z := gen_tuple_const(|X|,0.0)</l>
<c>* We now must transform the model points into the camera coordinate system.</c>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)</l>
<c>* Finally, we can project the points from the camera coordinate system to the</c>
<c>* image plane.</c>
<l>project_3d_point (Xc, Yc, Zc, CamParam, R, C)</l>
<c>* We now create a contour from the projected points.</c>
<l>gen_contour_polygon_xld (ModelWorld, R, C)</l>
<c>* For visualization purposes, we also will display an arrow from the reference</c>
<c>* point of the model.  The arrow is exactly 10mm long and oriented horizontally in</c>
<c>* the world coordinate system.  As with the model, the arrow will be displayed in</c>
<c>* the original image, where it will not be horizontal because of the perspective</c>
<c>* distortion.</c>
<l>X := [ColumnRef * PixelDist,ColumnRef * PixelDist + 1. / 100]</l>
<l>Y := [RowRef * PixelDist,RowRef * PixelDist]</l>
<l>Z := gen_tuple_const(|X|,0.0)</l>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)</l>
<l>project_3d_point (Xc, Yc, Zc, CamParam, R, C)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (ModelWorld)</l>
<l>dev_set_color ('orange')</l>
<l>disp_arrow (WindowHandle, R[0], C[0], R[1], C[1], 2)</l>
<c>* The final part of the program performs the object recognition.  Up to three</c>
<c>* objects will be visible in the images.  Note that these objects are not exactly</c>
<c>* identical.  The circular indentations and protrusions have different radii (5.5mm,</c>
<c>* 6mm, and 6.5mm).  Therefore, in addition to the occlusions of the objects, the</c>
<c>* shape-based matching must compensate for these (significant) variations in</c>
<c>* the objects' shape.  The model was actually created from the object with the</c>
<c>* 6mm radii.</c>
<l>for J := 1 to 3 by 1</l>
<l>    read_image (Image, 'radius-gauges/radius-gauges-' + J$'02d')</l>
<l>    find_shape_model (ImageRectified, ModelID, 0, rad(360), 0.5, 0, 0.5, 'interpolation', 0, 0.9, Row, Column, Angle, Score)</l>
<l>endfor</l>
<l>ImgNo := 11</l>
<l>wait_seconds (3)</l>
<l>for J := 1 to 48 by 1</l>
<l>    read_image (Image, 'radius-gauges/radius-gauges-' + ImgNo$'02d')</l>
<c>    * We will count the time to rectify the image and to find the objects.</c>
<l>    count_seconds (S1)</l>
<l>    map_image (Image, Map, ImageRectified)</l>
<l>    find_shape_model (ImageRectified, ModelID, 0, rad(360), 0.5, 0, 0.5, 'least_squares', 0, 0.8, Row, Column, Angle, Score)</l>
<l>    count_seconds (S2)</l>
<l>    dev_display (Image)</l>
<l>    Time := S2 - S1</l>
<l>    Num := |Score|</l>
<l>    dev_set_color ('white')</l>
<l>    disp_message (WindowHandle, Num$'1d' + ' objects found in ' + (1000 * Time)$'4.1f' + ' ms', 'window', -1, -1, 'black', 'true')</l>
<c>    * We will now project the contours of the found instances of the model back to</c>
<c>    * the perspectively distorted image plane.  The following code is identical to</c>
<c>    * the code above that displays the model in the perspectively distorted image.</c>
<l>    Message := []</l>
<l>    for I := 0 to Num - 1 by 1</l>
<l>        Message := [Message,'Pose ' + I + ': (' + (Column[I] * PixelDist * 1000)$'3.2f' + ', ' + (Row[I] * PixelDist * 1000)$'3.2f' + ')[mm], ' + deg(Angle[I])$'3.2f' + '°']</l>
<l>    endfor</l>
<l>    disp_message (WindowHandle, Message, 'window', 380, -1, 'black', 'true')</l>
<l>    if (Num &gt; 0)</l>
<l>        for I := 0 to Num - 1 by 1</l>
<l>            vector_angle_to_rigid (RowRef, ColumnRef, 0, Row[I], Column[I], Angle[I], HomMat2D)</l>
<l>            affine_trans_contour_xld (ModelBorder, ModelBorderTrans, HomMat2D)</l>
<l>            get_contour_xld (ModelBorderTrans, Ys, Xs)</l>
<l>            X := Xs * PixelDist</l>
<l>            Y := Ys * PixelDist</l>
<l>            Z := gen_tuple_const(|X|,0.0)</l>
<l>            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)</l>
<l>            project_3d_point (Xc, Yc, Zc, CamParam, R, C)</l>
<l>            gen_contour_polygon_xld (ModelWorld, R, C)</l>
<l>            X := [Column[I] * PixelDist,Column[I] * PixelDist + cos(Angle[I]) / 100]</l>
<l>            Y := [Row[I] * PixelDist,Row[I] * PixelDist - sin(Angle[I]) / 100]</l>
<l>            Z := gen_tuple_const(|X|,0.0)</l>
<l>            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)</l>
<l>            project_3d_point (Xc, Yc, Zc, CamParam, R, C)</l>
<l>            dev_set_color ('green')</l>
<l>            dev_display (ModelWorld)</l>
<l>            dev_set_color ('orange')</l>
<l>            disp_arrow (WindowHandle, R[0], C[0], R[1], C[1], 2)</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImgNo := ImgNo + 1</l>
<l>    if (ImgNo &gt; 20)</l>
<l>        ImgNo := 1</l>
<l>    endif</l>
<l>    if (J &lt; 3)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<l>clear_shape_model (ModelID)</l>
<l>clear_calib_data (CalibDataID)</l>
<l>return ()</l>
</body>
<docu id="p_do_world_plane">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_multiple_parts">
<interface/>
<body>
<c>* </c>
<c>* This example program shows how to use HALCON's shape-based matching</c>
<c>* to find multiple different models in one call to find_shape_models.  Note that this</c>
<c>* is one mode of operation that is frequently useful.  However, the number of</c>
<c>* applications that can be solved with this mechanism is much larger.  For</c>
<c>* another application where finding multiple models in one call is useful are</c>
<c>* applications where the same object can only occur in small angle ranges</c>
<c>* around a discrete set of angles, e.g., 0°, 90°, 180°, and 270°.  In these cases,</c>
<c>* it would be wasteful to train the model for the full 360° rotation range and to</c>
<c>* match the model in this range.  Instead, four models using the small angle</c>
<c>* ranges around the discrete set of angles should be generated from the same</c>
<c>* model image and used in the matching stage using four different angle ranges.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 476, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, 481, 645)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c>* These colors will be used to graphically discern the different models in the</c>
<c>* visualization code below.</c>
<l>Colors := ['blue','orange','yellow']</l>
<c>* The models will be generated from hard-coded rectangles given by the</c>
<c>* following coordinates:</c>
<l>Row1 := [135,150,185]</l>
<l>Column1 := [250,170,220]</l>
<l>Row2 := [375,310,335]</l>
<l>Column2 := [355,395,375]</l>
<c>* The object Models will hold a set of XLD contours that represent the different</c>
<c>* models.  They are used below to overlay the found models on the current</c>
<c>* image.  XLD contours are used because they can be transformed much faster</c>
<c>* than regions.  This creates a slight problem because in general multiple XLD</c>
<c>* contours will represent one model.  Therefore, the start and end indices of the</c>
<c>* different models will be stored in IndexS and IndexE, respectively.</c>
<l>gen_empty_obj (Models)</l>
<l>IndexS := []</l>
<l>IndexE := []</l>
<c>* The variable ModelIDs holds the different models that are created below.</c>
<l>ModelIDs := []</l>
<c>* Likewise, RowsRef and ColumnsRef store the reference points of the different</c>
<c>* models.  They are necessary to transform the models to the found instances</c>
<c>* in the current image.</c>
<l>RowsRef := []</l>
<l>ColumnsRef := []</l>
<l>for J := 1 to 3 by 1</l>
<l>    read_image (Image, 'metal-parts/metal-part-model-' + J$'02d')</l>
<l>    dev_display (Image)</l>
<c>    * </c>
<l>    disp_message (WindowHandle, 'Find multiple different metal parts', 'window', 12, 12, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Generating shape model ' + J$'d', 'window', 40, 12, 'black', 'true')</l>
<l>    gen_rectangle1 (Rectangle, Row1[J - 1], Column1[J - 1], Row2[J - 1], Column2[J - 1])</l>
<l>    area_center (Rectangle, Area, Row, Column)</l>
<l>    reduce_domain (Image, Rectangle, ImageReduced)</l>
<l>    inspect_shape_model (Image, ModelImages, ModelRegions, 1, 30)</l>
<c>    * Since the shape models contain a few extraneous edges, they will be</c>
<c>    * removed here to give a slightly nicer visualization.</c>
<l>    connection (ModelRegions, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 20, 100000)</l>
<l>    union1 (SelectedRegions, ModelRegions)</l>
<l>    gen_contours_skeleton_xld (ModelRegions, ModelContours, 1, 'filter')</l>
<l>    dev_set_color (Colors[J - 1])</l>
<l>    dev_display (ModelContours)</l>
<c>    * Count how many XLD contours there are in the current model and in the</c>
<c>    * already stored models.  This is necessary to compute IndexS and IndexE.</c>
<l>    count_obj (ModelContours, NumModel)</l>
<l>    count_obj (Models, NumModels)</l>
<l>    create_shape_model (ImageReduced, 5, rad(0), rad(360), 0, 'pregeneration', 'use_polarity', 30, 10, ModelID)</l>
<l>    concat_obj (Models, ModelContours, Models)</l>
<l>    IndexS := [IndexS,NumModels + 1]</l>
<l>    IndexE := [IndexE,NumModels + NumModel]</l>
<l>    ModelIDs := [ModelIDs,ModelID]</l>
<l>    RowsRef := [RowsRef,Row]</l>
<l>    ColumnsRef := [ColumnsRef,Column]</l>
<l>endfor</l>
<l>for I := 1 to 3 by 1</l>
<l>    read_image (Image, 'metal-parts/metal-parts-' + I$'02d')</l>
<l>    find_shape_models (Image, ModelIDs, rad(0), rad(360), 0.6, 0, 0.5, 'interpolation', 0, 0.6, Row, Column, Angle, Score, Model)</l>
<l>endfor</l>
<l>dev_set_color ('red')</l>
<l>ImgNo := 14</l>
<l>for I := 1 to 60 by 1</l>
<l>    read_image (Image, 'metal-parts/metal-parts-' + ImgNo$'02d')</l>
<l>    count_seconds (S1)</l>
<l>    find_shape_models (Image, ModelIDs, rad(0), rad(360), 0.6, 0, 0.5, 'interpolation', 0, 0.6, Row, Column, Angle, Score, Model)</l>
<l>    count_seconds (S2)</l>
<l>    Time := S2 - S1</l>
<l>    dev_display (Image)</l>
<l>    Num := |Score|</l>
<l>    for J := 0 to Num - 1 by 1</l>
<c>        * Select the correct XLD contours from the Models object.</c>
<l>        copy_obj (Models, ModelSelected, IndexS[Model[J]], IndexE[Model[J]] - IndexS[Model[J]] + 1)</l>
<c>        * Compute the transformation from the model object to the current instance.</c>
<l>        vector_angle_to_rigid (RowsRef[Model[J]], ColumnsRef[Model[J]], 0, Row[J], Column[J], Angle[J], HomMat2D)</l>
<l>        affine_trans_contour_xld (ModelSelected, ModelTrans, HomMat2D)</l>
<l>        dev_set_color (Colors[Model[J]])</l>
<l>        dev_display (ModelTrans)</l>
<l>    endfor</l>
<l>    dev_set_color ('yellow')</l>
<l>    set_tposition (WindowHandle, 20, 20)</l>
<l>    if (Num == 1)</l>
<l>        disp_message (WindowHandle, Num$'1d' + ' object  found in ' + (1000 * Time)$'4.2f' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>    else</l>
<l>        disp_message (WindowHandle, Num$'1d' + ' objects  found in ' + (1000 * Time)$'4.2f' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>    endif</l>
<l>    ImgNo := ImgNo + 1</l>
<l>    if (ImgNo &gt; 15)</l>
<l>        ImgNo := 1</l>
<l>    endif</l>
<l>    if (I &lt; 3)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (1)</l>
<l>for J := 0 to |ModelIDs| - 1 by 1</l>
<l>    clear_shape_model (ModelIDs[J])</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_multiple_parts">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_print_check">
<interface/>
<body>
<c>* </c>
<c>* This example program shows how to use HALCON's variation model operators</c>
<c>* to perform a typical print quality inspection.  The program detects incorrect</c>
<c>* prints on the clips of pens.  In the first step, the variation model is constructed</c>
<c>* from images of correct prints.  Since the position of the objects can vary, the</c>
<c>* images must be transformed to a reference position (the position of the print</c>
<c>* in the first image in this example).  HALCON's shape-based matching is used</c>
<c>* to detect the position and angle of the print in the images.  The found position</c>
<c>* and angle are used to transform the images to the reference position.</c>
<c>* In the second part of the program, the prints of the correct clips and of several</c>
<c>* incorrect clips is checked and classified.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>read_image (Image, 'pen/pen-01')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_display (Image)</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_color ('green')</l>
<l>disp_message (WindowHandle, 'Inspect the print on a pen clip', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* Note: the shape model will be constructed from a ROI that is computed</c>
<c>* automatically based on a simple image segmentation.</c>
<l>threshold (Image, Region, 100, 255)</l>
<l>fill_up (Region, RegionFillUp)</l>
<l>difference (RegionFillUp, Region, RegionDifference)</l>
<l>shape_trans (RegionDifference, RegionTrans, 'convex')</l>
<l>dilation_circle (RegionTrans, RegionDilation, 8.5)</l>
<l>reduce_domain (Image, RegionDilation, ImageReduced)</l>
<l>inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 1, 20)</l>
<l>gen_contours_skeleton_xld (ModelRegions, Model, 1, 'filter')</l>
<l>area_center (RegionDilation, Area, RowRef, ColumnRef)</l>
<l>create_shape_model (ImageReduced, 5, rad(-10), rad(20), 0, 'none', 'use_polarity', 20, 10, ShapeModelID)</l>
<l>create_variation_model (Width, Height, 'byte', 'standard', VariationModelID)</l>
<l>for I := 1 to 15 by 1</l>
<l>    read_image (Image, 'pen/pen-' + I$'02d')</l>
<l>    find_shape_model (Image, ShapeModelID, rad(-30), rad(60), 0.5, 1, 0.5, 'interpolation', 0, 0.9, Row, Column, Angle, Score)</l>
<l>    if (|Score| == 1)</l>
<l>        vector_angle_to_rigid (Row, Column, Angle, RowRef, ColumnRef, 0, HomMat2D)</l>
<l>        affine_trans_image (Image, ImageTrans, HomMat2D, 'constant', 'false')</l>
<l>        train_variation_model (ImageTrans, VariationModelID)</l>
<l>        dev_display (ImageTrans)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (Model)</l>
<l>        disp_message (WindowHandle, 'Train a variation model', 'window', 12, 12, 'black', 'true')</l>
<l>        wait_seconds (0.25)</l>
<l>    endif</l>
<l>endfor</l>
<l>get_variation_model (MeanImage, VarImage, VariationModelID)</l>
<l>prepare_variation_model (VariationModelID, 20, 3)</l>
<c>* Note: the checking of the print will be restricted to the region of the clip.</c>
<c>* Sometimes the print is also in an incorrect position of the clip.  This will lead</c>
<c>* to erroneous regions at the top or bottom border of the clip and hence can</c>
<c>* be detected easily.</c>
<l>erosion_rectangle1 (RegionFillUp, RegionROI, 1, 15)</l>
<l>dev_display (MeanImage)</l>
<l>disp_message (WindowHandle, 'Reference image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>dev_display (VarImage)</l>
<l>disp_message (WindowHandle, 'Variation image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>dev_set_draw ('margin')</l>
<l>for I := 1 to 30 by 2</l>
<l>    read_image (Image, 'pen/pen-' + I$'02d')</l>
<l>    find_shape_model (Image, ShapeModelID, rad(-10), rad(20), 0.5, 1, 0.5, 'interpolation', 0, 0.9, Row, Column, Angle, Score)</l>
<l>    if (|Score| == 1)</l>
<l>        vector_angle_to_rigid (Row, Column, Angle, RowRef, ColumnRef, 0, HomMat2D)</l>
<l>        affine_trans_image (Image, ImageTrans, HomMat2D, 'constant', 'false')</l>
<l>        reduce_domain (ImageTrans, RegionROI, ImageReduced)</l>
<l>        compare_variation_model (ImageReduced, RegionDiff, VariationModelID)</l>
<l>        connection (RegionDiff, ConnectedRegions)</l>
<l>        select_shape (ConnectedRegions, RegionsError, 'area', 'and', 20, 1000000)</l>
<l>        count_obj (RegionsError, NumError)</l>
<l>        dev_clear_window ()</l>
<l>        dev_display (ImageTrans)</l>
<l>        dev_set_color ('red')</l>
<l>        dev_display (RegionsError)</l>
<l>        set_tposition (WindowHandle, 20, 20)</l>
<l>        if (NumError == 0)</l>
<l>            dev_set_color ('green')</l>
<l>            write_string (WindowHandle, 'Clip OK')</l>
<l>            wait_seconds (0.2)</l>
<l>        else</l>
<l>            dev_set_color ('red')</l>
<l>            write_string (WindowHandle, 'Clip not OK')</l>
<l>            wait_seconds (0.5)</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>clear_shape_model (ShapeModelID)</l>
<l>clear_variation_model (VariationModelID)</l>
<l>wait_seconds (1)</l>
<l>return ()</l>
</body>
<docu id="p_do_print_check">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_wood">
<interface/>
<body>
<c>* Determine the age of a tree by counting its annual rings</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<c>* </c>
<l>read_image (WoodPiece1, 'woodring')</l>
<l>get_image_size (WoodPiece1, Width, Height)</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>min_max_gray (WoodPiece1, WoodPiece1, 2, Min, Max, Range)</l>
<l>scale_image (WoodPiece1, ImageScaled, 255 / (Max - Min), -255 / (Max - Min) * Min)</l>
<l>dev_display (ImageScaled)</l>
<l>disp_message (WindowHandle, 'Count annual rings', 'window', -1, -1, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* Segmentation of annual ring</c>
<l>mean_image (WoodPiece1, ImageMean, 9, 9)</l>
<l>dyn_threshold (WoodPiece1, ImageMean, Regions, 5.0, 'dark')</l>
<l>threshold (WoodPiece1, Dark, 0, 90)</l>
<l>dilation_rectangle1 (Dark, DarkDilation, 30, 7)</l>
<l>difference (Regions, DarkDilation, RegionBright)</l>
<c>* Eliminate tiny regions that are no annual rings</c>
<l>connection (RegionBright, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 30, 10000000)</l>
<c>* Define the start and end point of a line across the annual rings</c>
<c>* using the mouse. The number of intersections with annual rings</c>
<c>* is counted along this line</c>
<l>Row1 := 290</l>
<l>Column1 := 6</l>
<l>Row2 := 69.5</l>
<l>Column2 := 1406.5</l>
<l>gen_region_line (Line, Row1, Column1, Row2, Column2)</l>
<l>intersection (Line, SelectedRegions, Inters)</l>
<l>connection (Inters, ConnectedInters)</l>
<l>count_obj (ConnectedInters, Number)</l>
<l>dev_set_color ('green')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<l>dev_display (Line)</l>
<l>disp_message (WindowHandle, 'Age: ' + Number + ' years', 'window', 100, 160, 'black', 'true')</l>
<l>wait_seconds (4)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_wood">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_angio">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>read_image (Angio, 'angio-part')</l>
<l>get_image_size (Angio, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (Angio)</l>
<l>dev_open_window (480 - 260, 640 - 260, 256, 256, 'black', WindowHandle1)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_set_color ('blue')</l>
<l>lines_gauss (Angio, Lines, 2.3, 0, 0.7, 'dark', 'true', 'true', 'true')</l>
<l>count_obj (Lines, Number)</l>
<l>for I := 1 to Number by 1</l>
<l>    disp_message (WindowHandle, 'Measure Vessels in an Angiographic Image', 'window', -1, -1, 'black', 'true')</l>
<l>    select_obj (Lines, Line, I)</l>
<l>    get_contour_xld (Line, Row, Col)</l>
<l>    get_contour_attrib_xld (Line, 'angle', Angle)</l>
<l>    get_contour_attrib_xld (Line, 'width_left', WidthL)</l>
<l>    get_contour_attrib_xld (Line, 'width_right', WidthR)</l>
<c>    * To display the lines, the point at which the gray value drops to</c>
<c>    * 25% of the contrast between the line and the background will be</c>
<c>    * displayed.  This point is given by sqrt(3/4) for the parabolic</c>
<c>    * line model.</c>
<l>    RowR := Row + cos(Angle) * WidthR * sqrt(0.75)</l>
<l>    ColR := Col + sin(Angle) * WidthR * sqrt(0.75)</l>
<l>    RowL := Row - cos(Angle) * WidthL * sqrt(0.75)</l>
<l>    ColL := Col - sin(Angle) * WidthL * sqrt(0.75)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (Line)</l>
<l>    dev_set_color ('green')</l>
<l>    disp_polygon (WindowHandle, RowL, ColL)</l>
<l>    disp_polygon (WindowHandle, RowR, ColR)</l>
<l>endfor</l>
<l>for I := 1 to Number by 1</l>
<l>    select_obj (Lines, Line, I)</l>
<l>    get_contour_xld (Line, Row, Col)</l>
<l>    if (|Row| &gt; 100 and not (I % 2))</l>
<l>        get_contour_attrib_xld (Line, 'angle', Angle)</l>
<l>        get_contour_attrib_xld (Line, 'width_left', WidthL)</l>
<l>        get_contour_attrib_xld (Line, 'width_right', WidthR)</l>
<l>        RowR := Row + cos(Angle) * WidthR</l>
<l>        ColR := Col + sin(Angle) * WidthR</l>
<l>        RowL := Row - cos(Angle) * WidthL</l>
<l>        ColL := Col - sin(Angle) * WidthL</l>
<l>        for J := 0 to |Row| - 1 by 1</l>
<l>            count_seconds (Seconds1)</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (Line)</l>
<l>            dev_set_color ('yellow')</l>
<l>            disp_circle (WindowHandle, Row[J], Col[J], 1.5)</l>
<l>            dev_set_window (WindowHandle1)</l>
<l>            dev_set_part (round(Row[J] - 12), round(Col[J] - 12), round(Row[J] + 12), round(Col[J] + 12))</l>
<l>            dev_display (Angio)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (Line)</l>
<l>            dev_set_color ('green')</l>
<l>            disp_polygon (WindowHandle1, RowL, ColL)</l>
<l>            disp_polygon (WindowHandle1, RowR, ColR)</l>
<l>            dev_set_color ('yellow')</l>
<l>            disp_circle (WindowHandle1, Row[J], Col[J], 1.5)</l>
<l>            count_seconds (Seconds2)</l>
<l>            if (I == 10)</l>
<l>                ProcessedTime := Seconds2 - Seconds1</l>
<l>                wait_seconds (max([0.04 - ProcessedTime,0]))</l>
<l>            endif</l>
<l>        endfor</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    endif</l>
<l>endfor</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (Lines)</l>
<l>dev_set_color ('red')</l>
<l>dev_set_line_width (1)</l>
<l>dev_display (Lines)</l>
<l>wait_seconds (3)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_close_window ()</l>
<l>return ()</l>
</body>
<docu id="p_do_angio">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_roads">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>PartWidth := 512</l>
<l>PartHeight := 512</l>
<l>TopRow := 250</l>
<l>TopCol := 600</l>
<c>* </c>
<l>read_image (Part, 'mreut_y')</l>
<l>read_image (Mreut43, 'mreut4_3')</l>
<l>get_image_size (Mreut43, Mreut43Width, Mreut43Height)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, Mreut43Width, Mreut43Height, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Mreut43Height - 1, Mreut43Width - 1)</l>
<l>dev_display (Mreut43)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>disp_message (WindowHandle, 'Extract road centers from aerial image', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_line_width (3)</l>
<l>wait_seconds (3)</l>
<l>threshold (Mreut43, Bright, 160, 255)</l>
<l>reduce_domain (Mreut43, Bright, Mreut43Bright)</l>
<l>lines_gauss (Mreut43Bright, RoadCenters, 1.2, 5, 14, 'light', 'true', 'bar-shaped', 'true')</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_scale (HomMat2DIdentity, 8, 8, 0, 0, HomMat2DScale)</l>
<l>hom_mat2d_translate (HomMat2DScale, -TopRow, -TopCol, HomMat2DTranslate)</l>
<l>affine_trans_contour_xld (RoadCenters, ScaledRoadCenters, HomMat2DTranslate)</l>
<l>clip_contours_xld (ScaledRoadCenters, ClippedRoadCenters, 0, 0, PartWidth, PartHeight)</l>
<l>gen_polygons_xld (ClippedRoadCenters, RoadCenterPolygons, 'ramer', 2)</l>
<l>dev_set_colored (6)</l>
<l>dev_display (RoadCenters)</l>
<l>disp_message (WindowHandle, 'Extract road centers from aerial image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>dev_set_part (0, 0, PartHeight - 1, PartWidth - 1)</l>
<l>dev_display (Part)</l>
<l>disp_message (WindowHandle, 'Extract road sides from aerial image', 'window', 12, 12, 'black', 'true')</l>
<l>edges_image (Part, PartAmp, PartDir, 'mderiche2', 0.3, 'nms', 20, 40)</l>
<l>threshold (PartAmp, EdgeRegion, 1, 255)</l>
<l>clip_region (EdgeRegion, ClippedEdges, 2, 2, PartWidth - 3, PartHeight - 3)</l>
<l>skeleton (ClippedEdges, EdgeSkeleton)</l>
<l>gen_contours_skeleton_xld (EdgeSkeleton, RoadEdges, 1, 'filter')</l>
<l>gen_polygons_xld (RoadEdges, RoadEdgePolygons, 'ramer', 2)</l>
<l>gen_parallels_xld (RoadEdgePolygons, ParallelRoadEdges, 10, 30, 0.15, 'true')</l>
<l>mod_parallels_xld (ParallelRoadEdges, Part, ModParallelRoadEdges, ExtParallelRoadEdges, 0.3, 160, 220, 10)</l>
<l>combine_roads_xld (RoadEdgePolygons, ModParallelRoadEdges, ExtParallelRoadEdges, RoadCenterPolygons, RoadSides, rad(40), rad(20), 40, 40)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (RoadSides)</l>
<l>dev_set_line_width (1)</l>
<l>disp_message (WindowHandle, 'Extract road sides from aerial image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_roads">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_xing">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<l>read_image (Image, 'xing/init')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<c>* </c>
<l>read_region (XingRegion, 'xing/xing_region')</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_colored (12)</l>
<l>dev_set_line_width (3)</l>
<l>dev_display (Image)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>disp_message (WindowHandle, 'Monitor cars and people on a crossing', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, 'constant')</l>
<l>create_bg_esti (ImageZoomed, 0.7, 0.7, 'fixed', 0.001, 0.03, 'on', 8.0, 10, 3.25, 15, BgEstiHandle)</l>
<l>for I := 120 to 420 by 1</l>
<l>    read_image (ActualImage, 'xing/xing' + (I$'03'))</l>
<l>    zoom_image_factor (ActualImage, ImageZoomed, 0.5, 0.5, 'constant')</l>
<l>    run_bg_esti (ImageZoomed, ForegroundRegion, BgEstiHandle)</l>
<l>    zoom_region (ForegroundRegion, RegionZoom, 2, 2)</l>
<l>    intersection (RegionZoom, XingRegion, RegionIntersection)</l>
<l>    connection (RegionIntersection, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 20, 99999)</l>
<l>    shape_trans (SelectedRegions, RegionTrans, 'convex')</l>
<l>    union1 (RegionTrans, RegionUnion)</l>
<l>    connection (RegionUnion, FinalConnected)</l>
<l>    select_gray (FinalConnected, ActualImage, SelectedRegionsGray, 'deviation', 'and', 25, 1000)</l>
<l>    union1 (SelectedRegionsGray, RegionUnionFinal)</l>
<l>    dilation_rectangle1 (RegionUnionFinal, RegionDilation, 5, 5)</l>
<l>    complement (RegionDilation, BackGround)</l>
<l>    clip_region (BackGround, RegionClipped, 0, 0, Height - 1, Width - 1)</l>
<l>    zoom_region (RegionClipped, BackGroundZoom, 0.5, 0.5)</l>
<l>    update_bg_esti (ImageZoomed, BackGroundZoom, BgEstiHandle)</l>
<l>    shape_trans (SelectedRegionsGray, Rects, 'rectangle1')</l>
<c>    * </c>
<l>    set_system ('flush_graphic', 'false')</l>
<l>    dev_display (ActualImage)</l>
<l>    dev_set_color ('orange')</l>
<l>    dev_display (Rects)</l>
<l>    disp_message (WindowHandle, 'Monitor cars and people on a crossing', 'window', 12, 12, 'black', 'true')</l>
<l>    set_system ('flush_graphic', 'true')</l>
<l>    set_tposition (WindowHandle, -10, -10)</l>
<l>    write_string (WindowHandle, '')</l>
<l>endfor</l>
<l>close_bg_esti (BgEstiHandle)</l>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_xing">
<parameters/>
</docu>
</procedure>
<procedure name="p_set_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>return ()</l>
</body>
<docu id="p_set_font">
<parameters>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_mosaicking">
<interface/>
<body>
<c>* This example program shows how several images can be combined</c>
<c>* into a large mosaic image.  The program shows how to use</c>
<c>* proj_match_points_ransac, bundle_adjust_mosaic, and</c>
<c>* gen_bundle_adjusted_mosaic to achieve this.</c>
<c>* </c>
<c>* Set image path and name</c>
<l>ImgPath := '3d_machine_vision/mosaic/'</l>
<l>ImgName := 'bga_r_'</l>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle1)</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_color ('green')</l>
<l>p_set_font (WindowHandle1)</l>
<c>* The internal camera parameters of the used camera (necessary only, if the</c>
<c>* radial distortions are to be eliminated)</c>
<l>CamParam := [0.0121693,-2675.63,7.40046e-006,7.4e-006,290.491,258.887,640,480]</l>
<l>change_radial_distortion_cam_par ('adaptive', CamParam, 0, CamParOut)</l>
<c>* Read in the images and show them one-by-one.</c>
<l>gen_empty_obj (Images)</l>
<l>SelectedImages := [1,2,3,6,7,8]</l>
<l>for J := 1 to 6 by 1</l>
<l>    I := SelectedImages[J - 1]</l>
<l>    read_image (Image, ImgPath + ImgName + I$'02')</l>
<l>    get_image_size (Image, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    change_radial_distortion_image (Image, Image, Image, CamParam, CamParOut)</l>
<l>    concat_obj (Images, Image, Images)</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle1, 'Create mosaic from 6 images', 'window', -1, -1, 'black', 'true')</l>
<l>    disp_message (WindowHandle1, 'Image ' + J$'d', 'window', 40, -1, 'black', 'true')</l>
<l>    wait_seconds (0.7)</l>
<l>endfor</l>
<c>* To show the point matches that are used to compute the projective</c>
<c>* transformation between the images, we will show all images in a large</c>
<c>* tiled image with some space between the images so that the extents</c>
<c>* of the images are easily visible.</c>
<l>dev_set_window_extents (-1, -1, 1960 / 3.0625, 980 / 3.0625)</l>
<l>dev_set_part (0, 0, 979, 1959)</l>
<l>tile_images_offset (Images, TiledImage, [0,0,0,500,500,500], [0,660,1320,0,660,1320], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], 1960, 980)</l>
<l>dev_clear_window ()</l>
<l>dev_display (TiledImage)</l>
<l>dev_set_color ('green')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<l>for I := 1 to 6 by 1</l>
<l>    if (I &lt; 4)</l>
<l>        gen_rectangle1 (Rectangle, 0, (I - 1) * 660, 480, I * 660 - 20)</l>
<l>        dev_display (Rectangle)</l>
<l>    else</l>
<l>        gen_rectangle1 (Rectangle, 500, (I - 4) * 660, 980, (I - 3) * 660 - 20)</l>
<l>        dev_display (Rectangle)</l>
<l>    endif</l>
<l>endfor</l>
<l>disp_message (WindowHandle1, 'All 6 images', 'window', -1, -1, 'black', 'true')</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_draw ('fill')</l>
<l>wait_seconds (3)</l>
<c>* Now we compute point matches between pairs of images and with this</c>
<c>* the projective transformation between the image pairs.</c>
<l>dev_clear_window ()</l>
<l>dev_display (TiledImage)</l>
<l>disp_message (WindowHandle1, 'Point matches used for bundle adjustment', 'window', -1, -1, 'black', 'true')</l>
<l>From := [1,1,1,4,2,2,2,2,5,3,3]</l>
<l>To := [4,5,2,5,4,5,6,3,6,5,6]</l>
<l>Num := |From|</l>
<c>* We need a variable to accumulate the projective transformation matrices,</c>
<c>* the coordinates of the matched points, and the number of matched</c>
<c>* points for each image pair.</c>
<l>ProjMatrices := []</l>
<l>Rows1 := []</l>
<l>Cols1 := []</l>
<l>Rows2 := []</l>
<l>Cols2 := []</l>
<l>NumCorrespondences := []</l>
<c>* Now we can determine the transformations between the image pairs.</c>
<l>for J := 0 to Num - 1 by 1</l>
<l>    F := From[J]</l>
<l>    T := To[J]</l>
<l>    select_obj (Images, ImageF, F)</l>
<l>    select_obj (Images, ImageT, T)</l>
<c>    * Extract the points in both images.</c>
<l>    SigmaGrad := 1</l>
<l>    SigmaSmooth := 3</l>
<l>    Alpha := 0.04</l>
<l>    Threshold := 0</l>
<l>    points_harris (ImageF, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowFAll, ColFAll)</l>
<l>    points_harris (ImageT, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowTAll, ColTAll)</l>
<c>    * Define initial values for the position of the search window</c>
<l>    if (F &gt; 3)</l>
<l>        FShiftR := 500</l>
<l>        FShiftC := (F - 4) * 660</l>
<l>    else</l>
<l>        FShiftR := 0</l>
<l>        FShiftC := (F - 1) * 660</l>
<l>    endif</l>
<l>    if (T &gt; 3)</l>
<l>        TShiftR := 500</l>
<l>        TShiftC := (T - 4) * 660</l>
<l>    else</l>
<l>        TShiftR := 0</l>
<l>        TShiftC := (T - 1) * 660</l>
<l>    endif</l>
<l>    RowMove := (FShiftR - TShiftR) / 2.7</l>
<l>    ColMove := (FShiftC - TShiftC) / 2</l>
<c>    * Perform the matching</c>
<l>    MaskSize := 21</l>
<l>    RowTolerance := 20</l>
<l>    ColTolerance := 20</l>
<l>    Rotation := 0</l>
<l>    MatchThreshold := 50</l>
<l>    DistanceThreshold := 0.25</l>
<l>    RandSeed := 4364537</l>
<l>    proj_match_points_ransac (ImageF, ImageT, RowFAll, ColFAll, RowTAll, ColTAll, 'sad', MaskSize, RowMove, ColMove, RowTolerance, ColTolerance, Rotation, MatchThreshold, 'gold_standard', DistanceThreshold, RandSeed, ProjMatrix, Points1, Points2)</l>
<c>    * Accumulate the transformation matrices</c>
<l>    ProjMatrices := [ProjMatrices,ProjMatrix]</l>
<c>    * and the matched points.</c>
<l>    Rows1 := [Rows1,subset(RowFAll,Points1)]</l>
<l>    Cols1 := [Cols1,subset(ColFAll,Points1)]</l>
<l>    Rows2 := [Rows2,subset(RowTAll,Points2)]</l>
<l>    Cols2 := [Cols2,subset(ColTAll,Points2)]</l>
<l>    NumCorrespondences := [NumCorrespondences,|Points1|]</l>
<c>    * Generate crosses that represent the extracted points in the tiled image.</c>
<c>    * Note that we have to take the row offsets of the images in the tiled image</c>
<c>    * into account.</c>
<l>    gen_cross_contour_xld (PointsF, RowFAll + FShiftR, ColFAll + FShiftC, 6, rad(45))</l>
<l>    gen_cross_contour_xld (PointsT, RowTAll + TShiftR, ColTAll + TShiftC, 6, rad(45))</l>
<c>    * Generate a representation of the matched point pairs as lines.  We create</c>
<c>    * XLD contours from the lines so that we can zoom into the graphics window</c>
<c>    * to take a closer look at the matches.</c>
<l>    RowF := subset(RowFAll,Points1) + FShiftR</l>
<l>    ColF := subset(ColFAll,Points1) + FShiftC</l>
<l>    RowT := subset(RowTAll,Points2) + TShiftR</l>
<l>    ColT := subset(ColTAll,Points2) + TShiftC</l>
<l>    gen_empty_obj (Matches)</l>
<l>    for K := 0 to |RowF| - 1 by 1</l>
<l>        gen_contour_polygon_xld (Match, [RowF[K],RowT[K]], [ColF[K],ColT[K]])</l>
<l>        concat_obj (Matches, Match, Matches)</l>
<l>    endfor</l>
<c>    * Now display the extracted data.</c>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (Matches)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (PointsF)</l>
<l>    dev_display (PointsT)</l>
<l>    disp_message (WindowHandle1, 'Point matches used for bundle adjustment', 'window', -1, -1, 'black', 'true')</l>
<l>endfor</l>
<l>wait_seconds (3)</l>
<c>* Set the stacking order</c>
<l>StartImage := 2</l>
<l>StackingOrder := [4,5,6,1,2,3]</l>
<c>* Finally, we can generate the bundle adjusted mosaic image from the projective transformations.</c>
<l>bundle_adjust_mosaic (6, StartImage, From, To, ProjMatrices, Rows1, Cols1, Rows2, Cols2, NumCorrespondences, 'projective', MosaicMatrices2D, Rows, Cols, Error)</l>
<l>gen_bundle_adjusted_mosaic (Images, MosaicImage, MosaicMatrices2D, StackingOrder, 'false', TransMat2D)</l>
<l>get_image_size (MosaicImage, Width, Height)</l>
<l>dev_set_window_extents (-1, -1, 640, Height * 640. / Width)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_clear_window ()</l>
<l>dev_display (MosaicImage)</l>
<l>disp_message (WindowHandle1, 'Image mosaic', 'window', -1, -1, 'black', 'true')</l>
<l>wait_seconds (4)</l>
<c>* To investigate the seam between two images, we first display the borders</c>
<c>* of the individual images.</c>
<c>* This can be done most easily by creating an image that contains the border</c>
<c>* of the images, generating a mosaic from it, and segmenting the resulting</c>
<c>* mosaic image.</c>
<l>get_image_size (Image, Width, Height)</l>
<l>gen_image_const (ImageBlank, 'byte', Width, Height)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, Height - 1, Width - 1)</l>
<l>paint_region (Rectangle, ImageBlank, ImageBorder, 255, 'margin')</l>
<l>gen_empty_obj (ImagesBorder)</l>
<l>for J := 1 to 6 by 1</l>
<l>    concat_obj (ImagesBorder, ImageBorder, ImagesBorder)</l>
<l>endfor</l>
<l>gen_bundle_adjusted_mosaic (ImagesBorder, MosaicImageBorder, MosaicMatrices2D, StackingOrder, 'false', TransMat2D)</l>
<l>threshold (MosaicImageBorder, Seams, 128, 255)</l>
<l>dev_clear_window ()</l>
<l>dev_display (MosaicImage)</l>
<l>set_tposition (WindowHandle1, 20, 10)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Seams)</l>
<l>disp_message (WindowHandle1, 'Seams between the images', 'window', -1, -1, 'black', 'true')</l>
<l>dev_set_color ('blue')</l>
<c>* Now, open a zoom window, showing the area around</c>
<c>* the seam between images 2,3,5,6.</c>
<l>get_image_size (MosaicImage, Width, Height)</l>
<l>PartHeight := 85</l>
<l>PartWidth := 320</l>
<l>PartCenterRow := 486</l>
<l>PartCenterCol := 329</l>
<l>dev_open_window (Height * 640. / Width + 66, 0, PartWidth * 2, PartHeight * 2, 'black', WindowHandle2)</l>
<l>p_set_font (WindowHandle2)</l>
<l>dev_set_part (PartCenterRow - PartHeight / 2 + 1, PartCenterCol - PartWidth / 2 + 1, PartCenterRow + PartHeight / 2, PartCenterCol + PartWidth / 2)</l>
<l>dev_display (MosaicImage)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Seams)</l>
<l>disp_message (WindowHandle2, 'Close-up view', 'window', -1, -1, 'black', 'true')</l>
<l>dev_set_window (WindowHandle1)</l>
<l>get_image_size (MosaicImage, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_set_line_width (3)</l>
<l>* dev_display (MosaicImage)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('blue')</l>
<l>disp_rectangle1 (WindowHandle1, PartCenterRow - PartHeight / 2 + 1, PartCenterCol - PartWidth / 2 + 1, PartCenterRow + PartHeight / 2, PartCenterCol + PartWidth / 2)</l>
<l>wait_seconds (6)</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_window (WindowHandle2)</l>
<l>dev_close_window ()</l>
<l>return ()</l>
</body>
<docu id="p_do_mosaicking">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_grid_rectification">
<interface/>
<body>
<c>* This example illustrates how to use the operators for the grid-rectification.</c>
<c>* </c>
<c>* The following command creates a postscript file</c>
<c>* that contains the rectification grid. This grid must be</c>
<c>* printed. Then it must be mounted on the object surface.</c>
<l>WidthOfGrid := 0.17</l>
<l>NumSquares := 17</l>
<c>* </c>
<c>* Read the image of the object wrapped by the rectification grid</c>
<c>* and reopen the window with an appropriate size.</c>
<l>read_image (ImageCan, 'can')</l>
<l>get_image_size (ImageCan, ImageWidth, ImageHeight)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowID1)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>p_set_font (WindowID1)</l>
<l>dev_display (ImageCan)</l>
<l>disp_message (WindowID1, 'Rectify the surface of a can', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* Part 1: Determination of the image map</c>
<c>* The surface to be rectified is wrapped by a checkered pattern, which</c>
<c>* is used to determine the mapping between the distorted image and</c>
<c>* the rectified image. Note the orientation of the two circular marks. When</c>
<c>* in gen_grid_rectification_map() the parameter Rotation is 'auto', the rectified</c>
<c>* image is rotated such that the black mark is left of the white mark.</c>
<c>* </c>
<l>read_image (Image, 'can_with_grid')</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowID1, 'Apply rectification grid', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* Determination of the region that contains the rectification grid.</c>
<l>MinContrast := 25</l>
<l>Radius := 10</l>
<l>find_rectification_grid (Image, GridRegion, MinContrast, Radius)</l>
<l>reduce_domain (Image, GridRegion, ImageReduced)</l>
<c>* </c>
<c>* Determination of the grid points.</c>
<l>SigmaSaddlePoints := 1.5</l>
<l>Threshold := 5</l>
<l>saddle_points_sub_pix (ImageReduced, 'facet', SigmaSaddlePoints, Threshold, Row, Col)</l>
<l>gen_cross_contour_xld (SaddlePoints, Row, Col, 6, 0.785398)</l>
<c>* </c>
<c>* Determination of the image map.</c>
<l>SigmaConnectGridPoints := 0.9</l>
<l>MaxDist := 5.0</l>
<l>GridSpacing := 20</l>
<l>connect_grid_points (ImageReduced, ConnectingLines, Row, Col, SigmaConnectGridPoints, MaxDist)</l>
<l>gen_grid_rectification_map (ImageReduced, ConnectingLines, Map, Meshes, GridSpacing, 0, Row, Col, 'bilinear')</l>
<l>map_image (ImageReduced, Map, ImageMapped)</l>
<c>* </c>
<l>p_grid_visualization_of_intermediate_results (Image, ConnectingLines, Meshes, Map, ImageMapped, SaddlePoints, WindowID1, ImageWidth, WindowID2)</l>
<c>* </c>
<c>* Part 2: Application of the image map</c>
<c>* The original surface (without the checkered pattern) is rectified</c>
<c>* using the previously calculated image map.</c>
<c>* </c>
<c>* Read in the image to be rectified.</c>
<l>disp_message (WindowID1, 'Original image', 'window', 12, 12, 'black', 'true')</l>
<c>* </c>
<c>* Rectification of the image using the previously calculated image map.</c>
<l>map_image (ImageCan, Map, ImageCanMapped)</l>
<c>* </c>
<l>p_grid_visualization_of_results (ImageCan, ImageCanMapped, WindowID1, WindowID2)</l>
<c>* </c>
<l>wait_seconds (3)</l>
<c>* Try to read the barcodes</c>
<l>p_grid_read_and_display_1d_bar_code (ImageCanMapped, [], WindowID2)</l>
<l>wait_seconds (4)</l>
<l>dev_set_window (WindowID2)</l>
<l>dev_close_window ()</l>
<l>return ()</l>
</body>
<docu id="p_do_grid_rectification">
<parameters/>
</docu>
</procedure>
<procedure name="p_grid_visualization_of_intermediate_results">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ConnectingLines" base_type="iconic" dimension="0"/>
<par name="Meshes" base_type="iconic" dimension="0"/>
<par name="Map" base_type="iconic" dimension="0"/>
<par name="ImageMapped" base_type="iconic" dimension="0"/>
<par name="SaddlePoints" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowID1" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowID2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>dev_set_window (WindowID1)</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Meshes)</l>
<l>disp_message (WindowID1, 'Meshes used for rectification', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (2)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 320, 240, 'black', WindowID1)</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowID1)</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Meshes)</l>
<l>disp_message (WindowID1, 'Original grid', 'window', 12, 12, 'black', 'true')</l>
<l>get_image_size (Map, MapWidth, MapHeight)</l>
<l>dev_open_window (0, 334, 305, MapHeight * 305. / MapWidth, 'black', WindowID2)</l>
<l>dev_set_part (0, 0, MapHeight - 1, MapWidth - 1)</l>
<l>p_set_font (WindowID2)</l>
<l>dev_display (ImageMapped)</l>
<l>disp_message (WindowID2, 'Rectified grid', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<l>return ()</l>
</body>
<docu id="p_grid_visualization_of_intermediate_results">
<short lang="en_US">Visualizes the intermediate results of the example program.</short>
<parameters>
<parameter id="ConnectingLines"/>
<parameter id="Image"/>
<parameter id="ImageMapped"/>
<parameter id="ImageWidth"/>
<parameter id="Map"/>
<parameter id="Meshes"/>
<parameter id="SaddlePoints"/>
<parameter id="WindowID1"/>
<parameter id="WindowID2"/>
</parameters>
</docu>
</procedure>
<procedure name="p_grid_visualization_of_results">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ImageMapped" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowID1" base_type="ctrl" dimension="0"/>
<par name="WindowID2" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_set_window (WindowID1)</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowID1, 'Original image', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_window (WindowID2)</l>
<l>get_image_size (ImageMapped, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (ImageMapped)</l>
<l>disp_message (WindowID2, 'Rectified image', 'window', 12, 12, 'black', 'true')</l>
<l>return ()</l>
</body>
<docu id="p_grid_visualization_of_results">
<parameters>
<parameter id="Image"/>
<parameter id="ImageMapped"/>
<parameter id="WindowID1"/>
<parameter id="WindowID2"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_2dbarcode">
<interface/>
<body>
<l>read_image (ImageECC200, 'datacode/ecc200/ecc200_disturbed_005')</l>
<l>crop_rectangle1 (ImageECC200, ImageECC200Part, 110, 30, 110 + 284, 30 + 284)</l>
<l>read_image (ImageQRCode, 'datacode/qrcode/qr_workpiece_05')</l>
<l>crop_rectangle1 (ImageQRCode, ImageQRCodePart, 110, 60, 110 + 284, 60 + 284)</l>
<l>read_image (ImagePDF417, 'datacode/pdf417/pdf417_misc_06')</l>
<l>crop_rectangle1 (ImagePDF417, ImagePDF417Parts, [190,190], [60,60 + 285], [190 + 284,190 + 284], [60 + 284,60 + 285 + 284])</l>
<l>read_image (ImageMicroQR, 'datacode/micro_qr/micro_qr_cell_phone_02')</l>
<l>crop_rectangle1 (ImageMicroQR, ImageMicroQRPart, 110, 160, 110 + 284, 160 + 284)</l>
<l>read_image (ImageAztec, 'datacode/aztec/aztec_ticket_04')</l>
<l>crop_rectangle1 (ImageAztec, ImageAztecPart, 170, 130, 170 + 284, 130 + 284)</l>
<l>concat_obj (ImageQRCodePart, ImageECC200Part, Images)</l>
<l>concat_obj (Images, ImageAztecPart, Images)</l>
<l>concat_obj (Images, ImageMicroQRPart, Images)</l>
<l>concat_obj (Images, ImagePDF417Parts, Images)</l>
<l>tile_images (Images, TiledImage, 3, 'horizontal')</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 50, 'black', WindowHandle)</l>
<l>p_set_font (WindowHandle)</l>
<l>disp_message (WindowHandle, 'Find and decode 2D data codes', 'window', -1, -1, 'black', 'true')</l>
<c>* </c>
<l>dev_open_window_fit_image (TiledImage, 113, 0, 640, -1, WindowHandle1)</l>
<l>p_set_font (WindowHandle1)</l>
<l>dev_display (TiledImage)</l>
<c>* </c>
<l>disp_message (WindowHandle1, 'QR code', 'image', 240, 12, 'black', 'true')</l>
<l>disp_message (WindowHandle1, 'ECC 200', 'image', 240, 12 + 284, 'black', 'true')</l>
<l>disp_message (WindowHandle1, 'Aztec code', 'image', 240, 12 + 284 + 284, 'black', 'true')</l>
<l>disp_message (WindowHandle1, 'Micro QR', 'image', 240 + 284, 12, 'black', 'true')</l>
<l>disp_message (WindowHandle1, 'PDF 417', 'image', 240 + 284, 12 + 284, 'black', 'true')</l>
<c>* </c>
<l>wait_seconds (4)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_close_window ()</l>
<c>* </c>
<l>p_do_qrcode ()</l>
<l>p_do_ecc200 ()</l>
<l>p_do_aztec ()</l>
<l>p_do_microqr ()</l>
<l>p_do_pdf417 ()</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_2dbarcode">
<parameters/>
</docu>
</procedure>
<procedure name="p_grid_read_and_display_1d_bar_code">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="BarCodeDescr" base_type="ctrl" dimension="0"/>
<par name="Window" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>create_bar_code_model ([], [], BarCodeHandle)</l>
<l>set_bar_code_param (BarCodeHandle, 'element_size_min', 1.5)</l>
<l>find_bar_code (Image, CodeRegion, BarCodeHandle, 'EAN-13', DecodedDataStrings)</l>
<l>BarcodeFound := |DecodedDataStrings| &gt; 0</l>
<l>clear_bar_code_model (BarCodeHandle)</l>
<l>dev_set_line_width (2)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (CodeRegion)</l>
<l>if (BarcodeFound == 1)</l>
<l>    disp_message (Window, ['Bar code: ',DecodedDataStrings], 'window', 40, -1, 'black', 'true')</l>
<l>else</l>
<l>    disp_message (Window, 'No bar code found.', 'window', 40, -1, 'black', 'true')</l>
<l>endif</l>
<l>dev_set_draw ('fill')</l>
<l>dev_set_line_width (2)</l>
<l>return ()</l>
</body>
<docu id="p_grid_read_and_display_1d_bar_code">
<short lang="en_US">Searches a 1D bar code, reads it, and displays the result</short>
<parameters>
<parameter id="BarCodeDescr"/>
<parameter id="Image"/>
<parameter id="Window"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_ecc200">
<interface/>
<body>
<c>* *****************************************************************************</c>
<c>* Example program for demonstrating the 2d data code operators.</c>
<c>* *****************************************************************************</c>
<c>* This example program runs through an image sequence looking for</c>
<c>* 2d data code symbols (ECC 200, data matrix).</c>
<c>* This program uses the model without any adaptions, tuning, or</c>
<c>* symbol specific modifications.</c>
<c>* Only the opportunity to switch the complete set of model</c>
<c>* parameters from the standard to the enhanced settings is</c>
<c>* demonstrated.</c>
<c>* Searching the symbols with the standard setting is faster,</c>
<c>* especially, if no readable symbol is found.  On the other hand,</c>
<c>* there are a number of restrictions concerning the symbol size,</c>
<c>* the module size, the polarity, and the minimum contrast, that</c>
<c>* prevent a number of symbols from being detected.</c>
<c>* </c>
<c>* Number of image files contained in the sequence</c>
<l>Paths := ['datacode/ecc200/ecc200_disturbed_','datacode/ecc200/ecc200_cpu_']</l>
<l>Sequence := [1:20]</l>
<l>Numbers := Sequence$'.03'</l>
<l>FileNames := Paths[0] + Numbers[0:16]</l>
<l>FileNames := [FileNames,Paths[1] + Numbers]</l>
<c>* </c>
<c>* The first two images in the array are specially illustrative of</c>
<c>* the difficulty of the task at hand, therefore there will be shown</c>
<c>* in more detail</c>
<l>FileNames := [FileNames[12],FileNames[19],FileNames]</l>
<c>* </c>
<l>read_image (Image, FileNames[2])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>get_string_extents (WindowHandle, 'decqde-Err: ', Ascent, Descent, TWidth, THeight)</l>
<c>* </c>
<c>* Create a 2d data code model.</c>
<c>* --------------------------------------------------</c>
<c>* This model describes the symbol class that is searched and serves as a</c>
<c>* container for collecting the results during the symbol search in order to</c>
<c>* access them later by the get_data_code_2d_* operators.</c>
<c>* You can choose between two default parameter settings:</c>
<c>* the standard and an enhanced one.</c>
<c>* --------------------------------------------------</c>
<c>* --------   ATTENTION !!!   --------</c>
<c>* --------------------------------------------------</c>
<c>* Please recognize that there are symbols that cannot be found with the</c>
<c>* standard default parameters.</c>
<c>* The reasons for that are:</c>
<c>* + the contrast is too low</c>
<c>* + some symbols are printed light on dark, which is not covered by</c>
<c>* the standard model</c>
<c>* + the symbols are too big (&gt;48x48 modules)</c>
<c>* + the modules are printed as small unconnected dots</c>
<c>* Changing the default parameter set to 'enhanced recognition' enables</c>
<c>* HALCON to find most of the symbols that couldn't be detected before.</c>
<c>* The price for the improved recognition rate is an increasing runtime,</c>
<c>* especially when no datacode symbols are found.</c>
<c>* --------------------------------------------------</c>
<c>* </c>
<l>create_data_code_2d_model ('Data Matrix ECC 200', [], [], DataCodeHandle)</l>
<c>* </c>
<c>* by (un)commenting the appropriate command line one can</c>
<c>* switch between standard and enhanced mode</c>
<c>* The standard mode is the default!</c>
<c>* </c>
<l>set_data_code_2d_param (DataCodeHandle, 'default_parameters', 'enhanced_recognition')</l>
<c>* </c>
<c>* Query a list of all supported model parameters, alphanumeric results,</c>
<c>* and iconic result objects; The operator query_data_code_2d_params</c>
<c>* returns a list of the generic parameter names that can be used</c>
<c>* in the get_ or set_data_code_2d_* operators.</c>
<c>* </c>
<l>query_data_code_2d_params (DataCodeHandle, 'get_model_params', GenParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_params', ResultParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_objects', ResultObjectNames)</l>
<c>* </c>
<c>* </c>
<l>for I := 0 to |FileNames| - 1 by 1</l>
<c>    * </c>
<c>    * read the next image</c>
<l>    read_image (Image, FileNames[I])</l>
<c>    * </c>
<c>    * </c>
<c>    * in the sequence 'datacode/ecc200/ecc200_cpu_007', ..., there is inversion of polarity</c>
<l>    if (I &gt; 24 and I &lt; 35)</l>
<l>        set_data_code_2d_param (DataCodeHandle, 'polarity', 'light_on_dark')</l>
<l>    else</l>
<l>        set_data_code_2d_param (DataCodeHandle, 'polarity', 'dark_on_light')</l>
<l>    endif</l>
<c>    * </c>
<c>    * </c>
<c>    * look for the 2d data code symbols</c>
<c>    * - stop after finding the expected number of symbols (or after the last search pass)</c>
<c>    * - measure the run time of find_data_code_2d</c>
<c>    * </c>
<l>    dev_update_var ('off')</l>
<l>    count_seconds (T1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (T2)</l>
<l>    dev_update_var ('on')</l>
<l>    Time := 1000 * (T2 - T1)</l>
<c>    * </c>
<c>    * get some interesting information about the search in general</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'result_num', ResultNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'candidate_num', CandNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'pass_num', Passes)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'undecoded_num', UndecNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', ['search_level','min_search_level','max_search_level'], SL)</l>
<c>    * </c>
<c>    * get some interesting information about all successfully detected symbols</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_rows', SymbolRows)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_cols', SymbolCols)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_height', ModuleHeight)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_width', ModuleWidth)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mirrored', Mirrored)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'contrast', Contrast)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'decoding_error', DecodingError)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'slant', Slant)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'polarity', Polarity)</l>
<c>    * </c>
<c>    * get some information about all investigated symbol candidates in order to get a first</c>
<c>    * hint why a symbol could not be read</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_candidates', 'status', AllStatus)</l>
<l>    get_data_code_2d_objects (AllCandidates, DataCodeHandle, 'all_candidates', 'candidate_xld')</l>
<c>    * </c>
<c>    * display some of the general information (runtime, number of found symbols and passes)</c>
<c>    * and display all candidates that were investigated (red) and the decoded symbols (green)</c>
<c>    * </c>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, 'ECC 200 found and decoded in ' + Time$'.1f' + ' ms', 'window', -1, -1, 'black', 'true')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (3)</l>
<l>    dev_display (SymbolXLDs)</l>
<l>    dev_set_line_width (1)</l>
<c>    * </c>
<c>    * for all symbols display the encoded data string and some</c>
<c>    * info about the symbol and the reading process</c>
<c>    * </c>
<l>    for K := 0 to |ResultHandles| - 1 by 1</l>
<l>        select_obj (SymbolXLDs, SymbolXLD, K + 1)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        p_datacode_result_pos (SymbolXLD, 1.7 * TWidth, THeight, 7, Width, Height, TPosRow, TPosCol)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 0, TWidth, THeight, 'Symbol:', SymbolRows[K] + 'x' + SymbolCols[K], 'orange')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 1, TWidth, THeight, 'Modules:', ModuleHeight[K]$'.1f' + 'x' + ModuleWidth[K]$'.1f', 'orange')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 2, TWidth, THeight, 'Mirrored:', Mirrored[K], 'orange')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 3, TWidth, THeight, 'Contrast:', Contrast[K], 'orange')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 4, TWidth, THeight, 'Decode-err:', DecodingError[K], 'orange')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 6, TWidth, THeight, 'Result:', '', 'green')</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 7, TWidth, THeight, DecodedDataStrings[K], '', 'green')</l>
<l>    endfor</l>
<c>    * </c>
<c>    *   make a pause when displaying results on the two illustrative images</c>
<l>    if (I &lt;= 1)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* cleanup: close the 2d data code model</c>
<c>* </c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<l>return ()</l>
</body>
<docu id="p_do_ecc200">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_qrcode">
<interface/>
<body>
<c>* </c>
<c>* *****************************************************************************</c>
<c>* Example program for demonstrating the 2d data code operators.</c>
<c>* *****************************************************************************</c>
<c>* This example program runs through an image sequence looking for</c>
<c>* 2d data code symbols (QR code).</c>
<c>* This program uses the model without any adaptions, tuning, or</c>
<c>* symbol specific modifications.</c>
<c>* Only the opportunity to switch the complete set of model</c>
<c>* parameters from the standard to the enhanced settings is</c>
<c>* demonstrated.</c>
<c>* Searching the symbols with the standard setting is faster,</c>
<c>* especially, if no readable symbol is found.  On the other hand,</c>
<c>* there are a number of restrictions concerning the symbol size,</c>
<c>* the module size, the polarity, and the minimum contrast, that</c>
<c>* prevent a number of symbols from being detected.</c>
<c>* </c>
<c>* The first two images in the array are specially illustrative of</c>
<c>* the difficulty of the task at hand, therefore there will be shown</c>
<c>* in more detail</c>
<l>Paths := 'datacode/qrcode/qr_workpiece_'</l>
<l>Sequence := [1:9]</l>
<l>Numbers := Sequence$'.02'</l>
<l>FileNames := Paths[0] + Numbers</l>
<l>FileNames := [FileNames[0],FileNames[8],FileNames,FileNames[0:5]]</l>
<c>* </c>
<c>* </c>
<l>read_image (Image, FileNames[0])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>get_string_extents (WindowHandle, 'Err-cqrr-level: ', Ascent, Descent, TWidth, THeight)</l>
<c>* </c>
<c>* Create a 2d data code model.</c>
<c>* --------------------------------------------------</c>
<c>* This model describes the symbol class that is searched and serves as a</c>
<c>* container for collecting the results during the symbol search in order to</c>
<c>* access them later by the get_data_code_2d_* operators.</c>
<c>* For the model, you can choose between two default parameter settings:</c>
<c>* the standard and an enhanced one.  The standard mode is the default</c>
<c>* mode that is chosen if no parameter setting is explicitly specified.</c>
<c>* --------------------------------------------------</c>
<c>* --------   ATTENTION !!!   --------</c>
<c>* --------------------------------------------------</c>
<c>* Please recognize that there are symbols that cannot be found with the</c>
<c>* standard default parameters.</c>
<c>* The reasons for that are:</c>
<c>* + the contrast is too low</c>
<c>* + some symbols are printed light on dark, which is not covered by</c>
<c>* the standard model</c>
<c>* + the symbols are too big (&gt;version 15 = &gt;71x71 modules)</c>
<c>* + the modules are printed as small unconnected dots</c>
<c>* Changing the default parameter set to 'enhanced recognition' enables</c>
<c>* HALCON to find most of the symbols that couldn't be detected before.</c>
<c>* The price for the improved recognition rate is an increasing runtime,</c>
<c>* especially if no datacode symbols are found.</c>
<c>* --------------------------------------------------</c>
<c>* </c>
<l>create_data_code_2d_model ('QR Code', [], [], DataCodeHandle)</l>
<c>* </c>
<c>* by (un)commenting the appropriate command line one can</c>
<c>* switch between standard and enhanced mode</c>
<c>* After the model creation the standard mode is the default!</c>
<c>* </c>
<l>set_data_code_2d_param (DataCodeHandle, 'default_parameters', 'enhanced_recognition')</l>
<c>* </c>
<c>* Query a list of all supported model parameters, alphanumeric results,</c>
<c>* and iconic result objects; The operator query_data_code_2d_params</c>
<c>* returns a list of the generic parameter names that can be used</c>
<c>* in the get_ or set_data_code_2d_* operators.</c>
<c>* </c>
<l>query_data_code_2d_params (DataCodeHandle, 'get_model_params', GenParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_params', ResultParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_objects', ResultObjectNames)</l>
<c>* </c>
<c>* within a loop:</c>
<c>* + read the next image from the image sequence file</c>
<c>* + try to recognize the data code symbol(s)</c>
<c>* + for every image display the recognized symbol, the decoded string,</c>
<c>* and some data about the symbol and the search process</c>
<c>* </c>
<l>for I := 0 to |FileNames| - 1 by 1</l>
<c>    * </c>
<c>    * read the next image</c>
<l>    read_image (Image, FileNames[I])</l>
<c>    * </c>
<c>    * </c>
<c>    * re-read the current settings of the model</c>
<l>    get_data_code_2d_param (DataCodeHandle, GenParamNames, GenParamValues)</l>
<c>    * </c>
<c>    * look for the 2d data code symbols</c>
<c>    * - stop after finding the expected number of symbols (or after the last search pass)</c>
<c>    * - measure the run time of find_data_code_2d</c>
<c>    * </c>
<l>    dev_update_var ('off')</l>
<l>    count_seconds (T1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (T2)</l>
<l>    dev_update_var ('on')</l>
<l>    Time := 1000 * (T2 - T1)</l>
<c>    * </c>
<c>    * get some interesting information about the search in general</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'result_num', ResultNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'candidate_num', CandNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'pass_num', Passes)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'undecoded_num', UndecNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', ['search_level','min_search_level','max_search_level'], SL)</l>
<c>    * </c>
<c>    * get some interesting information about all successfully detected symbols</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'model_type', ModelType)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'version', Version)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_height', ModuleHeight)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_width', ModuleWidth)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mirrored', Mirrored)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'contrast', Contrast)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'decoding_error', DecodingError)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mask_pattern_ref', MaskPattern)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'error_correction_level', ErrorCorrectionLevel)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'polarity', Polarity)</l>
<c>    * </c>
<c>    * get some information about all investigated symbol candidates in order to get a first</c>
<c>    * hint why a symbol could not be read</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_candidates', 'status', AllStatus)</l>
<l>    get_data_code_2d_objects (AllCandidates, DataCodeHandle, 'all_candidates', 'candidate_xld')</l>
<c>    * </c>
<c>    * display some of the general information (runtime, number of found symbols and passes)</c>
<c>    * and display all candidates that were investigated (red) and the decoded symbols (green)</c>
<c>    * </c>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, 'QR Code found and decoded in ' + Time$'.1f' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (3)</l>
<l>    dev_display (SymbolXLDs)</l>
<l>    dev_set_line_width (1)</l>
<c>    * </c>
<c>    * for all symbols display the encoded data string and some</c>
<c>    * info about the symbol and the reading process</c>
<c>    * </c>
<l>    for K := 0 to |ResultHandles| - 1 by 1</l>
<l>        select_obj (SymbolXLDs, SymbolXLD, K + 1)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        Color := 'orange'</l>
<l>        p_datacode_result_pos (SymbolXLD, 1.7 * TWidth, THeight, 10, Width, Height, TPosRow, TPosCol)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 0, TWidth, THeight, 'Model type:', ModelType[K], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 1, TWidth, THeight, 'Version:', Version[K] + '  (' + (Version[K] * 4 + 17) + 'x' + (Version[K] * 4 + 17) + ')', Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 2, TWidth, THeight, 'Modules:', ModuleHeight[K]$'.1f' + 'x' + ModuleWidth[K]$'.1f', Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 3, TWidth, THeight, 'Mirrored:', Mirrored[K], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 4, TWidth, THeight, 'Contrast:', Contrast[K], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 5, TWidth, THeight, 'Decod.err:', DecodingError[K], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 6, TWidth, THeight, 'Mask pattern:', MaskPattern[K], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 7, TWidth, THeight, 'Err-corr-level:', ErrorCorrectionLevel[K], Color)</l>
<l>        Color := 'green'</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 9, TWidth, THeight, 'Result:', '', Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 10, TWidth, THeight, DecodedDataStrings[K], '', Color)</l>
<c>        * </c>
<l>    endfor</l>
<c>    * </c>
<l>    if (I &lt;= 1)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (4)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* cleanup: close the 2d data code model</c>
<c>* </c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_do_qrcode">
<parameters/>
</docu>
</procedure>
<procedure name="p_datacode_write_result">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Number" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="Name" base_type="ctrl" dimension="0"/>
<par name="Value" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>R := Row + Number * Height</l>
<l>C := Col</l>
<l>disp_message (WindowHandle, Name, 'window', R + 1, C + 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Name, 'window', R - 1, C - 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Name, 'window', R + 1, C - 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Name, 'window', R - 1, C + 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Name, 'window', R, C, Color, 'false')</l>
<l>C := Col + Width</l>
<l>disp_message (WindowHandle, Value, 'window', R + 1, C + 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Value, 'window', R - 1, C - 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Value, 'window', R + 1, C - 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Value, 'window', R - 1, C + 1, 'black', 'false')</l>
<l>disp_message (WindowHandle, Value, 'window', R, C, Color, 'false')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_datacode_write_result">
<short lang="en_US">write the result data of a datacode symbol</short>
<parameters>
<parameter id="Col"/>
<parameter id="Color"/>
<parameter id="Height"/>
<parameter id="Name"/>
<parameter id="Number"/>
<parameter id="Row"/>
<parameter id="Value"/>
<parameter id="Width"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_datacode_result_pos">
<interface>
<io>
<par name="DataCode" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="TWidth" base_type="ctrl" dimension="0"/>
<par name="THeight" base_type="ctrl" dimension="0"/>
<par name="Num" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PosRow" base_type="ctrl" dimension="0"/>
<par name="PosCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_contour_xld (DataCode, Row, Col)</l>
<l>PosRow := mean(Row)</l>
<l>PosCol := mean(Col)</l>
<l>Max := -Num * THeight * TWidth / 2</l>
<c>* Above</c>
<l>Cut := min([(min(Row) - Num * THeight) * TWidth,(Width - (min(Col) + TWidth)) * THeight])</l>
<l>if (Cut &gt; Max)</l>
<l>    PosRow := min(Row) - Num * THeight</l>
<l>    PosCol := min(Col)</l>
<l>    Max := Cut</l>
<l>endif</l>
<c>* Below</c>
<l>Cut := min([(Height - (max(Row) + Num * THeight)) * TWidth,(Width - (min(Col) + TWidth)) * THeight])</l>
<l>if (Cut &gt; Max)</l>
<l>    PosRow := max(Row)</l>
<l>    PosCol := min(Col)</l>
<l>    Max := Cut</l>
<l>endif</l>
<c>* Left</c>
<l>Cut := min([(min(Col) - TWidth) * Num * THeight,(Height - (min(Row) + Num * THeight)) * TWidth])</l>
<l>if (Cut &gt; Max)</l>
<l>    PosRow := min(Row)</l>
<l>    PosCol := min(Col) - TWidth</l>
<l>    Max := Cut</l>
<l>endif</l>
<c>* Right</c>
<l>Cut := min([(Width - (max(Col) + TWidth)) * Num * THeight,(Height - (min(Row) + Num * THeight)) * TWidth])</l>
<l>if (Cut &gt; Max)</l>
<l>    PosRow := min(Row)</l>
<l>    PosCol := max(Col)</l>
<l>    Max := Cut</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="p_datacode_result_pos">
<parameters>
<parameter id="DataCode"/>
<parameter id="Height"/>
<parameter id="Num"/>
<parameter id="PosCol"/>
<parameter id="PosRow"/>
<parameter id="THeight"/>
<parameter id="TWidth"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="p_disp_pause_sign">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Position" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>set_display_font (WindowHandle, 11, 'mono', 'true', 'false')</l>
<l>String := ' Slow motion '</l>
<l>get_string_extents (WindowHandle, String, Ascent, Descent, Width, Height)</l>
<l>Row := 12</l>
<l>Column := WidthWin - 12 - Width</l>
<c>* Adapt Height for different font sizes!</c>
<l>Height := 15</l>
<c>* Adapt text position and extents because of image zooming</c>
<l>FactorRow := 1. * (Row2Part - Row1Part + 1) / HeightWin</l>
<l>FactorColumn := 1. * (Column2Part - Column1Part + 1) / WidthWin</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>dev_set_draw ('fill')</l>
<l>dev_set_color ('#F28D26')</l>
<l>R1 := Row * FactorRow + 0.5 + Row1Part</l>
<l>C1 := Column * FactorColumn + 0.5 + Column1Part</l>
<l>R2 := (Row + Height - 1) * FactorRow + 0.5 + Row1Part</l>
<l>C2 := (Column + Width - 1) * FactorColumn + 0.5 + Column1Part</l>
<l>gen_rectangle1 (Rectangle, R1, C1, R2, C2)</l>
<l>dev_display (Rectangle)</l>
<l>dev_set_color ('black')</l>
<l>set_tposition (WindowHandle, R1, C1)</l>
<l>dev_set_color ('black')</l>
<l>write_string (WindowHandle, String)</l>
<l>dev_set_draw (DrawMode)</l>
<l>p_set_font (WindowHandle)</l>
<l>return ()</l>
</body>
<docu id="p_disp_pause_sign">
<parameters>
<parameter id="Position"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_show_intro">
<interface>
<oc>
<par name="MainWindow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', MainWindow)</l>
<l>dev_set_window (MainWindow)</l>
<l>dev_update_off ()</l>
<c>* </c>
<l>Path := 'explore_halcon/'</l>
<l>TimeToWait := [2,8,6,10,12,12,8]</l>
<l>for I := 1 to 7 by 1</l>
<l>    read_image (Slide, Path + 'explore_halcon_' + (I$'.2') + '_start')</l>
<l>    get_image_size (Slide, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Slide)</l>
<l>    wait_seconds (0.1)</l>
<l>    read_image (Slide, Path + 'explore_halcon_' + (I$'.2'))</l>
<l>    dev_display (Slide)</l>
<l>    p_wait_mouse_click (MainWindow, 452, 379, 470, 419, TimeToWait[I - 1])</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_show_intro">
<short lang="en_US">Show HALCON introduction slides</short>
<parameters>
<parameter id="MainWindow"/>
</parameters>
</docu>
</procedure>
<procedure name="p_show_end">
<interface>
<ic>
<par name="StatusWindow" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_set_window (StatusWindow)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_update_window ('off')</l>
<c>* </c>
<l>Path := 'explore_halcon/'</l>
<l>for I := 1 to 6 by 1</l>
<l>    read_image (Slide, Path + 'explore_halcon_more_' + (I$'.2'))</l>
<l>    get_image_size (Slide, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Slide)</l>
<l>    wait_seconds (1)</l>
<l>endfor</l>
<c>* </c>
<l>* dev_close_window ()</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="p_show_end">
<parameters>
<parameter id="StatusWindow"/>
</parameters>
</docu>
</procedure>
<procedure name="p_wait_mouse_click">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="RectR1" base_type="ctrl" dimension="0"/>
<par name="RectC1" base_type="ctrl" dimension="0"/>
<par name="RectR2" base_type="ctrl" dimension="0"/>
<par name="RectC2" base_type="ctrl" dimension="0"/>
<par name="WaitSeconds" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_update_off ()</l>
<l>gen_rectangle1 (Rectangle, RectR1, RectC1, RectR2, RectC2)</l>
<l>get_system ('clock_mode', Information)</l>
<l>set_system ('clock_mode', 'elapsed_time')</l>
<l>count_seconds (Seconds1)</l>
<l>Time := 0</l>
<l>Clicked := false</l>
<l>while (Time &lt; WaitSeconds and not Clicked)</l>
<l>*     wait_seconds (0.2)</l>
<l>    count_seconds (Seconds2)</l>
<l>    Time := Seconds2 - Seconds1</l>
<l>    dev_error_var (Error, 1)</l>
<l>    dev_set_check ('~give_error')</l>
<l>    get_mposition (WindowHandle, Row, Col, Button)</l>
<l>    dev_error_var (Error, 0)</l>
<l>    dev_set_check ('give_error')</l>
<l>    if (Error != H_MSG_TRUE)</l>
<l>        Button := 0</l>
<l>    endif</l>
<l>    if (Button == 1 and Row &gt; RectR1 and Row &lt; RectR2 and Col &gt; RectC1 and Col &lt; RectC2)</l>
<l>        Clicked := true</l>
<l>    endif</l>
<l>endwhile</l>
<l>set_system ('clock_mode', Information)</l>
<l>dev_update_on ()</l>
<l>return ()</l>
</body>
<docu id="p_wait_mouse_click">
<parameters>
<parameter id="RectC1"/>
<parameter id="RectC2"/>
<parameter id="RectR1"/>
<parameter id="RectR2"/>
<parameter id="WaitSeconds"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_pdf417">
<interface/>
<body>
<c>* </c>
<c>* *****************************************************************************</c>
<c>* Example program for demonstrating the 2d data code operators</c>
<c>* *****************************************************************************</c>
<c>* This example program runs through an image sequence looking for</c>
<c>* 2d data code symbols (PDF417). To optimize the run time the</c>
<c>* parameters are set manually.</c>
<c>* In particular, the setting of the polarity helps to reduce the run time.</c>
<c>* In this example the polarity, the symbol size, the module size, and</c>
<c>* the minimum contrast are set.</c>
<c>* Note that in general the parameters can be chosen even more restrictive</c>
<c>* because the symbol variations in practice are smaller than in this example.</c>
<c>* </c>
<l>Paths := 'datacode/pdf417/pdf417_misc_'</l>
<l>Sequence := [1:10]</l>
<l>Numbers := Sequence$'.02'</l>
<l>FileNames := Paths[0] + Numbers</l>
<l>FileNames := [FileNames[7],FileNames[4],FileNames]</l>
<c>* </c>
<l>read_image (Image, FileNames[2])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_open_window (489, 0, 640, 95, 'black', WindowHandleResult)</l>
<l>dev_set_part (0, 0, 94, 639)</l>
<l>set_display_font (WindowHandleResult, 11, 'mono', 'true', 'false')</l>
<l>get_string_extents (WindowHandleResult, 'Symbol columns: ', Ascent, Descent, TWidthResult, THeightResult)</l>
<l>gen_image_const (ImageEmpty, 'byte', 640, 95)</l>
<l>p_set_font (WindowHandle)</l>
<l>get_string_extents (WindowHandle, 'Áymbol columns: ', Ascent, Descent, TWidth, THeight)</l>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<c>* Create a 2d data code model.</c>
<c>* --------------------------------------------------</c>
<c>* This model describes the symbol class that is searched and serves as a</c>
<c>* container for collecting the results during the symbol search in order to</c>
<c>* access them later by the get_data_code_2d_* operators.</c>
<c>* </c>
<l>create_data_code_2d_model ('PDF417', [], [], DataCodeHandle)</l>
<l>set_data_code_2d_param (DataCodeHandle, ['symbol_rows_min','symbol_rows_max'], [6,16])</l>
<l>set_data_code_2d_param (DataCodeHandle, ['symbol_cols_min','symbol_cols_max'], [5,9])</l>
<l>set_data_code_2d_param (DataCodeHandle, ['module_width_min','module_width_max'], [2.0,4.0])</l>
<l>set_data_code_2d_param (DataCodeHandle, ['module_aspect_min','module_aspect_max'], [2.5,4.0])</l>
<l>set_data_code_2d_param (DataCodeHandle, 'polarity', 'dark_on_light')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'contrast_min', 10)</l>
<c>* </c>
<c>* Query a list of all supported model parameters, alphanumeric results,</c>
<c>* and iconic result objects; The operator query_data_code_2d_params</c>
<c>* returns a list of the generic parameter names that can be used</c>
<c>* in the get_ or set_data_code_2d_* operators.</c>
<c>* </c>
<l>query_data_code_2d_params (DataCodeHandle, 'get_model_params', GenParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_params', ResultParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_objects', ResultObjectNames)</l>
<c>* </c>
<c>* </c>
<c>* Within a loop:</c>
<c>* + read the next image from the image sequence file</c>
<c>* + try to recognize the data code symbol(s)</c>
<c>* + for every image display the recognized symbol, the decoded string,</c>
<c>* and some data about the symbol and the search process</c>
<c>* </c>
<l>for I := 0 to |FileNames| - 1 by 1</l>
<c>    * </c>
<c>    * Read the next image</c>
<l>    read_image (Image, FileNames[I])</l>
<c>    * </c>
<c>    * Re-read the current settings of the model</c>
<l>    get_data_code_2d_param (DataCodeHandle, GenParamNames, GenParamValues)</l>
<c>    * </c>
<c>    * Look for the 2d data code symbols</c>
<c>    * - stop after finding the expected number of symbols (or after the last search pass)</c>
<c>    * - measure the run time of find_data_code_2d</c>
<c>    * </c>
<l>    count_seconds (T1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (T2)</l>
<l>    Time := 1000 * (T2 - T1)</l>
<c>    * </c>
<c>    * Get some interesting information about the search in general</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'result_num', ResultNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'candidate_num', CandNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'pass_num', Passes)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'undecoded_num', UndecNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', ['search_level','min_search_level','max_search_level'], SL)</l>
<c>    * </c>
<c>    * Get some interesting information about all successfully detected symbols</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_height', ModuleHeight)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_width', ModuleWidth)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_aspect', ModuleAspect)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_rows', SymbolRows)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_cols', SymbolColumns)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mirrored', Mirrored)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'contrast', Contrast)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'decoding_error', DecodingError)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'error_correction_level', ErrorCorrectionLevel)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'macro_exist', MacroExist)</l>
<c>    * </c>
<c>    * Get some information about all investigated symbol candidates in order to get a first</c>
<c>    * hint why a symbol could not be read</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_candidates', 'status', AllStatus)</l>
<l>    get_data_code_2d_objects (AllCandidates, DataCodeHandle, 'all_candidates', 'candidate_xld')</l>
<c>    * </c>
<c>    * Display some of the general information (runtime, number of found symbols and passes)</c>
<c>    * and display all candidates that were investigated (red) and the decoded symbols (green)</c>
<c>    * </c>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, 'PDF417 found and decoded in ' + Time$'.0f' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (3)</l>
<l>    dev_display (SymbolXLDs)</l>
<l>    dev_set_line_width (1)</l>
<c>    * </c>
<c>    * For all symbols display the encoded data string and some</c>
<c>    * info about the symbol and the reading process</c>
<c>    * </c>
<l>    for J := 0 to |ResultHandles| - 1 by 1</l>
<l>        select_obj (SymbolXLDs, SymbolXLD, J + 1)</l>
<l>        get_contour_xld (SymbolXLD, Row, Col)</l>
<l>        Color := 'orange'</l>
<c>        * </c>
<l>        p_datacode_result_pos (SymbolXLD, 1.3 * TWidth, THeight * 0.9, 7, Width, Height, TPosRow, TPosCol)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 0, TWidth, THeight * 0.9, 'Symbol rows:', SymbolRows[J], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 1, TWidth, THeight * 0.9, 'Symbol columns:', SymbolColumns[J], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 2, TWidth, THeight * 0.9, 'Modules:', ModuleHeight[J]$'.1f' + 'x' + ModuleWidth[J]$'.1f', Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 3, TWidth, THeight * 0.9, 'Mirrored:', Mirrored[J], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 4, TWidth, THeight * 0.9, 'Contrast:', Contrast[J], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 5, TWidth, THeight * 0.9, 'Decod.err:', DecodingError[J], Color)</l>
<l>        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, 6, TWidth, THeight * 0.9, 'Err-corr-level:', ErrorCorrectionLevel[J], Color)</l>
<c>        * Because some of the symbols encode escape sequences we should not output the</c>
<c>        * decoded string directly. Therefore, we base the output on the ASCII values of the</c>
<c>        * decoded data and interpret these values manually.</c>
<l>        dev_set_window (WindowHandleResult)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (ImageEmpty)</l>
<l>        get_data_code_2d_results (DataCodeHandle, ResultHandles[J], 'decoded_data', DecodedData)</l>
<l>        set_tposition (WindowHandleResult, 5, 10)</l>
<l>        write_string (WindowHandleResult, 'Result:')</l>
<l>        write_encoded_data (WindowHandleResult, DecodedData, 5, 80, TWidthResult, THeightResult * 0.9, 95, Width, 'green')</l>
<l>        dev_set_window (WindowHandle)</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (I &lt;= 1)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* Cleanup: close the 2d data code model</c>
<c>* </c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<l>dev_set_window (WindowHandleResult)</l>
<l>dev_close_window ()</l>
<l>return ()</l>
</body>
<docu id="p_do_pdf417">
<parameters/>
</docu>
</procedure>
<procedure name="write_encoded_data">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="DecodedData" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Count the number of lines to write</c>
<l>* I := 0</l>
<l>* TextLine := 0</l>
<l>* while (I &lt; |DecodedData|)</l>
<l>*     Char := DecodedData[I]</l>
<l>*     tuple_chr (Char, CharASCII)</l>
<l>*     if (Char == 10)</l>
<c>        * simulate LF (line feed) only if no CR follows</c>
<l>*         if (I + 1 == |DecodedData|)</l>
<l>*             TextLine := TextLine + 1</l>
<l>*         else</l>
<l>*             if (DecodedData[I + 1] != 13)</l>
<l>*                 TextLine := TextLine + 1</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (Char == 13)</l>
<c>        * simulate CR (carriage return) only if no LF follows</c>
<l>*         if (I + 1 == |DecodedData|)</l>
<l>*             TextLine := TextLine + 1</l>
<l>*         else</l>
<l>*             if (DecodedData[I + 1] != 10)</l>
<l>*                 TextLine := TextLine + 1</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (Char == 94)</l>
<l>*         TextLine := TextLine + 1</l>
<l>*     endif</l>
<l>*     I := I + 1</l>
<l>* endwhile</l>
<l>* if (Row + (TextLine + 1) * Height &gt; ImageHeight)</l>
<l>*     Row := ImageHeight - (TextLine + 1) * Height</l>
<l>* endif</l>
<l>dev_set_color ('green')</l>
<l>set_tposition (WindowHandle, Row, Col)</l>
<l>I := 0</l>
<l>TextLine := 0</l>
<l>LastSpace := -1</l>
<l>get_string_extents (WindowHandle, 'a', Ascent, Descent, LetterWidth, Height1)</l>
<c>* Interpret the decoded data</c>
<l>while (I &lt; |DecodedData|)</l>
<l>    Char := DecodedData[I]</l>
<l>    tuple_chr (Char, CharASCII)</l>
<l>    if (Char == 32)</l>
<l>        LastSpace := I</l>
<l>    endif</l>
<l>    if (Char != 2 and Char != 3 and Char != 9 and Char != 10 and Char != 13 and Char != 26 and Char != 31 and Char != 94)</l>
<l>        write_string (WindowHandle, CharASCII)</l>
<l>    else</l>
<l>        if (Char == 2)</l>
<c>            * ignore STX (start of text)</c>
<l>        endif</l>
<l>        if (Char == 3)</l>
<c>            * ignore ETX (end of text)</c>
<l>        endif</l>
<l>        if (Char == 9)</l>
<c>            * simulate TAB (horizontal tab)</c>
<l>            write_string (WindowHandle, '  ')</l>
<l>        endif</l>
<l>        if (Char == 10)</l>
<c>            * simulate LF (line feed) only if no CR follows</c>
<l>            if (I + 1 == |DecodedData|)</l>
<l>                TextLine := TextLine + 1</l>
<l>                set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<l>            else</l>
<l>                if (DecodedData[I + 1] != 13)</l>
<l>                    TextLine := TextLine + 1</l>
<l>                    set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (Char == 13)</l>
<c>            * simulate CR (carriage return) only if no LF follows</c>
<l>            if (I + 1 == |DecodedData|)</l>
<l>                TextLine := TextLine + 1</l>
<l>                set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<l>            else</l>
<l>                if (DecodedData[I + 1] != 10)</l>
<l>                    TextLine := TextLine + 1</l>
<l>                    set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (Char == 26)</l>
<c>            * ignore SUB (substitution)</c>
<l>        endif</l>
<l>        if (Char == 31)</l>
<c>            * ignore VT (vertical tab)</c>
<l>        endif</l>
<l>        if (Char == 94)</l>
<c>            * replace ^ by LF</c>
<l>*             TextLine := TextLine + 1</l>
<l>*             set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<c>            * replace ^ by ' '</c>
<l>            LastSpace := I</l>
<l>            write_string (WindowHandle, ' ')</l>
<l>        endif</l>
<l>    endif</l>
<l>    get_tposition (WindowHandle, RowCurrent, ColumnCurrent)</l>
<l>    if (ColumnCurrent &gt; ImageWidth and LastSpace != -1)</l>
<l>        gen_rectangle1 (RectangleDelete, Row + Height * TextLine, ColumnCurrent - (I - LastSpace) * LetterWidth, Row + Height * TextLine + Height, ColumnCurrent)</l>
<l>        dev_set_color ('black')</l>
<l>        dev_display (RectangleDelete)</l>
<l>        dev_set_color ('green')</l>
<l>        TextLine := TextLine + 1</l>
<l>        set_tposition (WindowHandle, Row + Height * TextLine, Col)</l>
<l>        I := LastSpace</l>
<l>    endif</l>
<l>    I := I + 1</l>
<l>endwhile</l>
<l>return ()</l>
</body>
<docu id="write_encoded_data">
<short lang="en_US">output the encoded data string into the window</short>
<parameters>
<parameter id="Col"/>
<parameter id="Color"/>
<parameter id="DecodedData"/>
<parameter id="Height"/>
<parameter id="ImageHeight"/>
<parameter id="ImageWidth"/>
<parameter id="Row"/>
<parameter id="Width"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_3d_position_of_circles">
<interface/>
<body>
<c>* This example program shows how to use the operator get_circle_pose.</c>
<c>* First, the contours of the drill-holes of a rim are extracted.</c>
<c>* Then, the 3D position of the center of these contours is determined with the operator get_circle_pose.</c>
<c>* </c>
<c>* Read the image and initialize the program.</c>
<l>read_image (Image, 'rim')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window_fit_image (Image, 0, 0, 640, -1, WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_display (Image)</l>
<l>dev_set_line_width (2)</l>
<c>* </c>
<c>* Determine the elliptical contours of the drill-holes.</c>
<l>p_determine_ellipse_contours (Image, EllipseContoursLarge, EllipseContoursSmall, false, NumberLarge, NumberSmall)</l>
<l>concat_obj (EllipseContoursLarge, EllipseContoursSmall, EllipseContours)</l>
<c>* </c>
<c>* Set the radius of the drill-holes and the camera parameters (result from a camera calibration)</c>
<l>RadiusLarge := 10.25 / 1000.0</l>
<l>RadiusSmall := 5.91 / 1000.0</l>
<l>CamParam := [0.0122,-261.04,7.39e-6,7.4e-6,303.12,234.17,652,494]</l>
<c>* </c>
<c>* Apply the operator get_circle_pos to determine the position and orientation of the circles.</c>
<c>* Note that in this case the operator get_circle_pose is called two times: First to determine  the poses of the circles,</c>
<c>* then, to determine the normal vectors of the 3D circles.</c>
<c>* For each circle, two possible 3D positions and orientations are determined by the operator get_circle_pose.</c>
<c>* The normal vectors of the 3D circles are used to cluster the results such that all the</c>
<c>* circles that lie within one plane are grouped together. This clustering is carried out by</c>
<c>* the procedure p_cluster_normals.</c>
<l>get_circle_pose (EllipseContours, CamParam, [gen_tuple_const(NumberLarge,RadiusLarge),gen_tuple_const(NumberSmall,RadiusSmall)], 'pose', Pose1, Pose2)</l>
<l>get_circle_pose (EllipseContours, CamParam, [gen_tuple_const(NumberLarge,RadiusLarge),gen_tuple_const(NumberSmall,RadiusSmall)], 'center_normal', CenterNormal1, CenterNormal2)</l>
<l>p_cluster_normals (Pose1, Pose2, CenterNormal1, CenterNormal2, ClusterP1, ClusterP2, ClusterCN1, ClusterCN2)</l>
<c>* </c>
<c>* Visualize the results.</c>
<l>dev_display (Image)</l>
<l>dev_set_color ('blue')</l>
<l>dev_set_line_width (2)</l>
<l>dev_display (EllipseContours)</l>
<l>disp_message (WindowHandle, 'Fitted ellipses', 'image', -1, -1, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<l>disp_message (WindowHandle, ['3D position of the circles','determined solely from the ellipses'], 'image', 10, -1, 'black', 'true')</l>
<l>dev_set_color ('green')</l>
<l>for I := 0 to NumberLarge + NumberSmall - 1 by 1</l>
<l>    pose_to_hom_mat3d (ClusterP1[I * 7:I * 7 + 6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, 0, 0, 0, Qx, Qy, Qz)</l>
<l>    project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)</l>
<l>    gen_cross_contour_xld (Cross, Row, Column, 10, 0.785398)</l>
<l>    dev_display (Cross)</l>
<l>    if (I &lt; (NumberLarge + NumberSmall - 1))</l>
<l>        disp_message (WindowHandle, ['X= ' + (ClusterCN1[I * 6] * 1000)$'3.1f' + ' mm','Y= ' + (ClusterCN1[I * 6 + 1] * 1000)$'3.1f' + ' mm','Z= ' + (ClusterCN1[I * 6 + 2] * 1000)$'3.1f' + ' mm'], 'image', Row - 40, Column - 270, 'black', 'true')</l>
<l>    else</l>
<l>        disp_message (WindowHandle, ['X= ' + (ClusterCN1[I * 6] * 1000)$'3.1f' + ' mm','Y= ' + (ClusterCN1[I * 6 + 1] * 1000)$'3.1f' + ' mm','Z= ' + (ClusterCN1[I * 6 + 2] * 1000)$'3.1f' + ' mm'], 'image', Row - 200, Column - 170, 'black', 'true')</l>
<l>        dev_set_color ('blue')</l>
<l>        disp_line (WindowHandle, 404, 660, 487, 709)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (5)</l>
<l>return ()</l>
</body>
<docu id="p_do_3d_position_of_circles">
<parameters/>
</docu>
</procedure>
<procedure name="p_determine_ellipse_contours">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EllipseContoursLarge" base_type="iconic" dimension="0"/>
<par name="EllipseContoursSmall" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="visualization" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NumberLarge" base_type="ctrl" dimension="0"/>
<par name="NumberSmall" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>threshold (Image, Dark, 0, 128)</l>
<l>if (visualization)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_draw ('fill')</l>
<l>    dev_display (Dark)</l>
<l>    stop ()</l>
<l>endif</l>
<c>* </c>
<l>connection (Dark, DarkRegions)</l>
<l>select_shape (DarkRegions, Circles, ['circularity','area'], 'and', [0.85,50], [1.0,99999])</l>
<l>if (visualization)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_colored (12)</l>
<l>    dev_display (Circles)</l>
<l>    stop ()</l>
<l>endif</l>
<c>* </c>
<l>dilation_circle (Circles, ROIOuter, 8.5)</l>
<l>erosion_circle (Circles, ROIInner, 8.5)</l>
<l>difference (ROIOuter, ROIInner, ROI)</l>
<l>union1 (ROI, ROIEdges)</l>
<l>if (visualization)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (ROIEdges)</l>
<l>    stop ()</l>
<l>endif</l>
<c>* </c>
<l>reduce_domain (Image, ROIEdges, RimReduced)</l>
<l>edges_sub_pix (RimReduced, Edges, 'canny', 2, 20, 40)</l>
<c>* </c>
<l>select_contours_xld (Edges, EdgesLarge, 'contour_length', 200, 300, 0, 0)</l>
<l>count_obj (EdgesLarge, NumberLarge)</l>
<l>fit_ellipse_contour_xld (EdgesLarge, 'ftukey', -1, 2, 0, 200, 3, 2, Row, Column, Phi, Ra, Rb, StartPhi, EndPhi, PointOrder)</l>
<l>gen_ellipse_contour_xld (EllipseContoursLarge, Row, Column, gen_tuple_const(NumberLarge,0), Ra, Rb, gen_tuple_const(NumberLarge,0), gen_tuple_const(NumberLarge,rad(360)), gen_tuple_const(NumberLarge,'positive'), 1.5)</l>
<c>* </c>
<l>select_contours_xld (Edges, EdgesSmall, 'contour_length', 100, 200, 0, 0)</l>
<l>count_obj (EdgesSmall, NumberSmall)</l>
<l>fit_ellipse_contour_xld (EdgesSmall, 'ftukey', -1, 2, 0, 200, 3, 2, Row, Column, Phi, Ra, Rb, StartPhi, EndPhi, PointOrder)</l>
<l>gen_ellipse_contour_xld (EllipseContoursSmall, Row, Column, gen_tuple_const(NumberSmall,0), Ra, Rb, gen_tuple_const(NumberSmall,0), gen_tuple_const(NumberSmall,rad(360)), gen_tuple_const(NumberSmall,'positive'), 1.5)</l>
<c>* </c>
<l>if (visualization)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (EllipseContoursLarge)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (EllipseContoursSmall)</l>
<l>    stop ()</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="p_determine_ellipse_contours">
<short lang="en_US">Determines large and small elliptical contours.</short>
<parameters>
<parameter id="EllipseContoursLarge"/>
<parameter id="EllipseContoursSmall"/>
<parameter id="Image"/>
<parameter id="NumberLarge"/>
<parameter id="NumberSmall"/>
<parameter id="visualization"/>
</parameters>
</docu>
</procedure>
<procedure name="p_cluster_normals">
<interface>
<ic>
<par name="Pose1" base_type="ctrl" dimension="0"/>
<par name="Pose2" base_type="ctrl" dimension="0"/>
<par name="CenterNormal1" base_type="ctrl" dimension="0"/>
<par name="CenterNormal2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClusterP1" base_type="ctrl" dimension="0"/>
<par name="ClusterP2" base_type="ctrl" dimension="0"/>
<par name="ClusterCN1" base_type="ctrl" dimension="0"/>
<par name="ClusterCN2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Number := |CenterNormal1| / 6</l>
<l>ClusterP1 := Pose1[0:6]</l>
<l>ClusterP2 := Pose2[0:6]</l>
<l>ClusterCN1 := CenterNormal1[0:5]</l>
<l>ClusterCN2 := CenterNormal2[0:5]</l>
<l>NA := ClusterCN1[3:5]</l>
<l>NB := ClusterCN2[3:5]</l>
<l>for I := 1 to Number - 1 by 1</l>
<l>    N1 := CenterNormal1[I * 6 + 3:I * 6 + 5]</l>
<l>    N2 := CenterNormal2[I * 6 + 3:I * 6 + 5]</l>
<l>    N1NA := sum(N1 * NA)</l>
<l>    N1NB := sum(N1 * NB)</l>
<l>    N2NA := sum(N2 * NA)</l>
<l>    N2NB := sum(N2 * NB)</l>
<l>    tuple_sort_index ([N1NA,N1NB,N2NA,N2NB] * -1, Indices)</l>
<l>    if (Indices[0] == 0 or Indices[0] == 3)</l>
<l>        ClusterP1 := [ClusterP1,Pose1[I * 7:I * 7 + 6]]</l>
<l>        ClusterP2 := [ClusterP2,Pose2[I * 7:I * 7 + 6]]</l>
<l>        ClusterCN1 := [ClusterCN1,CenterNormal1[I * 6:I * 6 + 5]]</l>
<l>        ClusterCN2 := [ClusterCN2,CenterNormal2[I * 6:I * 6 + 5]]</l>
<l>    else</l>
<l>        ClusterP1 := [ClusterP1,Pose2[I * 7:I * 7 + 6]]</l>
<l>        ClusterP2 := [ClusterP2,Pose1[I * 7:I * 7 + 6]]</l>
<l>        ClusterCN1 := [ClusterCN1,CenterNormal2[I * 6:I * 6 + 5]]</l>
<l>        ClusterCN2 := [ClusterCN2,CenterNormal1[I * 6:I * 6 + 5]]</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>idx := []</l>
<l>for I := 0 to Number - 1 by 1</l>
<l>    idx := [idx,I * 6 + 3]</l>
<l>endfor</l>
<l>DeviationC1 := deviation(subset(ClusterCN1,idx)) + deviation(subset(ClusterCN1,idx + 1)) + deviation(subset(ClusterCN1,idx + 2))</l>
<l>DeviationC2 := deviation(subset(ClusterCN2,idx)) + deviation(subset(ClusterCN2,idx + 1)) + deviation(subset(ClusterCN2,idx + 2))</l>
<l>if (DeviationC2 &lt; DeviationC1)</l>
<l>    Help := ClusterP1</l>
<l>    ClusterP1 := ClusterP2</l>
<l>    ClusterP2 := Help</l>
<l>    Help := ClusterCN1</l>
<l>    ClusterCN1 := ClusterCN2</l>
<l>    ClusterCN2 := Help</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="p_cluster_normals">
<short lang="en_US">Out of the two possible orientations per ellipse, Cluster1 contains the ones, where the normal vectors point in a similar direction</short>
<parameters>
<parameter id="CenterNormal1"/>
<parameter id="CenterNormal2"/>
<parameter id="ClusterCN1"/>
<parameter id="ClusterCN2"/>
<parameter id="ClusterP1"/>
<parameter id="ClusterP2"/>
<parameter id="Pose1"/>
<parameter id="Pose2"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_color_fuses">
<interface/>
<body>
<c>* ****</c>
<c>* step: set up fuse properties and hue ranges</c>
<c>* ****</c>
<l>FuseColors := ['Orange','Red','Blue','Yellow','Green']</l>
<l>FuseTypes := [5,10,15,20,30]</l>
<c>* HueRanges: Orange 10-30, Red 0-10...</c>
<l>HueRanges := [10,30,0,10,125,162,30,64,96,128]</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 600 * 640. / 800, 'black', WH)</l>
<l>p_set_font (WH)</l>
<l>for Index := 1 to 4 by 1</l>
<c>    * ****</c>
<c>    * step: acquire image</c>
<c>    * ****</c>
<l>    read_image (Image, 'color/color_fuses_' + Index$'.02')</l>
<l>    get_image_size (Image, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Image)</l>
<c>    * ****</c>
<c>    * step: extract saturated hues</c>
<c>    * ****</c>
<l>    decompose3 (Image, Red, Green, Blue)</l>
<l>    trans_from_rgb (Red, Green, Blue, Hue, Saturation, Intensity, 'hsv')</l>
<l>    threshold (Saturation, Saturated, 60, 255)</l>
<l>    reduce_domain (Hue, Saturated, HueSaturated)</l>
<l>    disp_message (WH, 'Result of the color segmentation:', 'window', 10, 10, 'black', 'true')</l>
<l>    for Fuse := 0 to |FuseTypes| - 1 by 1</l>
<c>        * ****</c>
<c>        * step: classify specific fuse</c>
<c>        * ****</c>
<l>        threshold (HueSaturated, CurrentFuse, HueRanges[Fuse * 2], HueRanges[Fuse * 2 + 1])</l>
<l>        connection (CurrentFuse, CurrentFuseConn)</l>
<l>        fill_up (CurrentFuseConn, CurrentFuseFill)</l>
<l>        select_shape (CurrentFuseFill, CurrentFuseSel, 'area', 'and', 6000, 20000)</l>
<l>        area_center (CurrentFuseSel, FuseArea, Row1, Column1)</l>
<l>        dev_set_color ('magenta')</l>
<l>        for I := 0 to |FuseArea| - 1 by 1</l>
<l>            disp_message (WH, [FuseColors[Fuse],'(' + FuseTypes[Fuse] + ' A)'], 'image', Row1[I] + 60, Column1[I] - 70, 'black', 'true')</l>
<l>        endfor</l>
<l>    endfor</l>
<l>    p_disp_pause_sign (WH, 2)</l>
<l>    wait_seconds (3)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="p_do_color_fuses">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_textline_orientation">
<interface/>
<body>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<l>J := 1</l>
<l>for I := 1 to 25 by 1</l>
<l>    read_image (Image, 'dot_print_rotated/dot_print_rotated_' + J$'02d')</l>
<c>    * </c>
<l>    if (I &lt; 5)</l>
<l>        dev_display (Image)</l>
<l>        disp_message (WindowHandle, 'Determine text line orientation automatically', 'window', 12, 12, 'black', 'true')</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>*     wait_seconds (1)</l>
<l>    text_line_orientation (Image, Image, 50, rad(-30), rad(30), OrientationAngle)</l>
<l>    rotate_image (Image, ImageRotate, -OrientationAngle / rad(180) * 180, 'constant')</l>
<c>    * </c>
<l>    dots_image (ImageRotate, ImageDots, 3, 'dark', 2)</l>
<l>    scale_image_max (ImageDots, ImageScaleMax)</l>
<l>    intensity (ImageRotate, ImageRotate, Mean, Deviation)</l>
<l>    threshold (ImageScaleMax, RegionThresh, Mean - 35, 255)</l>
<l>    connection (RegionThresh, ConnectedDots)</l>
<l>    select_shape (ConnectedDots, SelectedDots, 'area', 'and', 8, 1000)</l>
<l>    opening_circle (SelectedDots, SelectedDotsOpening, 1.5)</l>
<l>    union1 (SelectedDotsOpening, Region)</l>
<l>    closing_circle (Region, RegionClosing, 9.5)</l>
<l>    connection (RegionClosing, ConnectedRegions)</l>
<c>    * Connect split parts</c>
<l>    smallest_rectangle1 (ConnectedRegions, Row11, Column11, Row21, Column21)</l>
<l>    gen_rectangle1 (Rectangle1, Row11, Column11, Row21, Column21)</l>
<l>    union1 (Rectangle1, RegionUnion3)</l>
<l>    connection (RegionUnion3, ConnectedRegions2)</l>
<l>    select_shape (ConnectedRegions2, SelectedRegions, ['area','height','width'], 'and', [1000,30,20], [3200,70,70])</l>
<c>    * Get rectangular shape</c>
<l>    smallest_rectangle1 (SelectedRegions, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (RectangularShape, Row1, Column1, Row2, Column2)</l>
<c>    * Build lines</c>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    dilation_rectangle1 (RegionUnion, RegionDilation, 50, 1)</l>
<l>    connection (RegionDilation, ConnectedLines)</l>
<l>    select_shape (ConnectedLines, SelectedLines, 'area', 'and', 10000, 99999)</l>
<c>    * Element of lines</c>
<l>    intersection (SelectedLines, RectangularShape, ElementOfLines)</l>
<l>    intersection (ElementOfLines, SelectedDotsOpening, RegionDots)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (ImageRotate)</l>
<l>    disp_message (WindowHandle, 'Rotation corrected', 'window', -1, -1, 'black', 'true')</l>
<l>*     dev_set_colored (12)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (ElementOfLines)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_draw ('fill')</l>
<l>    dev_display (RegionDots)</l>
<l>    if (I &lt; 5)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>    J := J + 1</l>
<l>    if (J &gt; 5)</l>
<l>        J := 1</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_textline_orientation">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_novelty_detection_gmm">
<interface/>
<body>
<c>* </c>
<c>* This example program shows you how to use the GMM classifier for novelty</c>
<c>* detection to perform a web inspection task.  To perform the novelty detection,</c>
<c>* all pixels belonging to the single trained class are computed, and are then</c>
<c>* subtracted from the classification ROI to extract the erroneous pixels.  For</c>
<c>* the web inspection task, the GMM can consequently be used to detect</c>
<c>* textures that do not correspond to the texture of the trained good objects.</c>
<l>dev_update_off ()</l>
<l>read_image (Image, 'plastic_mesh/plastic_mesh_01')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Novelty detection with GMM classifier', 'window', 12, 12, 'black', 'true')</l>
<c>* The texture filters used for the classification will return artifacts at the image</c>
<c>* borders because the images of the plastic mesh to be inspected do not</c>
<c>* contain an integer number of mesh cells.  Because this would lead to wrongly</c>
<c>* detected errors at the image borders, we must exclude the area close to the</c>
<c>* image border from the training and classification.  This is done with the following</c>
<c>* rectangle.  Note that the image is later scaled down by a factor of two.</c>
<l>gen_rectangle1 (Rectangle, 10, 10, Height / 2 - 11, Width / 2 - 11)</l>
<c>* Create the GMM classifier.</c>
<c>* Load pretrained classifier if present</c>
<l>get_system ('example_dir', HEXAMPLES)</l>
<l>GMMClassifierFile := HEXAMPLES + '/hdevelop/Segmentation/Classification/novelty_detection.gmm'</l>
<l>file_exists (GMMClassifierFile, ClassifierFileExists)</l>
<l>if (ClassifierFileExists)</l>
<c>    * Read training data of GMM</c>
<l>    disp_message (WindowHandle, 'Load GMM Classifier...', 'window', 45, 50, 'black', 'true')</l>
<l>    read_class_gmm (GMMClassifierFile, GMMHandle)</l>
<l>else</l>
<c>    * Train GMM classifier</c>
<l>    disp_message (WindowHandle, 'Train GMM Classifier...', 'window', 45, 50, 'black', 'true')</l>
<l>    create_class_gmm (5, 1, [1,5], 'spherical', 'normalization', 5, 42, GMMHandle)</l>
<c>    * The training is based on five images that contain no errors.</c>
<l>    dev_set_color ('red')</l>
<l>    for J := 1 to 5 by 1</l>
<l>        read_image (Image, 'plastic_mesh/plastic_mesh_' + J$'02')</l>
<c>        * The images are zoomed down because the resolution of the mesh is very</c>
<c>        * high.  This saves a large amount of processing time.</c>
<l>        zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, 'constant')</l>
<c>        * Generate the texture image.</c>
<l>        gen_texture_image (ImageZoomed, ImageTexture)</l>
<c>        * Add the samples to the classifier.</c>
<l>        add_samples_image_class_gmm (ImageTexture, Rectangle, GMMHandle, 2.0)</l>
<l>    endfor</l>
<c>    * Train classifier</c>
<l>    train_class_gmm (GMMHandle, 1000, 0.001, 'training', 1e-04, Centers, Iter)</l>
<l>endif</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<l>wait_seconds (1.5)</l>
<l>Indices := [4,5,6,7,2,8,9,10,11,12,1,13,14,4,5,6,7,2,8,9,10,11,12,1,13,14]</l>
<c>* Now detect errors in the plastic meshes.</c>
<l>for J := 0 to |Indices| - 1 by 1</l>
<l>    read_image (Image, 'plastic_mesh/plastic_mesh_' + Indices[J]$'02')</l>
<l>    zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, 'constant')</l>
<l>    get_image_size (ImageZoomed, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    gen_texture_image (ImageZoomed, ImageTexture)</l>
<l>    reduce_domain (ImageTexture, Rectangle, ImageTextureReduced)</l>
<c>    * Classify samples belonging to the trained class with the GMM.</c>
<l>    classify_image_class_gmm (ImageTextureReduced, Correct, GMMHandle, 0.001)</l>
<c>    * Subtract them from the ROI to obtain the texture errors.</c>
<l>    difference (Rectangle, Correct, Errors)</l>
<c>    * Postprocess the returned raw errors to remove insignificant parts of the</c>
<c>    * detected errors.</c>
<l>    opening_circle (Errors, ErrorsOpening, 3.5)</l>
<l>    closing_circle (ErrorsOpening, ErrorsClosing, 10.5)</l>
<l>    connection (ErrorsClosing, ErrorsConnected)</l>
<l>    select_shape (ErrorsConnected, FinalErrors, 'area', 'and', 300, 1000000)</l>
<l>    count_obj (FinalErrors, NumErrors)</l>
<l>    dev_display (ImageZoomed)</l>
<l>    if (NumErrors &gt; 0)</l>
<l>        dev_set_color ('yellow')</l>
<l>        dev_display (Rectangle)</l>
<l>        dev_set_color ('red')</l>
<l>        dev_display (FinalErrors)</l>
<l>    else</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (Rectangle)</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, 'Detect Errors in a Mesh', 'window', 12, 12, 'black', 'true')</l>
<l>    if (NumErrors &gt; 0)</l>
<l>        disp_message (WindowHandle, 'Mesh not OK', 'window', 45, 12, 'white', 'red')</l>
<l>    else</l>
<l>        disp_message (WindowHandle, 'Mesh OK', 'window', 45, 12, 'white', 'forest green')</l>
<l>    endif</l>
<l>    if (J &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<l>clear_class_gmm (GMMHandle)</l>
<l>return ()</l>
</body>
<docu id="p_do_novelty_detection_gmm">
<parameters/>
</docu>
</procedure>
<procedure name="gen_texture_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageTexture" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* The texture image is a five-channel image that contains the result of applying</c>
<c>* five different Laws filters, which basically correspond to first and second</c>
<c>* derivatives, and smoothing them sufficiently.</c>
<l>texture_laws (Image, ImageEL, 'el', 5, 5)</l>
<l>texture_laws (Image, ImageLE, 'le', 5, 5)</l>
<l>texture_laws (Image, ImageES, 'es', 1, 5)</l>
<l>texture_laws (Image, ImageSE, 'se', 1, 5)</l>
<l>texture_laws (Image, ImageEE, 'ee', 2, 5)</l>
<l>compose5 (ImageEL, ImageLE, ImageES, ImageSE, ImageEE, ImageLaws)</l>
<l>smooth_image (ImageLaws, ImageTexture, 'gauss', 5)</l>
<l>return ()</l>
</body>
<docu id="gen_texture_image">
<parameters>
<parameter id="Image"/>
<parameter id="ImageTexture"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_optical_flow_bicycle">
<interface/>
<body>
<c>* </c>
<c>* This example demonstrates the use of the optical flow for</c>
<c>* the detection of moving objects in an image sequence.</c>
<c>* The region of interest is analyzed to detect moving objects.</c>
<c>* If a moving object is detected, the exit gate is opened automatically.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>get_system ('no_object_result', NoObjectResult)</l>
<l>get_system ('empty_region_result', EmptyRegion)</l>
<l>get_system ('store_empty_region', StoreEmpty)</l>
<l>set_system ('no_object_result', 'true')</l>
<l>set_system ('empty_region_result', 'true')</l>
<l>set_system ('store_empty_region', 'true')</l>
<c>* </c>
<c>* Generate ROI</c>
<l>gen_contour_polygon_xld (ROI, [0,0,283,348,479,479], [0,379,379,434,639,0])</l>
<l>gen_region_contour_xld (ROI, RegionROI, 'filled')</l>
<c>* </c>
<c>* Initialize output window</c>
<l>read_image (Image1, 'bicycle/bicycle_01')</l>
<l>get_image_size (Image1, ImWidth, ImHeight)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, ImWidth, ImHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, ImHeight / 2 - 1, ImWidth / 2 - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<l>dev_set_draw ('margin')</l>
<c>* Prepare first image for calculation of optical flow</c>
<l>reduce_domain (Image1, RegionROI, GrayImage1ROI)</l>
<l>zoom_region (RegionROI, RegionROI, 0.5, 0.5)</l>
<l>zoom_image_factor (Image1, Image1, 0.5, 0.5, 'constant')</l>
<l>for I := 1 to 27 by 1</l>
<l>    read_image (Image2, 'bicycle/bicycle_' + I$'.2')</l>
<c>    * </c>
<c>    * Zoom images for calculation of optical flow</c>
<l>    zoom_image_factor (Image2, Image2, 0.5, 0.5, 'constant')</l>
<l>    reduce_domain (Image2, RegionROI, Image2ROI)</l>
<l>    reduce_domain (Image1, RegionROI, Image1ROI)</l>
<c>    * </c>
<l>    optical_flow_mg (Image1ROI, Image2ROI, VectorField, 'fdrig', 0.8, 1, 10, 5, ['default_parameters','warp_zoom_factor'], ['fast',0.8])</l>
<l>    vector_field_length (VectorField, LengthImage, 'squared_length')</l>
<c>    * </c>
<c>    * Segment regions with moving objects in the defined ROI</c>
<l>    min_max_gray (RegionROI, LengthImage, 0.1, Min, Max, Range)</l>
<l>    if (Max &lt; 2)</l>
<l>        continue</l>
<l>    endif</l>
<l>    threshold (LengthImage, RegionMovement, 2, Max)</l>
<l>    connection (RegionMovement, ConnectedRegions)</l>
<c>    * Select largest moving region</c>
<l>    select_shape_std (ConnectedRegions, RegionMovement, 'max_area', 70)</l>
<l>    area_center (RegionMovement, Area, RCenterNew, CCenterNew)</l>
<l>    if (Area &gt; 0)</l>
<l>        shape_trans (RegionMovement, ConvexHullregion, 'convex')</l>
<l>        intersection (RegionROI, ConvexHullregion, RegionMovementInROI)</l>
<l>        reduce_domain (VectorField, ConvexHullregion, VectorReduced)</l>
<l>        vector_field_to_real (VectorReduced, Row, Col)</l>
<c>        * </c>
<c>        * Estimate the movement direction and the speed</c>
<l>        intensity (RegionMovementInROI, Row, MeanRow, Deviation)</l>
<l>        intensity (RegionMovementInROI, Col, MeanCol, Deviation1)</l>
<l>        MeanLength := sqrt(MeanRow * MeanRow + MeanCol * MeanCol)</l>
<l>        Alpha := atan(MeanRow / MeanCol)</l>
<c>        * </c>
<c>        * Display results</c>
<l>        dev_display (Image2)</l>
<c>        * Display region of interest</c>
<l>        dev_set_line_width (3)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (RegionROI)</l>
<l>        disp_message (WindowHandle, 'Estimate moving direction and speed', 'window', -1, -1, 'black', 'true')</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_set_color ('yellow')</l>
<l>        dev_display (VectorReduced)</l>
<c>        * Display region of moving object in the region of interest</c>
<l>        dev_set_line_width (3)</l>
<l>        dev_set_color ('magenta')</l>
<l>        dev_display (RegionMovementInROI)</l>
<l>        disp_arrow (WindowHandle, RCenterNew, CCenterNew, RCenterNew + MeanLength * sin(Alpha), CCenterNew + MeanLength * cos(Alpha), 1)</l>
<l>    else</l>
<l>        dev_display (Image2)</l>
<l>        MeanL := 0</l>
<l>        disp_message (WindowHandle, 'Estimate moving direction and speed', 'window', -1, -1, 'black', 'true')</l>
<l>    endif</l>
<c>    * </c>
<l>    copy_obj (Image2, Image1, 1, 1)</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<l>set_system ('no_object_result', NoObjectResult)</l>
<l>set_system ('empty_region_result', EmptyRegion)</l>
<l>set_system ('store_empty_region', StoreEmpty)</l>
<l>return ()</l>
</body>
<docu id="p_do_optical_flow_bicycle">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_variation_model_illumination">
<interface/>
<body>
<c>* </c>
<c>* This example demonstrates the print inspection using</c>
<c>* a variation model. The variation model is trained</c>
<c>* using a single model image. Before applying the print inspection,</c>
<c>* the images are scaled to the same gray value range like the model.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Read model image and init visualization</c>
<l>read_image (ModelImage, 'cap_illumination/cap_illumination_01')</l>
<l>get_image_size (ModelImage, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, Width / 2, Height / 2, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<c>* Segment model region</c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_display (ModelImage)</l>
<l>disp_message (WindowHandle, 'Generate model...', 'window', 12, 12, 'black', 'true')</l>
<l>get_model_region (ModelImage, RegionROI, ImageReduced)</l>
<l>area_center (RegionROI, Area, RowModel, ColumnModel)</l>
<c>* </c>
<c>* Create model for shape-based-matching</c>
<l>create_scaled_shape_model (ImageReduced, 'auto', 0, rad(360), 'auto', 0.8, 1.2, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)</l>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<c>* Transform model contours from the original position for visualization</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, RowModel, ColumnModel, HomMat2DTranslate)</l>
<l>affine_trans_contour_xld (ModelContours, ModelContoursAffinTrans, HomMat2DTranslate)</l>
<c>* </c>
<c>* Create variation model for print inspection</c>
<l>create_variation_model (Width, Height, 'byte', 'direct', VariationID)</l>
<c>* Generate variation image</c>
<l>sobel_amp (ModelImage, VarImage, 'sum_abs', 5)</l>
<l>prepare_direct_variation_model (ModelImage, VarImage, VariationID, [20,25], [1.6,1.6])</l>
<c>* </c>
<c>* Get gray value range of the variation model</c>
<l>get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)</l>
<c>* </c>
<l>wait_seconds (1)</l>
<c>* </c>
<c>* Perform print inspection</c>
<l>J := 1</l>
<l>for I := 1 to 30 by 1</l>
<l>    read_image (rImage, 'cap_illumination/cap_illumination_' + J$'.2')</l>
<l>    inspect_cap (rImage, RegionROI, WindowHandle, ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel)</l>
<l>    if (I &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>    J := J + 1</l>
<l>    if (J &gt; 9)</l>
<l>        J := 1</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>wait_seconds (2)</l>
<l>clear_shape_model (ModelID)</l>
<l>clear_variation_model (VariationID)</l>
<l>return ()</l>
</body>
<docu id="p_do_variation_model_illumination">
<parameters/>
</docu>
</procedure>
<procedure name="get_grayval_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionForeground" base_type="iconic" dimension="0"/>
<par name="RegionBackground" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="BackgroundGVal" base_type="ctrl" dimension="0"/>
<par name="ForegroundGVal" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>reduce_domain (Image, RegionROI, ImageReduced)</l>
<l>binary_threshold (ImageReduced, RegionBackground, 'max_separability', 'dark', UsedThreshold)</l>
<l>difference (RegionROI, RegionBackground, RegionForeground)</l>
<l>intensity (RegionForeground, Image, ForegroundGVal, DeviationFG)</l>
<l>intensity (RegionBackground, Image, BackgroundGVal, DeviationBG)</l>
<l>return ()</l>
</body>
<docu id="get_grayval_range">
<parameters>
<parameter id="BackgroundGVal"/>
<parameter id="ForegroundGVal"/>
<parameter id="Image"/>
<parameter id="RegionBackground"/>
<parameter id="RegionForeground"/>
<parameter id="RegionROI"/>
</parameters>
</docu>
</procedure>
<procedure name="get_model_region">
<interface>
<io>
<par name="rImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionROI" base_type="iconic" dimension="0"/>
<par name="ImageReduced" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* </c>
<c>* Segment label on the cap</c>
<l>binary_threshold (rImage, BrightRegion, 'max_separability', 'light', UsedThreshold)</l>
<l>dilation_circle (BrightRegion, RegionDilation, 1.5)</l>
<l>connection (RegionDilation, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 100, 99999)</l>
<l>union1 (SelectedRegions, LabelRegion)</l>
<l>smallest_circle (LabelRegion, Row, Column, Radius)</l>
<l>smallest_rectangle1 (LabelRegion, Row1, Column1, Row2, Column2)</l>
<c>* </c>
<c>* Define model region</c>
<l>gen_circle (Region, Row, Column, Radius)</l>
<l>gen_rectangle1 (LabelRectangle, Row1, Column1, Row2, Column2)</l>
<l>intersection (Region, LabelRectangle, RegionIntersection)</l>
<l>dilation_circle (RegionIntersection, RegionROI, 5.5)</l>
<l>reduce_domain (rImage, RegionROI, ImageReduced)</l>
<l>return ()</l>
</body>
<docu id="get_model_region">
<parameters>
<parameter id="ImageReduced"/>
<parameter id="RegionROI"/>
<parameter id="rImage"/>
</parameters>
</docu>
</procedure>
<procedure name="inspect_cap">
<interface>
<io>
<par name="rImage" base_type="iconic" dimension="0"/>
<par name="RegionROI" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="VariationID" base_type="ctrl" dimension="0"/>
<par name="RowModel" base_type="ctrl" dimension="0"/>
<par name="ColumnModel" base_type="ctrl" dimension="0"/>
<par name="BackgroundGVModel" base_type="ctrl" dimension="0"/>
<par name="ForegroundGVModel" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Find shape model in the input image</c>
<l>count_seconds (StartSeconds)</l>
<l>find_scaled_shape_model (rImage, ModelID, 0, rad(360), 0.98, 1.02, 0.4, 1, 1, 'least_squares_high', [5,3], 0.9, Row, Column, Angle, Scale, Score)</l>
<l>count_seconds (EndSeconds)</l>
<l>TimeObjSearch := EndSeconds - StartSeconds</l>
<c>* </c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<c>* </c>
<l>if (|Row| &gt; 0)</l>
<c>    * </c>
<c>    * Align the model region and the found label region</c>
<l>    vector_angle_to_rigid (Row[0], Column[0], Angle, RowModel[0], ColumnModel[0], 0, HomMat2DImage)</l>
<l>    affine_trans_image (rImage, ImageAffinTrans, HomMat2DImage, 'constant', 'false')</l>
<l>    get_grayval_range (ImageAffinTrans, RegionROI, RegionForegroundImage, RegionBackgroundImage, BackgroundImage, ForegroundImage)</l>
<c>    * </c>
<c>    * Scale image to the model's gray value range</c>
<l>    Mult := (ForegroundGVModel - BackgroundGVModel) / (ForegroundImage - BackgroundImage)</l>
<l>    Add := ForegroundGVModel - Mult * ForegroundImage</l>
<c>    * Transform the contours of the models for the visualization</c>
<l>    vector_angle_to_rigid (0, 0, 0, Row[0], Column[0], Angle, HomMat2DContour)</l>
<l>    affine_trans_contour_xld (ModelContours, ModelContoursTrans, HomMat2DContour)</l>
<l>    reduce_domain (ImageAffinTrans, RegionROI, ImageReduced)</l>
<l>    scale_image (ImageReduced, ImageScaled, Mult, Add)</l>
<c>    * </c>
<c>    * Print Inspection</c>
<l>    count_seconds (StartSeconds)</l>
<l>    compare_ext_variation_model (ImageScaled, RegionDiff, VariationID, 'light_dark')</l>
<l>    count_seconds (EndSeconds)</l>
<c>    * Analyze bright and dark defect regions</c>
<l>    dev_display (rImage)</l>
<l>    count_obj (RegionDiff, NumberRegionDiff)</l>
<l>    for I := 1 to NumberRegionDiff by 1</l>
<l>        select_obj (RegionDiff, RegionDiffSelected, I)</l>
<l>        opening_circle (RegionDiffSelected, RegionOpening, 2.5)</l>
<l>        connection (RegionOpening, ConnectedRegions)</l>
<l>        select_shape (ConnectedRegions, DefectRegions, 'height', 'and', 20, 99999)</l>
<c>        * </c>
<c>        * Transform regions to the original position in the input image</c>
<l>        hom_mat2d_invert (HomMat2DImage, HomMat2DInvert)</l>
<l>        affine_trans_region (DefectRegions, DefectRegionsTrans, HomMat2DInvert, 'nearest_neighbor')</l>
<l>        closing_circle (DefectRegionsTrans, DefectRegionsClosing, 1.5)</l>
<c>        * </c>
<c>        * Display bright and dark defects using different colors</c>
<l>        dev_set_line_width (2)</l>
<l>        dev_set_draw ('margin')</l>
<l>        if (I == 1)</l>
<l>            dev_set_color ('red')</l>
<l>        else</l>
<l>            dev_set_color ('orange')</l>
<l>        endif</l>
<l>        dev_display (DefectRegionsClosing)</l>
<c>        * </c>
<c>        * Emphasize defect regions</c>
<l>        dev_set_color ('magenta')</l>
<l>        dev_set_draw ('margin')</l>
<l>        union1 (DefectRegionsClosing, RegionUnion)</l>
<l>        closing_circle (RegionUnion, RegionClosing, 10)</l>
<l>        connection (RegionClosing, DefectRegionEnlarged)</l>
<l>        elliptic_axis (DefectRegionEnlarged, Ra, Rb, Phi)</l>
<l>        if (|Phi|)</l>
<l>            area_center (DefectRegionEnlarged, Area, RowEllipse, ColumnEllipse)</l>
<l>            gen_ellipse (Ellipse, RowEllipse, ColumnEllipse, Phi, Ra * 2, Rb * 2)</l>
<l>            dev_display (Ellipse)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    dev_set_line_width (1)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (ModelContoursTrans)</l>
<c>    * </c>
<l>    TimePrintInspect := EndSeconds - StartSeconds</l>
<l>    disp_message (WindowHandle, 'Inspection Time: ' + ((TimeObjSearch + TimePrintInspect) * 1000.0)$'.04' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>else</l>
<l>    disp_message (WindowHandle, 'No shape model found!', 'window', 12, 12, 'black', 'true')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="inspect_cap">
<parameters>
<parameter id="BackgroundGVModel"/>
<parameter id="ColumnModel"/>
<parameter id="ForegroundGVModel"/>
<parameter id="ModelID"/>
<parameter id="RegionROI"/>
<parameter id="RowModel"/>
<parameter id="VariationID"/>
<parameter id="WindowHandle"/>
<parameter id="rImage"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_3d_matching_clamps">
<interface/>
<body>
<c>* </c>
<c>* This example program shows how to use HALCON's 3D Matching</c>
<c>* to find the 3D pose of clamps that exhibit a 6 degree of freedom</c>
<c>* motion.</c>
<c>* </c>
<c>* </c>
<c>* Set the camera parameters (can be obtained by using camera calibration)</c>
<l>CamParam := [0.01221,-2791,7.3958e-6,7.4e-6,308.21,245.92,640,480]</l>
<c>* </c>
<l>Width := CamParam[6]</l>
<l>Height := CamParam[7]</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>dev_update_off ()</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<c>* </c>
<l>read_image (Image, 'clamp_sloped/clamp_sloped_' + 1$'02')</l>
<l>get_image_size (Image, ImWidth, ImHeight)</l>
<l>dev_set_part (0, 0, ImHeight - 1, ImWidth - 1)</l>
<l>dev_display (Image)</l>
<c>* </c>
<c>* Load the precomputed 3D shape model if present</c>
<l>get_system ('example_dir', HEXAMPLES)</l>
<l>ShapeModel3DFile := HEXAMPLES + '/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3'</l>
<l>disp_message (WindowHandle, 'Loading 3D shape model...', 'window', 10, 10, 'black', 'true')</l>
<c>* </c>
<c>* </c>
<l>dev_set_check ('~give_error')</l>
<l>dev_error_var (ErrorVar, 1)</l>
<l>read_shape_model_3d (ShapeModel3DFile, ShapeModel3DID)</l>
<l>Error := ErrorVar</l>
<l>dev_set_check ('give_error')</l>
<l>if (Error != H_MSG_TRUE)</l>
<l>    dev_display (Image)</l>
<l>    set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>    disp_message (WindowHandle, ['Please run the HDevelop program',ShapeModel3DFile,'to create the 3D shape model!'], 'window', 5, 5, 'black', 'true')</l>
<l>    wait_seconds (2)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>dev_set_line_width (2)</l>
<c>* </c>
<c>* Find instances of a 3D shape model in some run-time images</c>
<l>for ImageNo := 1 to 35 by 1</l>
<l>    read_image (Image, 'clamp_sloped/clamp_sloped_' + ImageNo$'02')</l>
<l>    count_seconds (Seconds1)</l>
<c>    * Find up to two instances of the 3D shape model</c>
<l>    find_shape_model_3d (Image, ShapeModel3DID, 0.7, 0.9, 5, ['num_matches','pose_refinement'], [2,'least_squares_very_high'], Pose, CovPose, Score)</l>
<l>    count_seconds (Seconds2)</l>
<l>    Time := Seconds2 - Seconds1</l>
<l>    Time := Seconds2 - Seconds1</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, |Score| + ' Match(es) found in ' + Time$'4.3f' + ' s', 'window', 12, 12, 'black', 'true')</l>
<l>    for I := 0 to |Score| - 1 by 1</l>
<l>        PoseI := Pose[I * 7:I * 7 + 6]</l>
<l>        CovPoseI := CovPose[I * 6:I * 6 + 5]</l>
<l>        ScoreI := Score[I]</l>
<c>        * Visualize the found matches in the image by projecting the</c>
<c>        * 3D shape model with the pose of the match</c>
<l>        project_shape_model_3d (ModelContours, ShapeModel3DID, CamParam, PoseI, 'true', 0.523599)</l>
<l>        dev_set_color ('forest green')</l>
<l>        dev_display (ModelContours)</l>
<c>        * - projecting the coordinate system of the 3D object model</c>
<l>        dev_set_colored (3)</l>
<l>        disp_3d_coord_system (WindowHandle, CamParam, PoseI, 0.015)</l>
<c>        * Display the parameters of the found pose</c>
<l>        dev_set_color ('magenta')</l>
<l>        display_match_pose (ShapeModel3DID, PoseI, WindowHandle)</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (ImageNo &lt; 9)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (2)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Free the 3D shape model if it is not longer needed</c>
<l>clear_shape_model_3d (ShapeModel3DID)</l>
<c>* </c>
<l>wait_seconds (4)</l>
<l>return ()</l>
</body>
<docu id="p_do_3d_matching_clamps">
<parameters/>
</docu>
</procedure>
<procedure name="display_match_pose">
<interface>
<ic>
<par name="ShapeModel3DID" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* </c>
<l>get_shape_model_3d_params (ShapeModel3DID, 'reference_point', ReferencePoint)</l>
<l>get_shape_model_3d_params (ShapeModel3DID, 'cam_param', CamParam)</l>
<c>* </c>
<c>* Project the reference point</c>
<l>pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, ReferencePoint[0], ReferencePoint[1], ReferencePoint[2], X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, Row, Column)</l>
<c>* </c>
<c>* Display the pose at the projected reference point</c>
<l>set_tposition (WindowHandle, Row, Column - 10)</l>
<l>write_string (WindowHandle, 'Pose:')</l>
<l>set_tposition (WindowHandle, Row + 15, Column)</l>
<l>write_string (WindowHandle, 'X: ' + (1000 * Pose[0])$'4.1f' + ' mm')</l>
<l>set_tposition (WindowHandle, Row + 30, Column)</l>
<l>write_string (WindowHandle, 'Y: ' + (1000 * Pose[1])$'4.1f' + ' mm')</l>
<l>set_tposition (WindowHandle, Row + 45, Column)</l>
<l>write_string (WindowHandle, 'Z: ' + (1000 * Pose[2])$'4.1f' + ' mm')</l>
<l>set_tposition (WindowHandle, Row + 60, Column)</l>
<l>write_string (WindowHandle, 'Alpha: ' + Pose[3]$'4.1f' + '°')</l>
<l>set_tposition (WindowHandle, Row + 75, Column)</l>
<l>write_string (WindowHandle, 'Beta: ' + Pose[4]$'4.1f' + '°')</l>
<l>set_tposition (WindowHandle, Row + 90, Column)</l>
<l>write_string (WindowHandle, 'Gamma: ' + Pose[5]$'4.1f' + '°')</l>
<l>return ()</l>
</body>
<docu id="display_match_pose">
<chapters lang="en_US">
<item>Matching-3D</item>
</chapters>
<short lang="en_US">Display a 3D matching pose at the projected reference point</short>
<parameters>
<parameter id="Pose"/>
<parameter id="ShapeModel3DID"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_blister_mixed">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 750 * 0.854, 478 * 0.854, 'black', WindowHandle)</l>
<l>dev_set_part (-10, -15, 478 - 11, 750 - 16)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<c>* </c>
<c>* </c>
<l>read_image (Image, 'blister/blister_mixed_reference')</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Test mixed blister for correct composition', 'window', -1, -1, 'black', 'true')</l>
<l>disp_message (WindowHandle, '... train gmm classifier on pill types   ', 'window', 38, 12, 'black', 'true')</l>
<c>* </c>
<c>* First, we extract the content of the blister and pass</c>
<c>* this information on to the gmm classifier</c>
<l>extract_pill_types (Image, Chambers, ChambersUnion, Classes, PhiRef, RowRef, ColumnRef, PillTypeCount)</l>
<l>NumClasses := |PillTypeCount|</l>
<l>create_class_gmm (3, 3, [1,5], 'spherical', 'normalization', 10, 42, GMMHandle)</l>
<l>add_samples_image_class_gmm (Image, Classes, GMMHandle, 0)</l>
<l>train_class_gmm (GMMHandle, 100, 0.001, 'training', 0.0001, Centers, Iter)</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* </c>
<c>* Then, the subsequent blisters are checked for the</c>
<c>* correct pill combination</c>
<l>IndexList := [1,2,3,4,5,1,6,7,8,9,10,11,12,3,6,9,12,2,4,8,10,1,5,7,11,1,2,3,4,5,6,7,8,9,10,1]</l>
<l>for FileIndex := 0 to |IndexList| - 1 by 1</l>
<c>    * </c>
<c>    * Align image</c>
<l>    read_image (Image, 'blister/blister_mixed_' + IndexList[FileIndex]$'02')</l>
<l>    threshold (Image, Region, 90, 255)</l>
<l>    connection (Region, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 5000, 9999999)</l>
<l>    shape_trans (SelectedRegions, RegionTrans, 'convex')</l>
<l>    orientation_region (RegionTrans, Phi)</l>
<l>    if (abs(Phi) &gt; rad(90))</l>
<l>        Phi := rad(180) + Phi</l>
<l>    endif</l>
<l>    area_center (RegionTrans, Area1, Row, Column)</l>
<l>    vector_angle_to_rigid (Row, Column, Phi, RowRef, ColumnRef, PhiRef, HomMat2D)</l>
<l>    affine_trans_image (Image, ImageAffinTrans, HomMat2D, 'constant', 'false')</l>
<l>    reduce_domain (ImageAffinTrans, ChambersUnion, ImageReduced)</l>
<l>    decompose3 (ImageAffinTrans, ImageR, ImageG, ImageB)</l>
<c>    * </c>
<c>    * Classify pill type for each chamber</c>
<l>    classify_image_class_gmm (ImageReduced, ClassRegions, GMMHandle, 0.005)</l>
<c>    * </c>
<l>    count_obj (ClassRegions, Number)</l>
<l>    gen_empty_obj (FinalClasses)</l>
<l>    connection (Chambers, ChambersRemaining)</l>
<l>    for Index := Number to 1 by -1</l>
<l>        select_obj (ClassRegions, Region, Index)</l>
<l>        intersection (ChambersRemaining, Region, Region)</l>
<l>        select_shape (Region, PillsOfOneType, ['area','width'], 'and', [200,40], [3000,68])</l>
<l>        difference (ChambersUnion, PillsOfOneType, RegionDifference)</l>
<l>        connection (RegionDifference, ConnectedRegions)</l>
<l>        select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 0, 7868)</l>
<l>        shape_trans (SelectedRegions, SelectedRegions, 'convex')</l>
<l>        union1 (SelectedRegions, SelectedRegions)</l>
<l>        difference (ChambersRemaining, SelectedRegions, ChambersRemaining)</l>
<l>        concat_obj (SelectedRegions, FinalClasses, FinalClasses)</l>
<l>    endfor</l>
<c>    * </c>
<c>    * </c>
<c>    * Check for correct pill combination</c>
<l>    gen_empty_obj (MissingPills)</l>
<l>    gen_empty_obj (WrongPills)</l>
<l>    gen_empty_obj (WrongNumberOfPills)</l>
<l>    difference (ChambersUnion, FinalClasses, LeftOvers)</l>
<l>    area_center (LeftOvers, Area, Row1, Column1)</l>
<l>    if (Area &gt; 0)</l>
<l>        connection (LeftOvers, LeftOvers)</l>
<l>        count_obj (LeftOvers, Number)</l>
<l>        for Index := 1 to Number by 1</l>
<l>            select_obj (LeftOvers, ObjectSelected, Index)</l>
<l>            intensity (ObjectSelected, ImageB, Mean, Deviation)</l>
<l>            if (Deviation &gt; 40)</l>
<l>                concat_obj (WrongPills, ObjectSelected, WrongPills)</l>
<l>            else</l>
<l>                concat_obj (MissingPills, ObjectSelected, MissingPills)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute histogram</c>
<l>    CountFinalClass := []</l>
<l>    for Index := 1 to NumClasses by 1</l>
<l>        select_obj (FinalClasses, ObjectSelected, Index)</l>
<l>        connection (ObjectSelected, ObjectSelected)</l>
<l>        count_obj (ObjectSelected, Size)</l>
<l>        CountFinalClass := [CountFinalClass,Size]</l>
<l>    endfor</l>
<c>    * </c>
<l>    set_system ('flush_graphic', 'false')</l>
<l>    display_results (ImageAffinTrans, LeftOvers, FinalClasses, WrongPills, CountFinalClass, PillTypeCount, WindowHandle)</l>
<l>    set_system ('flush_graphic', 'true')</l>
<l>    disp_line (WindowHandle, -101, -101, -99, -99)</l>
<c>    * Display classification results and output allover statistic</c>
<l>    if (FileIndex &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>endfor</l>
<l>clear_class_gmm (GMMHandle)</l>
<c>* </c>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_blister_mixed">
<parameters/>
</docu>
</procedure>
<procedure name="extract_pill_types">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Chambers" base_type="iconic" dimension="0"/>
<par name="ChambersUnion" base_type="iconic" dimension="0"/>
<par name="Classes" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="PhiRef" base_type="ctrl" dimension="0"/>
<par name="RowRef" base_type="ctrl" dimension="0"/>
<par name="ColumnRef" base_type="ctrl" dimension="0"/>
<par name="PillTypeCount" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>threshold (Image, Region, 90, 255)</l>
<l>connection (Region, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 5000, 999999)</l>
<l>shape_trans (SelectedRegions, Blister, 'convex')</l>
<l>gen_empty_region (Chambers)</l>
<l>for I := 0 to 4 by 1</l>
<l>    Row := 107 + I * 70</l>
<l>    for J := 0 to 2 by 1</l>
<l>        Column := 177 + J * 150</l>
<l>        gen_rectangle2 (Rectangle, Row, Column, 0, 64, 30)</l>
<l>        concat_obj (Chambers, Rectangle, Chambers)</l>
<l>    endfor</l>
<l>endfor</l>
<l>difference (Blister, Chambers, Pattern)</l>
<l>union1 (Chambers, ChambersUnion)</l>
<l>orientation_region (Blister, PhiRef)</l>
<l>PhiRef := rad(180) + PhiRef</l>
<l>area_center (Blister, Area, RowRef, ColumnRef)</l>
<c>* </c>
<c>* </c>
<c>* +++ extract pattern for classification +++</c>
<l>select_shape (Chambers, PillType1, 'row', 'and', 1, 145)</l>
<l>union1 (PillType1, PillType1)</l>
<l>select_shape (Chambers, PillType2, 'row', 'and', 145, 270)</l>
<l>union1 (PillType2, PillType2)</l>
<l>select_shape (Chambers, PillType3, 'row', 'and', 270, 390)</l>
<l>union1 (PillType3, PillType3)</l>
<c>* </c>
<c>* </c>
<c>* extract color space of yellow pills</c>
<l>reduce_domain (Image, PillType1, ImageReduced)</l>
<l>decompose3 (ImageReduced, ImageR, ImageG, ImageB)</l>
<l>threshold (ImageB, Region, 60, 95)</l>
<c>* </c>
<c>* extract color space of red pills</c>
<l>reduce_domain (Image, PillType2, ImageReduced)</l>
<l>decompose3 (ImageReduced, ImageR, ImageG, ImageB)</l>
<l>invert_image (ImageB, ImageInvert)</l>
<l>hysteresis_threshold (ImageInvert, RegionHysteresis2, 190, 200, 5)</l>
<c>* </c>
<c>* extract color space of green pills</c>
<l>reduce_domain (Image, PillType3, ImageReduced)</l>
<l>decompose3 (ImageReduced, ImageR, ImageG, ImageB)</l>
<l>invert_image (ImageB, ImageInvert)</l>
<l>hysteresis_threshold (ImageInvert, RegionHysteresis3, 180, 200, 10)</l>
<c>* </c>
<l>intersection (Region, PillType1, PillType1)</l>
<l>intersection (RegionHysteresis2, PillType2, PillType2)</l>
<l>PillTypeCount := [3,6,6]</l>
<l>intersection (RegionHysteresis3, PillType3, PillType3)</l>
<l>concat_obj (PillType1, PillType2, Classes)</l>
<l>concat_obj (Classes, PillType3, Classes)</l>
<l>return ()</l>
</body>
<docu id="extract_pill_types">
<parameters>
<parameter id="Chambers"/>
<parameter id="ChambersUnion"/>
<parameter id="Classes"/>
<parameter id="ColumnRef"/>
<parameter id="Image"/>
<parameter id="PhiRef"/>
<parameter id="PillTypeCount"/>
<parameter id="RowRef"/>
</parameters>
</docu>
</procedure>
<procedure name="display_results">
<interface>
<io>
<par name="ImageAffinTrans" base_type="iconic" dimension="0"/>
<par name="LeftOvers" base_type="iconic" dimension="0"/>
<par name="FinalClasses" base_type="iconic" dimension="0"/>
<par name="WrongPills" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CountFinalClass" base_type="ctrl" dimension="0"/>
<par name="PillTypeCount" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>ThereWereErrors := false</l>
<l>dev_display (ImageAffinTrans)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (4)</l>
<l>dev_set_color ('red')</l>
<l>dilation_circle (LeftOvers, RedLeftOvers, 2.5)</l>
<l>dev_display (RedLeftOvers)</l>
<c>* </c>
<l>dev_set_line_width (3)</l>
<l>select_obj (FinalClasses, ObjectSelected, 1)</l>
<l>dev_set_color ('goldenrod')</l>
<l>dev_display (ObjectSelected)</l>
<l>select_obj (FinalClasses, ObjectSelected, 3)</l>
<l>dev_set_color ('medium forest green')</l>
<l>dev_display (ObjectSelected)</l>
<l>select_obj (FinalClasses, ObjectSelected, 2)</l>
<l>dev_set_color ('firebrick')</l>
<l>dev_display (ObjectSelected)</l>
<c>* </c>
<l>PillType := ['"yellow"','"red"','"green"']$'-8'</l>
<l>Numbers := '# Pill type ' + PillType + ': ' + CountFinalClass</l>
<l>Message := '# Pill type ' + PillType + ': '</l>
<l>Errors := (CountFinalClass [!=] PillTypeCount)$'1'</l>
<l>Colors := regexp_replace(Errors,'0','black')</l>
<l>Colors := regexp_replace(Colors,'1','red')</l>
<c>* </c>
<l>disp_message (WindowHandle, Numbers, 'window', 10, 10, Colors, 'true')</l>
<c>* </c>
<l>count_obj (WrongPills, NumWrong)</l>
<l>if (NumWrong &gt; 0)</l>
<l>    disp_message (WindowHandle, '# Wrong pill type   : ' + NumWrong, 'window', 10 + 60, 10, 'red', 'true')</l>
<l>endif</l>
<l>if (find(Errors,'1') != -1)</l>
<l>    disp_message (WindowHandle, 'Not OK', 'window', 10, 400, 'red', 'true')</l>
<l>else</l>
<l>    disp_message (WindowHandle, 'OK', 'window', 10, 400, 'forest green', 'true')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="display_results">
<parameters>
<parameter id="CountFinalClass"/>
<parameter id="FinalClasses"/>
<parameter id="ImageAffinTrans"/>
<parameter id="LeftOvers"/>
<parameter id="PillTypeCount"/>
<parameter id="WindowHandle"/>
<parameter id="WrongPills"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_ecc200_finder_pattern_tolerance">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, 576 - 1, 768 - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (4)</l>
<c>* </c>
<c>* </c>
<c>* </c>
<l>Path := 'datacode/ecc200/'</l>
<l>ImageFilesTrain := Path + 'ecc200_damaged_finder_pattern_training_'</l>
<l>ImageFiles := Path + 'ecc200_damaged_finder_pattern_'</l>
<l>read_image (Image, ImageFilesTrain + '01')</l>
<l>set_system ('clock_mode', 'performance_counter')</l>
<c>* </c>
<c>* Create a new ECC 200 data code model</c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Decode datacode symbols with\nheavily disturbed finder pattern', 'window', -1, -1, 'black', 'true')</l>
<l>create_data_code_2d_model ('Data Matrix ECC 200', [], [], DataCodeHandle)</l>
<l>wait_seconds (4)</l>
<c>* </c>
<c>* Perform the training</c>
<l>for Index := 1 to 5 by 1</l>
<l>    read_image (Image, ImageFilesTrain + Index$'.02')</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, 'Training datacode sample ' + Index, 'window', -1, -1, 'black', 'true')</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, 'train', 'all', ResultHandles, DecodedDataStrings)</l>
<l>    dev_set_color ('lime green')</l>
<l>    dev_display (SymbolXLDs)</l>
<l>    wait_seconds (0.6)</l>
<l>endfor</l>
<c>* </c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Decode datacode symbols', 'window', -1, -1, 'black', 'true')</l>
<l>wait_seconds (2.5)</l>
<c>* Perform the recognition</c>
<l>IndexList := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,4,8,12,16,3,6,9,15,18,1,2,5,7,10,11,13,14,17,19,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,4,8,12,16,3,6,9,15,18,1,2,5,7,10,11,13,14,17,19]</l>
<l>for Index := 0 to |IndexList| - 1 by 1</l>
<l>    read_image (Image, ImageFiles + IndexList[Index]$'.02')</l>
<l>    dev_display (Image)</l>
<l>    count_seconds (Seconds1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (Seconds2)</l>
<l>    Time := (Seconds2 - Seconds1) * 1000.0</l>
<l>    dev_set_color ('lime green')</l>
<l>    dev_display (SymbolXLDs)</l>
<l>    if (|DecodedDataStrings| &gt; 0)</l>
<l>        disp_message (WindowHandle, ['Decoded Symbol in ' + Time$'.1f' + ' ms','Symbol: ' + DecodedDataStrings], 'window', -1, -1, 'black', 'true')</l>
<l>    else</l>
<l>        disp_message (WindowHandle, 'No Symbol found (in ' + Time$'.1f' + ' ms )', 'window', -1, -1, 'black', 'true')</l>
<l>    endif</l>
<l>    if (Index &lt; 5)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Clear the data code model</c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<c>* </c>
<c>* </c>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_ecc200_finder_pattern_tolerance">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_bottle_mouth">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 512, 'black', WindowHandle1)</l>
<l>dev_set_part (0, 0, 512 - 1, 640 - 1)</l>
<l>p_set_font (WindowHandle1)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_color ('red')</l>
<c>* </c>
<l>SmoothX := 501</l>
<l>ThresholdOffset := 25</l>
<l>MinDefectSize := 50</l>
<c>* </c>
<l>dev_set_window (WindowHandle1)</l>
<l>get_system ('store_empty_region', StoreEmptyRegion)</l>
<l>set_system ('store_empty_region', 'false')</l>
<l>read_image (Image, 'bottles/bottle_mouth_01')</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle1, 'Check bottle mouth for damages', 'window', -1, -1, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* initialization</c>
<l>PolarResolution := 640</l>
<l>RingSize := 70</l>
<l>dev_open_window (0, 648 - 128, RingSize, 512, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, PolarResolution - 1, RingSize - 1)</l>
<c>* </c>
<c>* Main loop</c>
<c>* </c>
<c>* Detect defects in bottle necks</c>
<l>IndexList := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,4,8,12,16,3,6,9,15,2,10,14,1,5,7,11,13,14,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1]</l>
<l>for Index := 0 to |IndexList| - 1 by 1</l>
<l>    read_image (Image, 'bottles/bottle_mouth_' + IndexList[Index]$'.02')</l>
<c>    * </c>
<c>    * Part 1: Use basic morphology to detect bottle</c>
<l>    auto_threshold (Image, Regions, 2)</l>
<l>    select_obj (Regions, DarkRegion, 1)</l>
<l>    opening_circle (DarkRegion, RegionOpening, 3.5)</l>
<l>    closing_circle (RegionOpening, RegionClosing, 25.5)</l>
<l>    fill_up (RegionClosing, RegionFillUp)</l>
<l>    boundary (RegionFillUp, RegionBorder, 'outer')</l>
<l>    dilation_circle (RegionBorder, RegionDilation, 3.5)</l>
<l>    reduce_domain (Image, RegionDilation, ImageReduced)</l>
<c>    * </c>
<c>    * Find the bottle center by fitting a circle to extracted edges</c>
<l>    edges_sub_pix (ImageReduced, Edges, 'canny', 0.5, 20, 40)</l>
<l>    segment_contours_xld (Edges, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>    union_cocircular_contours_xld (ContoursSplit, UnionContours, 0.9, 0.5, 0.5, 200, 50, 50, 'true', 1)</l>
<l>    length_xld (UnionContours, Length)</l>
<l>    select_obj (UnionContours, LongestContour, sort_index(Length)[|Length| - 1] + 1)</l>
<l>    fit_circle_contour_xld (LongestContour, 'ahuber', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<c>    * </c>
<c>    * Part 2: Transform the ring-shaped bottle neck region to a rectangle</c>
<l>    gen_circle (Circle, Row, Column, Radius)</l>
<l>    dilation_circle (Circle, RegionDilation, 5)</l>
<l>    erosion_circle (Circle, RegionErosion, RingSize - 5)</l>
<l>    difference (RegionDilation, RegionErosion, RegionDifference)</l>
<l>    reduce_domain (Image, RegionDifference, ImageReduced)</l>
<l>    polar_trans_image_ext (ImageReduced, ImagePolar, Row, Column, 0, rad(360), Radius - RingSize, Radius, PolarResolution, RingSize, 'nearest_neighbor')</l>
<c>    * </c>
<c>    * Part 3: Find defects with a dynamic threshold</c>
<c>    * Note the strong smoothing in x-direction in the transformed image.</c>
<l>    scale_image_max (ImagePolar, ImageScaleMax)</l>
<l>    mean_image (ImageScaleMax, ImageMean, SmoothX, 3)</l>
<l>    dyn_threshold (ImageScaleMax, ImageMean, Regions1, 55, 'not_equal')</l>
<l>    connection (Regions1, Connection)</l>
<l>    select_shape (Connection, SelectedRegions, 'height', 'and', 9, 99999)</l>
<c>    * ignore noise regions</c>
<l>    closing_rectangle1 (SelectedRegions, RegionClosing1, 10, 20)</l>
<l>    union1 (RegionClosing1, RegionUnion)</l>
<c>    * re-transform defect regions for visualization</c>
<l>    polar_trans_region_inv (RegionUnion, XYTransRegion, Row, Column, 0, rad(360), Radius - RingSize, Radius, PolarResolution, RingSize, 1280, 1024, 'nearest_neighbor')</l>
<c>    * </c>
<c>    * Part 4: Display results</c>
<c>    * display original image with results</c>
<l>    dev_set_window (WindowHandle1)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (RegionDifference)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (XYTransRegion)</l>
<c>    * display polar transformed inspected region with results</c>
<c>    * The image and resulting region are rotated by 90 degrees</c>
<c>    * only for visualization purposes! (I.e. to fit better on the screen)</c>
<c>    * The rotation is NOT necessary for the detection algorithm.</c>
<l>    dev_set_window (WindowHandle)</l>
<l>    rotate_image (ImagePolar, ImageRotate, 90, 'constant')</l>
<l>    dev_display (ImageRotate)</l>
<l>    count_obj (RegionUnion, Number)</l>
<l>    if (Number &gt; 0)</l>
<l>        mirror_region (RegionUnion, RegionMirror, 'diagonal', PolarResolution)</l>
<l>        mirror_region (RegionMirror, RegionMirror, 'row', PolarResolution)</l>
<l>        dev_display (RegionMirror)</l>
<l>        disp_message (WindowHandle1, 'Not OK', 'window', -1, -1, 'red', 'false')</l>
<l>    else</l>
<l>        disp_message (WindowHandle1, 'OK', 'window', -1, -1, 'forest green', 'false')</l>
<l>    endif</l>
<l>    if (Index &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>        dev_set_color ('red')</l>
<l>    endif</l>
<l>    wait_seconds (0.07)</l>
<l>endfor</l>
<c>* Reset system parameters</c>
<l>set_system ('store_empty_region', StoreEmptyRegion)</l>
<c>* </c>
<c>* </c>
<l>wait_seconds (2)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_close_window ()</l>
<l>return ()</l>
</body>
<docu id="p_do_bottle_mouth">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_cookie_box">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, 480 - 1, 640 - 1)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<c>* </c>
<c>* </c>
<l>read_image (Image, 'packaging/cookie_box_01')</l>
<l>dev_display (Image)</l>
<c>* </c>
<l>get_system ('example_dir', HEXAMPLES)</l>
<l>DescrModelFile := HEXAMPLES + '/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm'</l>
<l>CamParam := [0.0155565,-109.42,1.28008e-005,1.28e-005,322.78,240.31,640,480]</l>
<c>* </c>
<l>disp_message (WindowHandle, 'Determine position and orientation\nof cookie box', 'window', -1, -1, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Loading descriptor-based model...', 'window', 60, -1, 'black', 'true')</l>
<l>dev_set_check ('~give_error')</l>
<l>dev_error_var (ErrorVar, 1)</l>
<l>read_descriptor_model (DescrModelFile, DescriptorHandle)</l>
<l>Error := ErrorVar</l>
<l>dev_set_check ('give_error')</l>
<l>if (Error != H_MSG_TRUE)</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, ['Please first run the HDevelop program','/Applications//Object-Recognition-2D/locate_cookie_box.hdev ','to create the descriptor-based model!'], 'window', 5, 5, 'black', 'true')</l>
<l>    wait_seconds (2)</l>
<l>    dev_close_window ()</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* reference pose of the object to the camera is computed</c>
<l>RowsRoi := [224,224,406,406]</l>
<l>ColumnsRoi := [115,540,540,115]</l>
<l>WorldX := [-189,189,189,-189] / 1000.0</l>
<l>WorldY := [-80,-80,80,80] / 1000.0</l>
<l>vector_to_pose (WorldX, WorldY, [], RowsRoi, ColumnsRoi, CamParam, 'iterative', 'error', Pose, Quality)</l>
<l>image_points_to_world_plane (CamParam, Pose, RowsRoi, ColumnsRoi, 'm', XOuterBox, YOuterBox)</l>
<c>* </c>
<c>* </c>
<c>* </c>
<c>* Main loop:</c>
<c>* search model in image sequence</c>
<l>IndexList := [1,2,4,5,6,7,8,9,10,2,4,6,8,10,1,5,7,9,6,8,5,10,1,2,5,7,9,3,6,8,4,5,10,2,1,4,5,6,7,8,9,10,2,4,6,8,1,5,7,9,6,2]</l>
<l>for Index := 0 to |IndexList| - 1 by 1</l>
<l>    OutputString := []</l>
<l>    read_image (Image, 'packaging/cookie_box_' + IndexList[Index]$'.02')</l>
<l>    set_system ('flush_graphic', 'false')</l>
<l>    dev_display (Image)</l>
<c>    * </c>
<c>    * find model (using default parameters)</c>
<l>    count_seconds (Seconds1)</l>
<l>    find_calib_descriptor_model (Image, DescriptorHandle, [], [], [], [], 0.25, 1, CamParam, 'num_points', Pose, Score)</l>
<l>    count_seconds (Seconds2)</l>
<l>    Time := Seconds2 - Seconds1</l>
<c>    * </c>
<c>    * display results</c>
<l>    if (|Score| &gt; 0)</l>
<l>        get_descriptor_model_points (DescriptorHandle, 'search', 0, Row, Col)</l>
<l>        dev_set_colored (12)</l>
<l>        dev_set_line_width (1)</l>
<l>        gen_cross_contour_xld (Cross1, Row, Col, 6, 0.785398)</l>
<l>        dev_display (Cross1)</l>
<l>        dev_set_line_width (3)</l>
<l>        disp_3d_coord_system (WindowHandle, CamParam, Pose, 0.07)</l>
<c>        * </c>
<l>        pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        affine_trans_point_3d (HomMat3D, XOuterBox, YOuterBox, [0,0,0,0], XTrans, YTrans, ZTrans)</l>
<l>        project_3d_point (XTrans, YTrans, ZTrans, CamParam, RowTrans, ColTrans)</l>
<c>        * </c>
<c>        * </c>
<l>        gen_contour_polygon_xld (Contour, RowTrans, ColTrans)</l>
<l>        close_contours_xld (Contour, Contour)</l>
<l>        dev_set_color ('lime green')</l>
<l>        dev_display (Contour)</l>
<c>        * </c>
<l>        OutputString := 'Box located in ' + (Time * 1000)$'.4' + ' ms'</l>
<c>        * determine direction of box</c>
<l>    endif</l>
<l>    disp_message (WindowHandle, OutputString, 'window', 10, 10, 'black', 'true')</l>
<l>    if (Index &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        set_system ('flush_graphic', 'true')</l>
<l>        disp_line (WindowHandle, -101, -101, -99, -99)</l>
<l>        wait_seconds (0.95)</l>
<l>    else</l>
<l>        set_system ('flush_graphic', 'true')</l>
<l>        disp_line (WindowHandle, -101, -101, -99, -99)</l>
<l>    endif</l>
<l>    wait_seconds (0.05)</l>
<l>endfor</l>
<c>* </c>
<c>* created descriptor model has to be deleted</c>
<l>clear_descriptor_model (DescriptorHandle)</l>
<c>* </c>
<c>* </c>
<l>wait_seconds (2)</l>
<l>return ()</l>
</body>
<docu id="p_do_cookie_box">
<parameters/>
</docu>
</procedure>
<procedure name="do_check_for_model_files">
<interface>
<oc>
<par name="CookieModelExists" base_type="ctrl" dimension="0"/>
<par name="ClampsModelExists" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>get_system ('example_dir', HEXAMPLES)</l>
<c>* </c>
<l>DescrModelFile := HEXAMPLES + '/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm'</l>
<l>file_exists (DescrModelFile, CookieModelExists)</l>
<c>* </c>
<c>* </c>
<l>ShapeModel3DFile := HEXAMPLES + '/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3'</l>
<l>file_exists (ShapeModel3DFile, ClampsModelExists)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="do_check_for_model_files">
<parameters>
<parameter id="ClampsModelExists"/>
<parameter id="CookieModelExists"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_track_engine_part">
<interface/>
<body>
<c>* This example shows how to efficiently perform a tracking task using</c>
<c>* perspective deformable matching. The basic idea is to speed up the</c>
<c>* search by using the pose that was determined in a previous image to</c>
<c>* restrict the search space in the next image. In case that the</c>
<c>* algorithm looses track of the object, the search is applied</c>
<c>* again, but this time in the full search domain.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>read_image (Image, 'automotive/engine_part_001')</l>
<l>dev_close_window ()</l>
<l>dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)</l>
<l>dev_set_line_width (3)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>dev_display (Image)</l>
<c>* </c>
<c>* Search parameters</c>
<l>AngleExtent := 90</l>
<l>AngleExtentTracking := 20</l>
<l>MinScore := 0.4</l>
<l>MinScoreTracking := 0.5</l>
<l>TrackingRadius := 80</l>
<l>ScaleROffset := 0.1</l>
<l>ScaleCOffset := 0.0</l>
<l>Metric := 'use_polarity'</l>
<l>CamParam := [12.0 / 1000,0.0,(4.65 / 1000000) * 2,(4.65 / 1000000) * 2,320,256,640,512]</l>
<c>* </c>
<l>read_region (Region, 'automotive/engine_part_model_region')</l>
<l>area_center (Region, Area, Row, Column)</l>
<l>reduce_domain (Image, Region, ImageReduced)</l>
<l>create_planar_uncalib_deformable_model (ImageReduced, 'auto', rad(-AngleExtent / 2.0), rad(AngleExtent), 'auto', 1, 1 + ScaleROffset, 'auto', 1, 1 + ScaleCOffset, 'auto', 'none', Metric, 'auto', 'auto', [], [], ModelID)</l>
<l>set_deformable_model_origin (ModelID, -Row, -Column)</l>
<l>get_deformable_model_contours (Contours, ModelID, 1)</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('green')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_display (Contours)</l>
<l>disp_message (WindowHandle, 'Model created', 'window', 12, 12, 'black', 'true')</l>
<l>gen_circle (Circle, Row, Column, TrackingRadius)</l>
<l>wait_seconds (3)</l>
<c>* </c>
<l>Score := []</l>
<l>select_obj (Contours, ObjectSelected, 1)</l>
<l>get_contour_xld (ObjectSelected, RowOrig, ColOrig)</l>
<l>NotFound := []</l>
<l>TrackingFailed := []</l>
<l>NumImages := 100</l>
<l>for Index := 1 to NumImages by 1</l>
<l>    wait_seconds (0.05)</l>
<l>    TrackingTime := 0</l>
<l>    read_image (Image, 'automotive/engine_part_' + Index$'03')</l>
<c>    * Either it is the first image, and one needs to perform full search,</c>
<c>    * or else the algorithm lost track of the object, and needs to start</c>
<c>    * all over again</c>
<l>    set_system ('flush_graphic', 'false')</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>    if (|Score| &gt; 0)</l>
<c>        * Keep track of the object: project the image with the pose that the object had</c>
<c>        * in the previous image. The assumption is that the pose does not change much</c>
<c>        * from image to image (see parameter AngleExtentTracking). Update the pose after</c>
<c>        * successful search</c>
<l>        try</l>
<l>            count_seconds (S1)</l>
<l>            hom_mat2d_invert (HomMat2DOut, HomMat2DInvert)</l>
<l>            projective_trans_image (Image, TransImage, HomMat2DInvert, 'bilinear', 'false', 'false')</l>
<l>            reduce_domain (TransImage, Circle, ImageReduced)</l>
<l>            find_planar_uncalib_deformable_model (TransImage, ModelID, rad(-AngleExtentTracking / 2), rad(AngleExtentTracking), 1, 1, 1, 1, MinScoreTracking, 1, 1, 0, 0.9, [], [], HomMat2DTrack, Score)</l>
<l>            count_seconds (S2)</l>
<l>            dev_set_color ('green')</l>
<l>            hom_mat2d_compose (HomMat2DOut, HomMat2DTrack, HomMat2DOut)</l>
<l>            projective_trans_contour_xld (Contours, ContoursProjTrans, HomMat2DOut)</l>
<l>            projective_trans_pixel (HomMat2DOut, [Row - 1,Row - 1,Row + 1,Row + 1], [Column - 2,Column + 1,Column + 1,Column - 1], RowTrans, ColTrans)</l>
<l>            vector_to_pose ([-2,1,1,-1], [-1,-1,1,1], [], RowTrans, ColTrans, CamParam, 'planar_analytic', 'error', Pose, Quality)</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        catch (Exception)</l>
<l>            TrackingTime := S2 - S1</l>
<l>            TrackingFailed := [TrackingFailed,Index]</l>
<l>        endtry</l>
<l>    endif</l>
<l>    if (|Score| == 0)</l>
<c>        * Still no object found. Try full search.</c>
<l>        try</l>
<l>            count_seconds (S1)</l>
<l>            find_planar_uncalib_deformable_model (Image, ModelID, rad(-AngleExtent / 2.0), rad(AngleExtent), 1, 1 + ScaleROffset, 1, 1 + ScaleCOffset, MinScore, 1, 1, 0, 0.9, [], [], HomMat2DOut, Score)</l>
<l>            count_seconds (S2)</l>
<l>            projective_trans_contour_xld (Contours, ContoursProjTrans, HomMat2DOut)</l>
<l>            projective_trans_pixel (HomMat2DOut, [Row - 1,Row - 1,Row + 1,Row + 1], [Column - 2,Column + 1,Column + 1,Column - 1], RowTrans, ColTrans)</l>
<l>            vector_to_pose ([-2,1,1,-1], [-1,-1,1,1], [], RowTrans, ColTrans, CamParam, 'planar_analytic', 'error', Pose, Quality)</l>
<l>            dev_set_color ('green')</l>
<l>        catch (Exception)</l>
<l>            set_system ('flush_graphic', 'true')</l>
<l>            dev_display (Image)</l>
<l>            NotFound := [NotFound,Index]</l>
<l>            continue</l>
<l>        endtry</l>
<l>    endif</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>    dev_display (Image)</l>
<l>    dev_display (ContoursProjTrans)</l>
<l>    disp_message (WindowHandle, 'Model found in ' + ((TrackingTime + S2 - S1) * 1000)$'.1f' + ' ms', 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_colored (3)</l>
<l>    disp_3d_coord_system (WindowHandle, CamParam, Pose, 100)</l>
<l>    set_system ('flush_graphic', 'true')</l>
<l>    set_tposition (WindowHandle, -200, -200)</l>
<l>    write_string (WindowHandle, '')</l>
<l>endfor</l>
<c>* </c>
<l>clear_deformable_model (ModelID)</l>
<l>wait_seconds (3)</l>
<l>return ()</l>
</body>
<docu id="p_do_track_engine_part">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_locate_pipe_joints_stereo">
<interface/>
<body>
<c>* Reconstruct the three-dimensional surface of a pile of pipe</c>
<c>* joints by using a multi-view stereo setup with four similar</c>
<c>* cameras and detect the position of each joint by using</c>
<c>* surface-based 3D matching</c>
<c>* </c>
<c>* </c>
<c>* *****</c>
<c>* Initializations:</c>
<c>* *****</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>ImagePath := '3d_machine_vision/multi_view/'</l>
<l>ImagePrefix := 'multi_view_pipe_joints'</l>
<l>read_image (Image, ImagePath + ImagePrefix + '_cam_0_01')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 420, 'black', WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* *****</c>
<c>* Part 1: Read the parameters of the multi-view stereo setup</c>
<c>* *****</c>
<c>* Read the camera setup model from file and get the parameters</c>
<c>* and the poses of the cameras</c>
<l>try</l>
<l>    read_camera_setup_model ('Calibration/Multi-View/four_camera_setup_model.csm', CameraSetupModelID)</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 5200)</l>
<l>        init_camera_setup (CameraSetupModelID)</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<c>* </c>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<l>get_camera_setup_param (CameraSetupModelID, 0, 'pose', Pose0)</l>
<l>get_camera_setup_param (CameraSetupModelID, 1, 'pose', Pose1)</l>
<l>get_camera_setup_param (CameraSetupModelID, 2, 'pose', Pose2)</l>
<l>get_camera_setup_param (CameraSetupModelID, 3, 'pose', Pose3)</l>
<l>get_camera_setup_param (CameraSetupModelID, 0, 'params', CamParam0)</l>
<l>get_camera_setup_param (CameraSetupModelID, 1, 'params', CamParam1)</l>
<l>get_camera_setup_param (CameraSetupModelID, 2, 'params', CamParam2)</l>
<l>get_camera_setup_param (CameraSetupModelID, 3, 'params', CamParam3)</l>
<c>* </c>
<c>* Create a multi-view stereo model, initialize it, and clear</c>
<c>* the camera setup, which is no longer required</c>
<l>create_stereo_model (CameraSetupModelID, 'surface_pairwise', 'persistence', 1, StereoModelID)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<c>* -&gt; Subsampling X, Y, Z</c>
<l>set_stereo_model_param (StereoModelID, 'sub_sampling_step', 3)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_method', 'ncc')</l>
<c>* -&gt; Interpolation aliasing by binocular image rectification</c>
<l>set_stereo_model_param (StereoModelID, 'rectif_interpolation', 'bilinear')</l>
<l>set_stereo_model_param (StereoModelID, 'rectif_sub_sampling', 1.2)</l>
<c>* -&gt; Binocular disparity parameters</c>
<l>set_stereo_model_param (StereoModelID, 'binocular_num_levels', 1)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_width', 19)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_height', 19)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_texture_thresh', 0)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_score_thresh', 0.4)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_filter', 'left_right_check')</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_sub_disparity', 'interpolation')</l>
<c>* -&gt; Define bounding box and camera pairs</c>
<l>set_stereo_model_param (StereoModelID, 'bounding_box', [-0.2,-0.07,-0.075,0.2,0.07,-0.004])</l>
<l>set_stereo_model_image_pairs (StereoModelID, [0,2], [1,3])</l>
<c>* </c>
<c>* *****</c>
<c>* Part 2: Create a surface model of the pipe fittings to be matched</c>
<c>* *****</c>
<l>read_object_model_3d ('pipe_joint', 'm', [], [], PipeJointOM3DID, Status)</l>
<l>create_surface_model (PipeJointOM3DID, 0.03, [], [], PipeJointSMID)</l>
<c>* </c>
<c>* The next line is required in order to use the option</c>
<c>* 'hidden_surface_removal' in the operator</c>
<c>* project_object_model_3d (see below).</c>
<l>prepare_object_model_3d (PipeJointOM3DID, 'shape_based_matching_3d', 'true', [], [])</l>
<c>* </c>
<c>* *****</c>
<c>* Part 3: Reconstruct the surface of the pile of pipe fittings</c>
<c>*         and detect the position of up to MaxNumParts by using</c>
<c>*         surface-based 3D matching</c>
<c>* *****</c>
<l>NumMatches := 3</l>
<l>MinScore := .3</l>
<l>Params := ['num_matches','pose_ref_scoring_dist_rel']</l>
<l>Values := [NumMatches,0.02]</l>
<c>* </c>
<l>pose_invert (Pose0, WorldPose0)</l>
<c>* </c>
<l>NumImages := 5</l>
<l>for Index := 1 to NumImages by 1</l>
<c>    * </c>
<c>    * Read and display the images</c>
<l>    read_multi_view_stereo_images (Images, ImagePath, ImagePrefix, Index, NumCameras)</l>
<c>    * </c>
<c>    * Reconstruct the 3D scene (the pile of pipe fittings)</c>
<l>    Message := 'Performing the reconstruction...'</l>
<l>    display_multi_view_stereo_images (Images, WindowHandle)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<c>    * </c>
<l>    count_seconds (T0)</l>
<l>    reconstruct_surface_stereo (Images, StereoModelID, PipeJointPileOM3DID)</l>
<l>    count_seconds (T1)</l>
<l>    ReconsTime := T1 - T0</l>
<c>    * </c>
<c>    * Perform surface-based 3D matching</c>
<l>    Message := 'Search ' + NumMatches + ' best parts with surface based matching...'</l>
<l>    disp_message (WindowHandle, Message, 'window', 36, 12, 'black', 'true')</l>
<l>    count_seconds (T2)</l>
<l>    find_surface_model (PipeJointSMID, PipeJointPileOM3DID, 0.03, 0.05, MinScore, 'false', Params, Values, Poses, Scores, SurfaceMatchingResultID)</l>
<l>    count_seconds (T3)</l>
<l>    MatchingDiff := T3 - T2</l>
<c>    * </c>
<c>    * Display the results</c>
<l>    set_system ('flush_graphic', 'false')</l>
<l>    select_obj (Images, Img, 1)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Img)</l>
<l>    count_seconds (T4)</l>
<l>    for MatchIndex := 0 to |Scores| - 1 by 1</l>
<l>        pose_to_hom_mat3d (Poses[MatchIndex * 7:(MatchIndex * 7) + 6], HomMat3DObjToWorld)</l>
<l>        pose_invert (Poses[MatchIndex * 7:(MatchIndex * 7) + 6], Pose3DWorldToObj)</l>
<l>        pose_compose (Pose3DWorldToObj, Pose0, Pose3DCamToObj)</l>
<l>        pose_invert (Pose3DCamToObj, ObjPoseCam0)</l>
<c>        * </c>
<c>        * Display the coordinate system of the part</c>
<l>        dev_set_colored (3)</l>
<l>        dev_set_line_width (3)</l>
<l>        disp_3d_coord_system (WindowHandle, CamParam0, ObjPoseCam0, 0.03)</l>
<c>        * Display the faces of the part</c>
<l>        affine_trans_object_model_3d (PipeJointOM3DID, HomMat3DObjToWorld, ObjectModel3DIDAffineTrans)</l>
<l>        project_object_model_3d (ModelContours, ObjectModel3DIDAffineTrans, CamParam0, WorldPose0, ['data','hidden_surface_removal'], ['faces','true'])</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (ModelContours)</l>
<c>        * </c>
<l>        clear_object_model_3d (ObjectModel3DIDAffineTrans)</l>
<l>    endfor</l>
<l>    set_system ('flush_graphic', 'true')</l>
<l>    count_seconds (T5)</l>
<l>    DispTime := T5 - T4</l>
<c>    * </c>
<l>    Message := 'Reconstruction: ' + ReconsTime$'.2f' + ' s'</l>
<l>    Message[1] := 'Found ' + |Scores| + ' pipe joint(s) in ' + MatchingDiff$'.2f' + ' s'</l>
<l>*     Message[2] := 'Visualization: ' + DispTime$'.1f' + ' s'</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Camera 0', 'window', Height - 36, 12, 'white', 'false')</l>
<l>    wait_seconds (2)</l>
<c>    * </c>
<c>    * clear the 3D object model</c>
<l>    clear_object_model_3d (PipeJointPileOM3DID)</l>
<l>    copy_obj (Images, OldImage, 1, 1)</l>
<l>endfor</l>
<c>* </c>
<c>* Clear the stereo model and the surface model</c>
<l>clear_stereo_model (StereoModelID)</l>
<l>clear_surface_model (PipeJointSMID)</l>
<l>clear_object_model_3d (PipeJointOM3DID)</l>
<c>* </c>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>wait_seconds (3)</l>
<l>return ()</l>
</body>
<docu id="p_do_locate_pipe_joints_stereo">
<parameters/>
</docu>
</procedure>
<procedure name="display_multi_view_stereo_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Display the images of a multi-view stereo setup</c>
<c>* consisting of four cameras</c>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<l>count_obj (Images, NumImages)</l>
<l>if (NumImages != 4)</l>
<l>    disp_message (WindowHandle, 'Wrong number of images provided!', 'window', 12, 12, 'black', 'true')</l>
<l>    stop ()</l>
<l>endif</l>
<c>* </c>
<l>NumCols := 2</l>
<l>select_obj (Images, Img, 1)</l>
<l>get_image_size (Img, Width, Height)</l>
<l>tile_images (Images, TiledImage, NumCols, 'horizontal')</l>
<l>dev_set_part (0, 0, (2 * Height) - 1, (2 * Width) - 1)</l>
<l>dev_display (TiledImage)</l>
<c>* </c>
<l>for Index := 0 to NumImages - 1 by 1</l>
<l>    RowIdx := (Index / NumCols) + 1</l>
<l>    ColIdx := Index % NumCols</l>
<l>    disp_message (WindowHandle, 'Camera ' + Index, 'image', (RowIdx * Height) - 72, (ColIdx * Width) + 12, 'white', 'false')</l>
<l>endfor</l>
<l>return ()</l>
<c>* </c>
</body>
<docu id="display_multi_view_stereo_images">
<parameters>
<parameter id="Images"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="init_camera_setup">
<interface>
<oc>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Define the internal and external camera parameters</c>
<l>CamParam0 := [0.00850373,4008.61,-2.95892e+008,2.37315e+013,0.139749,-0.00367983,5.99965e-006,6e-006,362.715,236.769,752,480]</l>
<l>CamParam1 := [0.00854019,3445.26,-1.18075e+008,6.40715e+012,-0.0527818,-0.192439,5.99894e-006,6e-006,406.13,254.15,752,480]</l>
<l>CamParam2 := [0.00852569,3938.44,-2.75967e+008,2.27295e+013,0.231091,0.193667,6.00001e-006,6e-006,367.159,242.477,752,480]</l>
<l>CamParam3 := [0.00853794,3793.19,-3.49193e+008,3.9611e+013,0.0264028,0.147156,6.00169e-006,6e-006,397.066,224.671,752,480]</l>
<c>* </c>
<l>Pose0 := [0.0496073,0.0280127,-0.431281,3.5466,354.117,179.758,0]</l>
<l>Pose1 := [0.0495484,-0.0297644,-0.429654,355.333,354.014,359.147,0]</l>
<l>Pose2 := [-0.0411315,-0.0294687,-0.427325,355.519,4.45356,359.876,0]</l>
<l>Pose3 := [-0.0414501,0.0288074,-0.429167,2.94179,4.59538,179.173,0]</l>
<c>* </c>
<c>* Create a camera setup model and set its parameters</c>
<l>create_camera_setup_model (4, CameraSetupModelID)</l>
<c>* </c>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, 'area_scan_polynomial', CamParam0, Pose0)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 1, 'area_scan_polynomial', CamParam1, Pose1)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 2, 'area_scan_polynomial', CamParam2, Pose2)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 3, 'area_scan_polynomial', CamParam3, Pose3)</l>
<l>return ()</l>
</body>
<docu id="init_camera_setup">
<parameters>
<parameter id="CameraSetupModelID"/>
</parameters>
</docu>
</procedure>
<procedure name="read_multi_view_stereo_images">
<interface>
<oo>
<par name="Images" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ImagePath" base_type="ctrl" dimension="0"/>
<par name="ImagePrefix" base_type="ctrl" dimension="0"/>
<par name="SceneIndex" base_type="ctrl" dimension="0"/>
<par name="NumCamera" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Read the images of the multi-view stereo setup</c>
<c>* </c>
<l>read_image (Images, ImagePath + ImagePrefix + '_cam_0_' + SceneIndex$'.02')</l>
<l>for Index := 1 to NumCamera - 1 by 1</l>
<l>    read_image (Img, ImagePath + ImagePrefix + '_cam_' + Index + '_' + SceneIndex$'.02')</l>
<l>    concat_obj (Images, Img, Images)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="read_multi_view_stereo_images">
<parameters>
<parameter id="ImagePath"/>
<parameter id="ImagePrefix"/>
<parameter id="Images"/>
<parameter id="NumCamera"/>
<parameter id="SceneIndex"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_warped_mesh">
<interface>
<io>
<par name="VectorField" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="WarpedMesh" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Step" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Generate a grid of the deformation from the VectorField</c>
<c>* The step width is given by the parameter Step.</c>
<c>* </c>
<l>gen_empty_obj (WarpedMesh)</l>
<l>count_obj (VectorField, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (VectorField, ObjectSelected, Index)</l>
<l>    vector_field_to_real (ObjectSelected, DRow, DColumn)</l>
<l>    get_image_size (VectorField, Width, Height)</l>
<c>    * Horizontal lines</c>
<l>    for ContR := 0.5 to Height[0] - 1 by Step</l>
<l>        Column := [0.5:Width[0] - 1]</l>
<l>        tuple_gen_const (Width[0] - 1, ContR, Row)</l>
<l>        get_grayval_interpolated (DRow, Row, Column, 'bilinear', GrayRow)</l>
<l>        get_grayval_interpolated (DColumn, Row, Column, 'bilinear', GrayColumn)</l>
<l>        gen_contour_polygon_xld (Contour, GrayRow, GrayColumn)</l>
<l>        concat_obj (WarpedMesh, Contour, WarpedMesh)</l>
<l>    endfor</l>
<c>    * Vertical lines</c>
<l>    for ContC := 0.5 to Width[0] - 1 by Step</l>
<l>        Row := [0.5:Height[0] - 1]</l>
<l>        tuple_gen_const (Height[0] - 1, ContC, Column)</l>
<l>        get_grayval_interpolated (DRow, Row, Column, 'bilinear', GrayRow)</l>
<l>        get_grayval_interpolated (DColumn, Row, Column, 'bilinear', GrayColumn)</l>
<l>        gen_contour_polygon_xld (Contour, GrayRow, GrayColumn)</l>
<l>        concat_obj (WarpedMesh, Contour, WarpedMesh)</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_warped_mesh">
<parameters>
<parameter id="Step"/>
<parameter id="VectorField"/>
<parameter id="WarpedMesh"/>
</parameters>
</docu>
</procedure>
<procedure name="p_find_cocoa_package_local_deformable">
<interface/>
<body>
<c>* This example program shows how to use local deformable</c>
<c>* matching to find objects that are deformed.</c>
<c>* </c>
<c>* Note that to find deformed objects you can</c>
<c>* - apply shape-based matching using the parameter</c>
<c>* 'max_deformation' or</c>
<c>* - apply local deformable matching.</c>
<c>* </c>
<c>* In this example, the task is solved with local</c>
<c>* deformable matching. You can compare it to the example</c>
<c>* 'find_cocoa_packages_max_deformations.hdev', which</c>
<c>* solves the same task with shape-based matching and the</c>
<c>* parameter 'max_deformation'. Shape-based matching is</c>
<c>* significantly faster, but local deformable matching is</c>
<c>* more robust to different types of deformations.</c>
<c>* For example, the deformations in the example program</c>
<c>* 'find_peanut_chocolate_candies_local_deformable.hdev'</c>
<c>* can not be handled by shape-based matching.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>read_image (ModelImage, 'food/cocoa_package_model')</l>
<l>dev_close_window ()</l>
<l>dev_open_window_fit_image (ModelImage, 0, 0, -1, -1, WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Create and display the local deformable model</c>
<l>create_local_deformable_model (ModelImage, 'auto', rad(-15), rad(30), 'auto', 1, 1, 'auto', 1, 1, 'auto', 'none', 'use_polarity', [40,60], 'auto', [], [], ModelID)</l>
<l>get_deformable_model_contours (ModelContours, ModelID, 1)</l>
<l>area_center (ModelImage, Area, Row, Column)</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, Row, Column, HomMat2DTranslate)</l>
<l>affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>dev_set_line_width (2)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (ModelImage)</l>
<l>dev_display (ContoursAffinTrans)</l>
<l>disp_message (WindowHandle, 'Model image and contours', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<l>Smoothness := 19</l>
<l>NumImages := 13</l>
<l>for Index := 1 to NumImages by 1</l>
<l>    read_image (Image, 'food/cocoa_packages_' + Index$'02')</l>
<l>    dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<l>    dev_display (Image)</l>
<l>*     disp_message (WindowHandle, 'Search ...', 'window', 12, 12, 'black', 'true')</l>
<l>    count_seconds (S1)</l>
<c>    * Find the model in the deformed search image.</c>
<c>    * As result, the rectified image, the respective</c>
<c>    * vector field, and the found contours are queried.</c>
<l>    find_local_deformable_model (Image, ImageRectified, VectorField, DeformedContours, ModelID, rad(-14), rad(28), 1, 1, 1, 1, 0.78, 0, 0, 0, 0.45, ['image_rectified','vector_field','deformed_contours'], ['deformation_smoothness','expand_border','subpixel'], [Smoothness,0,0], Score, Row, Column)</l>
<l>    count_seconds (S2)</l>
<l>    Time := S2 - S1</l>
<c>    * Visualize the deformation as a mesh generated from</c>
<c>    * the returned vector field</c>
<l>    gen_warped_mesh (VectorField, WarpedMesh, Smoothness / 2)</l>
<l>    dev_set_line_width (1)</l>
<l>    dev_set_color ('yellow')</l>
<l>    dev_display (WarpedMesh)</l>
<l>    FoundOut[Index] := |Score|</l>
<l>    dev_set_line_width (2)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (DeformedContours)</l>
<l>    disp_message (WindowHandle, |Score| + ' matches found in ' + Time$'1.2f' + ' s', 'window', 12, 12, 'black', 'true')</l>
<l>    for J := 0 to |Score| - 1 by 1</l>
<l>        disp_message (WindowHandle, 'Score: ' + Score[J]$'.2f', 'image', 350, Column[J] - 80, 'black', 'true')</l>
<l>    endfor</l>
<l>    if (Index &lt; 5)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (2)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Clean up</c>
<l>wait_seconds (3)</l>
<l>clear_deformable_model (ModelID)</l>
<l>return ()</l>
</body>
<docu id="p_find_cocoa_package_local_deformable">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_apply_sample_identifier_wine_bottle">
<interface/>
<body>
<c>* This procedure shows how to use the sample-based identification</c>
<c>* to identify different objects.</c>
<c>* First, the sample identifier is created, prepared, trained,</c>
<c>* and written to disk. In later runs, the trained sample</c>
<c>* identifier is read from disk to avoid the time-consuming</c>
<c>* preparation step. In the run-time phase, the trained sample</c>
<c>* identifier is used to identify new images of vegetables.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Get the image file names, the object names and IDs</c>
<l>ImageDirectory := 'food/wine_label'</l>
<l>get_object_images (ImageDirectory, ObjectNames, ObjectIDs, ImageFileNames, TrainingObjectNames, TrainingObjectIDs, TrainingImageFileNames)</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 512, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c>* Create a new sample identifier. Since we have color images available</c>
<c>* we use the color in addition to the texture information for</c>
<c>* identification.</c>
<l>create_sample_identifier ('add_color_info', 'true', SampleIdentifier)</l>
<l>set_sample_identifier_param (SampleIdentifier, 'image_resize_value', 0.1)</l>
<c>* Prepare the sample identifier by adding some representive sample</c>
<c>* images that show the different types of objects. For this,</c>
<c>* we simply use the training images.</c>
<l>for Index := 0 to |TrainingImageFileNames| - 1 by 1</l>
<l>    read_image (Image, TrainingImageFileNames[Index])</l>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, ['Add a sample of ' + TrainingObjectNames[Index],'to the sample identifier.'], 'window', 12, 12, 'black', 'true')</l>
<c>    * Add the current image as preparation data. Because we know</c>
<c>    * the object ID, we can use it in order to label the preparation</c>
<c>    * data. Thus, we can later reuse it for training and do not need to</c>
<c>    * add additional training data.</c>
<l>    add_sample_identifier_preparation_data (Image, SampleIdentifier, TrainingObjectIDs[Index], [], [], ObjectSampleIdx)</l>
<c>    * Optionally add the object name to the sample identifier for</c>
<c>    * convinience reasons.</c>
<l>    set_sample_identifier_object_info (SampleIdentifier, TrainingObjectIDs[Index], 'preparation_object_name', TrainingObjectNames[Index])</l>
<l>endfor</l>
<c>* Now, we can prepare the identifier</c>
<l>dev_clear_window ()</l>
<l>Message := ['Prepare and train the sample identifier','(this might take some seconds)']</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>count_seconds (S1)</l>
<l>prepare_sample_identifier (SampleIdentifier, 'true', [], [])</l>
<c>* Use the preparation data to train the identifier</c>
<l>train_sample_identifier (SampleIdentifier, [], [])</l>
<l>count_seconds (S2)</l>
<l>Runtime := S2 - S1</l>
<l>Message := [Message,'The sample identifier was prepared and trained in ' + Runtime$'.1' + 's.']</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (1)</l>
<c>* </c>
<c>* Identify new objects</c>
<l>Errors := 0</l>
<l>RandomIndices := sort_index(rand(|ImageFileNames|))</l>
<c>* Choose how many images should be tested</c>
<l>NumTests := 50</l>
<c>* Use the following line to test all images</c>
<l>NumIterations := min([NumTests,|RandomIndices|])</l>
<l>for I := 1 to NumIterations by 1</l>
<c>    * Randomly select a run-time image</c>
<l>    Index := RandomIndices[I - 1]</l>
<l>    ImageFileName := ImageFileNames[Index]</l>
<l>    ObjectID := ObjectIDs[Index]</l>
<l>    ObjectName := ObjectNames[Index]</l>
<l>    read_image (Image, ImageFileName)</l>
<c>    * Apply the sample identifier to identify the new objects</c>
<l>    apply_sample_identifier (Image, SampleIdentifier, 1, 0, [], [], ObjectIdx, Rating)</l>
<c>    * Get the name of the identified object for visualization purposes</c>
<l>    get_sample_identifier_object_info (SampleIdentifier, ObjectIdx, 'training_object_name', ResultObjectName)</l>
<l>    if (ObjectIdx != ObjectID)</l>
<c>        * Use red color for incorrect identifications</c>
<l>        Color := 'red'</l>
<l>        Errors := Errors + 1</l>
<l>    else</l>
<l>        Color := 'forest green'</l>
<l>    endif</l>
<l>    dev_display (Image)</l>
<l>    Message := ['Current object: ' + ObjectName,'Identified as:  ' + ResultObjectName,'Error rate: (' + Errors + '/' + I + ') = ' + (100.0 * Errors / I)$'.1f' + '%']</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, ['black',Color,'black'], 'true')</l>
<c>    * </c>
<l>    if (I &lt; 8)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Clear the sample identifier</c>
<l>clear_sample_identifier (SampleIdentifier)</l>
<l>wait_seconds (3)</l>
<l>return ()</l>
</body>
<docu id="p_do_apply_sample_identifier_wine_bottle">
<parameters/>
</docu>
</procedure>
<procedure name="get_object_images">
<interface>
<ic>
<par name="Directory" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectNames" base_type="ctrl" dimension="0"/>
<par name="ObjectIDs" base_type="ctrl" dimension="0"/>
<par name="ImageFileNames" base_type="ctrl" dimension="0"/>
<par name="TrainingObjectNames" base_type="ctrl" dimension="0"/>
<par name="TrainingObjectIDs" base_type="ctrl" dimension="0"/>
<par name="TrainingImageFileNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get all images in the directory</c>
<l>list_image_files (Directory, 'default', [], ImageFileNames)</l>
<l>ImageFileNames := sort(ImageFileNames)</l>
<l>tuple_regexp_match (ImageFileNames, '.*/(.*)\\..{3}$', Matches)</l>
<l>tuple_regexp_replace (Matches, '_[0-9]+', '', ObjectNames)</l>
<l>tuple_uniq (ObjectNames, UniqObjectNames)</l>
<l>ObjectIDs := []</l>
<l>for Index := 0 to |ObjectNames| - 1 by 1</l>
<l>    tuple_find (UniqObjectNames, ObjectNames[Index], Indices)</l>
<l>    ObjectIDs := [ObjectIDs,Indices]</l>
<l>endfor</l>
<c>* Extract the training images</c>
<l>TrainingObjectNames := []</l>
<l>TrainingObjectIDs := []</l>
<l>TrainingImageFileNames := []</l>
<l>tuple_uniq (ObjectIDs, ObjectIDsUniq)</l>
<l>for Index := 0 to |ObjectIDsUniq| - 1 by 1</l>
<l>    ObjectID := ObjectIDsUniq[Index]</l>
<l>    tuple_find (ObjectIDs, ObjectID, Indices)</l>
<c>    * Arbitrarily chose the first image of the same ID</c>
<c>    * as the training image</c>
<l>    I := Indices[0]</l>
<l>    TrainingObjectNames := [TrainingObjectNames,ObjectNames[I]]</l>
<l>    TrainingObjectIDs := [TrainingObjectIDs,ObjectIDs[I]]</l>
<l>    TrainingImageFileNames := [TrainingImageFileNames,ImageFileNames[I]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_object_images">
<parameters>
<parameter id="Directory"/>
<parameter id="ImageFileNames"/>
<parameter id="ObjectIDs"/>
<parameter id="ObjectNames"/>
<parameter id="TrainingImageFileNames"/>
<parameter id="TrainingObjectIDs"/>
<parameter id="TrainingObjectNames"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_read_braille_photometric_stereo">
<interface/>
<body>
<c>* This procedure demonstrates the use of the photometric stereo technique</c>
<c>* for the inspection and reading of braille text on a pharmaceutical</c>
<c>* package. Input are 4 images taken from the pharmaceutical package with</c>
<c>* light coming from different orientations.</c>
<c>* </c>
<c>* Initialization</c>
<l>dev_update_off ()</l>
<l>read_image (Images, 'photometric_stereo/braille_0' + [1:4])</l>
<l>select_obj (Images, Image, 1)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 312, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_colored (12)</l>
<l>dev_display (Image)</l>
<l>Message := 'Four different light orientations are used:'</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* This code table maps between the hexadecimal representation</c>
<c>* of the braille pattern and the corresponding character.</c>
<c>* In this case a german 6-dot code is used.</c>
<l>CodeTable := ['','a',',','b','.','k',';','l','´','c','i','f','äu','m','s','p','','e',':','h','*','o','!','r','CAPS','d','j','g','ä','n','t','q','lcase','au','?','eu','-','u','"','v','Cap','ei','ö','','ie','x','ß','','','sch','','ü','"','z','()','','&lt;e&gt;','ch','w','','','y','st','']</l>
<c>* </c>
<c>* Show input images with different illumination</c>
<l>for I := 1 to 4 by 1</l>
<l>    Message := 'Acquire image ' + I + ' of 4'</l>
<l>    select_obj (Images, ObjectSelected, I)</l>
<l>    dev_display (ObjectSelected)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    wait_seconds (0.5)</l>
<l>endfor</l>
<c>* </c>
<c>* Apply photometric stereo to determine the albedo and compute the mean</c>
<c>* curvature of the surface</c>
<l>Tilts := [6.1,95.0,-176.1,-86.8]</l>
<l>Slants := [41.4,42.6,41.7,40.9]</l>
<l>ResultType := 'gradient'</l>
<l>photometric_stereo (Images, HeightField, Gradient, Albedo, Slants, Tilts, ResultType, 'poisson', [], [])</l>
<c>* </c>
<c>* Calculate the mean curvature of the surface</c>
<c>* using the gradient field as input for the operator</c>
<c>* derivate_vector_field.</c>
<l>derivate_vector_field (Gradient, MeanCurvature, 1, 'mean_curvature')</l>
<c>* </c>
<c>* It is easy to segment the dots in the curvature image</c>
<l>dev_display (MeanCurvature)</l>
<l>disp_message (WindowHandle, 'The curvature image is used for reading the characters', 'window', 10, 10, 'black', 'true')</l>
<l>wait_seconds (4)</l>
<c>* </c>
<c>* Segment dots</c>
<l>threshold (MeanCurvature, Regions, -0.14, -0.017)</l>
<l>connection (Regions, ConnectedRegions)</l>
<l>dilation_circle (ConnectedRegions, RegionDilation, 1.5)</l>
<l>select_shape (RegionDilation, Braille, ['area','roundness'], 'and', [191.82,0.8108], [360.12,1])</l>
<l>union1 (Braille, RegionUnion)</l>
<c>* </c>
<c>* Group dots to words and characters</c>
<l>closing_rectangle1 (Regions, RegionClosing, 90, 40)</l>
<l>connection (RegionClosing, ConnectedRegions)</l>
<l>shape_trans (ConnectedRegions, RegionTrans, 'rectangle1')</l>
<l>select_shape (RegionTrans, SelectedRegions, 'height', 'and', 50, 90)</l>
<l>dilation_rectangle1 (SelectedRegions, RegionDilation1, 21, 1)</l>
<l>partition_dynamic (RegionDilation1, Partitioned, 72, 5)</l>
<l>intersection (Partitioned, RegionUnion, Letters)</l>
<c>* </c>
<c>* Display segmentation result</c>
<l>dev_display (Image)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<l>dev_display (Partitioned)</l>
<l>dev_display (Letters)</l>
<l>disp_message (WindowHandle, 'Result', 'window', 10, 10, 'black', 'true')</l>
<c>* </c>
<c>* Decode text letter by letter</c>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>count_obj (Letters, NumLetters)</l>
<l>for I := 1 to NumLetters by 1</l>
<c>    * </c>
<c>    * Define borders for the six dot sectors inside the rectangle</c>
<l>    select_obj (Partitioned, CurrentRectangle, I)</l>
<l>    region_features (CurrentRectangle, ['row1','height','column'], Limits)</l>
<l>    MaxFirstRow := Limits[0] + Limits[1] / 3.0</l>
<l>    MaxSecondRow := Limits[0] + Limits[1] * 2 / 3.0</l>
<l>    MaxFirstColumn := Limits[2]</l>
<c>    * </c>
<c>    * Decode the letter dot by dot</c>
<c>    * </c>
<c>    * Code values calculated depending</c>
<c>    * on the presence of dots using</c>
<c>    * the following scheme:</c>
<c>    *    (1) ( 8)</c>
<c>    *    (2) (16)</c>
<c>    *    (4) (32)</c>
<c>    * If a dot is present, the corresponding</c>
<c>    * value is added to the Code.</c>
<c>    * This way, 2^6 = 64 different codes are possible.</c>
<l>    select_obj (Letters, CurrentLetter, I)</l>
<l>    connection (CurrentLetter, Dots)</l>
<l>    count_obj (Dots, NumDots)</l>
<l>    Code := 0</l>
<l>    for J := 1 to NumDots by 1</l>
<l>        select_obj (Dots, CurrentDot, J)</l>
<l>        area_center (CurrentDot, _Area, Row, Column)</l>
<l>        if (Column &lt;= MaxFirstColumn)</l>
<l>            if (Row &lt;= MaxFirstRow)</l>
<c>                * Left upper (1)</c>
<l>                Code := Code + 1</l>
<l>            elseif (Row &lt;= MaxSecondRow)</l>
<c>                * Left middle (2)</c>
<l>                Code := Code + 2</l>
<l>            else</l>
<c>                * Left lower (4)</c>
<l>                Code := Code + 4</l>
<l>            endif</l>
<l>        else</l>
<l>            if (Row &lt;= MaxFirstRow)</l>
<c>                * Right upper (8)</c>
<l>                Code := Code + 8</l>
<l>            elseif (Row &lt;= MaxSecondRow)</l>
<c>                * Right middle (16)</c>
<l>                Code := Code + 16</l>
<l>            else</l>
<c>                * Right lower (32)</c>
<l>                Code := Code + 32</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>    Character[I - 1] := CodeTable[Code]</l>
<l>    disp_message (WindowHandle, CodeTable[Code], 'image', Limits[0] + Limits[1], Limits[2] - 20, 'black', 'true')</l>
<l>endfor</l>
<l>wait_seconds (5)</l>
<l>return ()</l>
</body>
<docu id="p_do_read_braille_photometric_stereo">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_inspect_leather_photometric_stereo">
<interface/>
<body>
<c>* This procedure demonstrates the use of the photometric stereo technique</c>
<c>* for the inspection of leather samples.</c>
<c>* Input are 4 images taken from different leather sample with light coming</c>
<c>* from different orientations.</c>
<c>* </c>
<c>* Initialization</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Part 1</c>
<c>* Show input images with different illumination</c>
<l>read_image (Images, 'photometric_stereo/leather_1_0' + [1:4])</l>
<l>for I := 1 to 4 by 1</l>
<l>    Message := 'Sample 1: Acquire image ' + I + ' of 4'</l>
<l>    select_obj (Images, ObjectSelected, I)</l>
<l>    dev_display (ObjectSelected)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    wait_seconds (0.5)</l>
<l>endfor</l>
<c>* </c>
<c>* Apply photometric stereo to determine the albedo</c>
<l>Tilts := [6.1,95.0,-176.1,-86.8]</l>
<l>Slants := [41.4,42.6,41.7,40.9]</l>
<l>ResultType := ['gradient','albedo']</l>
<l>photometric_stereo (Images, HeightField, Gradient, Albedo, Slants, Tilts, ResultType, 'poisson', [], [])</l>
<c>* </c>
<c>* Detect defects</c>
<l>var_threshold (Albedo, Region, 15, 15, 0.2, 0.05, 'light')</l>
<l>connection (Region, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 10, 99999)</l>
<l>union1 (SelectedRegions, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, 3.5)</l>
<l>connection (RegionClosing, Defects)</l>
<l>area_center (Defects, Area, Row, Column)</l>
<l>gen_circle (Circle, Row, Column, gen_tuple_const(|Row|,sqrt(Area) + 30))</l>
<c>* Display the defects</c>
<l>dev_display (Albedo)</l>
<l>dev_set_color ('red')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (4)</l>
<l>dev_display (Circle)</l>
<l>disp_message (WindowHandle, 'A defect can be easily detected in the Albedo image', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (5)</l>
<c>* </c>
<c>* Part 2</c>
<c>* Show input images with different illumination</c>
<l>read_image (Images, 'photometric_stereo/leather_2_0' + [1:4])</l>
<l>for I := 1 to 4 by 1</l>
<l>    Message := 'Sample 2: Acquire image ' + I + ' of 4'</l>
<l>    select_obj (Images, ObjectSelected, I)</l>
<l>    dev_display (ObjectSelected)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    wait_seconds (0.5)</l>
<l>endfor</l>
<c>* </c>
<c>* Apply photometric stereo to determine the albedo</c>
<l>photometric_stereo (Images, HeightField, Gradient, Albedo, Slants, Tilts, ResultType, 'poisson', [], [])</l>
<l>threshold (Albedo, Region1, 128, 255)</l>
<c>* </c>
<c>* Display the albedo image</c>
<l>dev_display (Albedo)</l>
<l>Message := 'These defects are difficult to detect in the albedo image.'</l>
<l>Message[1] := 'Therefore, we use the gradient information to detect them.'</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (5)</l>
<c>* </c>
<c>* Detect texture defects using gradient information.</c>
<c>* We are looking for areas with little surface changes.</c>
<l>derivate_vector_field (Gradient, Curl, 1, 'curl')</l>
<l>derivate_gauss (Curl, CurlGradient, 1, 'gradient')</l>
<c>* </c>
<c>* Detect texture defects</c>
<l>threshold (CurlGradient, Region, 0, 0.01)</l>
<l>rank_region (Region, RegionCount, 10, 10, 30)</l>
<l>connection (RegionCount, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 2000, 99999)</l>
<l>union1 (SelectedRegions, RegionUnion)</l>
<l>rank_region (RegionUnion, RegionCount1, 25, 25, 170)</l>
<l>connection (RegionCount1, NoTextured)</l>
<c>* </c>
<c>* Display texture defects</c>
<l>dev_display (Albedo)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('red')</l>
<l>dev_set_line_width (3)</l>
<l>dev_display (NoTextured)</l>
<l>disp_message (WindowHandle, 'Non-textured areas on leather', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (5)</l>
<c>* </c>
<c>* Detect scratches using curvature information.</c>
<c>* We are looking for areas with high curvature</c>
<l>derivate_vector_field (Gradient, MeanCurvature, 1, 'mean_curvature')</l>
<c>* </c>
<c>* Display the mean curvature of the surface</c>
<l>dev_display (MeanCurvature)</l>
<l>Message := 'Mean curvature of the surface'</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<c>* </c>
<c>* Detect scratches</c>
<l>abs_image (MeanCurvature, ImageAbs)</l>
<l>threshold (ImageAbs, Region2, 0.15, 255)</l>
<l>connection (Region2, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 10, 99999)</l>
<l>union1 (SelectedRegions1, RegionUnion1)</l>
<l>closing_circle (RegionUnion1, RegionClosing, 1.5)</l>
<l>connection (RegionClosing, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions2, 'max_diameter', 'and', 50, 99999)</l>
<l>select_gray (SelectedRegions2, MeanCurvature, SelectedRegions3, 'deviation', 'and', 0.2, 255)</l>
<c>* </c>
<c>* Display scratches</c>
<l>dev_display (Albedo)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('red')</l>
<l>dev_set_line_width (3)</l>
<l>dev_display (SelectedRegions3)</l>
<l>disp_message (WindowHandle, 'Deep scratch', 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (5)</l>
<l>return ()</l>
</body>
<docu id="p_do_inspect_leather_photometric_stereo">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_compare_surface_sheet_of_light">
<interface/>
<body>
<c>* This procedure shows the usage of an uncalibrated sheet of</c>
<c>* light setup for surface comparison.</c>
<c>* </c>
<c>* The inspected metal parts were scanned with an uncalibrated</c>
<c>* setup that returns disparities for each scan line.</c>
<c>* </c>
<c>* The disparity profiles are added to a sheet_of_light_model</c>
<c>* with the operator set_profile_sheet_of_light.</c>
<c>* Using simple scalings (defined at the start of the program)</c>
<c>* the measurements are transformed into a 3D object model.</c>
<c>* </c>
<c>* </c>
<c>* Part 1</c>
<c>* </c>
<c>* Create a sheet-of-light model to collect the profiles</c>
<c>* and set the scaling factors for the reconstruction.</c>
<c>* Note, that through the scalings, only approximate</c>
<c>* 3d coordinates are obtained (scaling does not</c>
<c>* replace calibration).</c>
<c>* Fortunately, in this case, this is completely sufficient</c>
<c>* for the task, as we only want to compare the parts</c>
<c>* qualitatively.</c>
<c>* </c>
<c>* Create sheet-of-light model with following parameters</c>
<l>NumProfiles := 441</l>
<l>DisparityRange := 512</l>
<l>ProfileWidth := 626</l>
<c>* In this example, the profiles are not measured by HALCON.</c>
<c>* Instead, they are obtained directly from the sheet-of-light</c>
<c>* sensor. Nevertheless the profile width is defined</c>
<c>* within create_sheet_of_light_model by the width of a rectangle.</c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>gen_rectangle1 (Rectangle, 0, 0, DisparityRange - 1, ProfileWidth - 1)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>create_sheet_of_light_model (Rectangle, 'calibration', 'offset_scale', SheetOfLightModelID)</l>
<c>* Set the scaling factors such that the distance</c>
<c>* of neighboring 3D points is approximately the same</c>
<c>* as in the real object.</c>
<l>ScaleX := 2</l>
<l>ScaleY := 8</l>
<l>ScaleZ := 1</l>
<l>Clip := 435</l>
<l>set_sheet_of_light_param (SheetOfLightModelID, 'scale_x', ScaleX)</l>
<l>set_sheet_of_light_param (SheetOfLightModelID, 'scale_y', ScaleY)</l>
<l>set_sheet_of_light_param (SheetOfLightModelID, 'scale_z', ScaleZ)</l>
<c>* </c>
<c>* Init display</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, ProfileWidth, NumProfiles, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Create an image to display the disparities</c>
<l>gen_image_const (Image, 'uint2', ProfileWidth, NumProfiles)</l>
<c>* </c>
<c>* Create the reference object by collecting</c>
<c>* the measured profiles in a sheet-of-light model</c>
<l>for Index := 0 to NumProfiles - 1 by 1</l>
<c>    * Add the next profile to the sheet of light model</c>
<l>    read_image (ImageModel, 'sheet_of_light/metal_part_1_disparity_line_' + Index$'03d')</l>
<l>    set_profile_sheet_of_light (ImageModel, SheetOfLightModelID, [])</l>
<c>    * Visualize accumulated profiles</c>
<l>    get_grayval (ImageModel, gen_tuple_const(ProfileWidth,0), [0:ProfileWidth - 1], Grayval)</l>
<l>    set_grayval (Image, gen_tuple_const(ProfileWidth,Index), [0:ProfileWidth - 1], Grayval)</l>
<l>    if (Index % 10 == 0)</l>
<l>        dev_display (Image)</l>
<l>    endif</l>
<l>    Message := 'Measure reference object'</l>
<l>    Message[1] := 'Profile #' + (Index + 1)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>endfor</l>
<c>* </c>
<l>Message := 'Prepare the model for distance measurement ...'</l>
<l>disp_message (WindowHandle, Message, 'window', 60, 12, 'black', 'true')</l>
<l>Status := ' ... triangulate object ...'</l>
<l>Status[1] := ' ... subsample object ...'</l>
<l>Status[2] := ' ... create surface model for alignment ...'</l>
<c>* Select the relevant part from the scene</c>
<l>get_sheet_of_light_result_object_model_3d (SheetOfLightModelID, Model3DAll)</l>
<l>select_points_object_model_3d (Model3DAll, 'point_coord_z', Clip, 800, Model3D)</l>
<c>* Clean up memory</c>
<l>clear_object_model_3d (Model3DAll)</l>
<c>* </c>
<c>* Prepare reference object for a more robust</c>
<c>* surface comparison.</c>
<c>* </c>
<c>* To get a more robust result, the reference object is</c>
<c>* subsampled to achieve a better resolution for the</c>
<c>* measurement. The subsampling needs a triangulation</c>
<c>* as a preprocessing step.</c>
<c>* </c>
<c>* Triangulate the model in a simple way</c>
<l>disp_message (WindowHandle, Status[0], 'window', 100, 12, 'white', 'false')</l>
<l>surface_normals_object_model_3d (Model3D, 'mls', 'mls_force_inwards', 'true', ObjectModel3DNormals)</l>
<l>triangulate_object_model_3d (ObjectModel3DNormals, 'greedy', 'greedy_remove_small_surfaces', 200, TriangulatedObjectModel3D, Information)</l>
<c>* Clean up memory</c>
<l>clear_object_model_3d (ObjectModel3DNormals)</l>
<c>* Sample the object for distance measurements</c>
<l>disp_message (WindowHandle, [Status[0] + ' ready.',Status[1]], 'window', 100, 12, 'white', 'false')</l>
<l>max_diameter_object_model_3d (TriangulatedObjectModel3D, Diameter)</l>
<l>sample_object_model_3d (TriangulatedObjectModel3D, 'fast', Diameter * 0.002, [], [], Model3DSampled)</l>
<l>disp_message (WindowHandle, [Status[0:1] + ' ready.',Status[2]], 'window', 100, 12, 'white', 'false')</l>
<c>* Clean up memory</c>
<l>clear_object_model_3d (Model3D)</l>
<c>* </c>
<c>* Create a surface model for alignment</c>
<l>create_surface_model (TriangulatedObjectModel3D, 0.01, 'model_invert_normals', 'true', SurfaceModelID)</l>
<c>* Display status</c>
<l>Message := Message + ' ready.'</l>
<l>disp_message (WindowHandle, Status + ' ready.', 'window', 100, 12, 'white', 'false')</l>
<c>* Display reference model</c>
<l>dev_clear_window ()</l>
<l>create_pose (1100, 1300, 35000, 140, 350, 55, 'Rp+T', 'gba', 'point', PoseDisplay)</l>
<l>Title := 'Reference object (uncalibrated measurement)'</l>
<l>* Pose := [1467.9,1330.73,33172.7,135.506,309.108,42.7514,0]</l>
<l>disp_object_model_3d_safe (WindowHandle, TriangulatedObjectModel3D, [], PoseDisplay, [], [])</l>
<l>disp_message (WindowHandle, Title, 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* Main loop:</c>
<c>* Perform a surface comparison on a number of objects</c>
<l>NumScenes := 1</l>
<l>for SceneIndex := 1 to NumScenes by 1</l>
<c>    * Reset the dispartities in the sheet of light model. All other settings can be reused</c>
<l>    reset_sheet_of_light_model (SheetOfLightModelID)</l>
<c>    * Collect and display the disparities from the sensor</c>
<l>    gen_image_const (Image, 'uint2', ProfileWidth, NumProfiles)</l>
<l>    for Index := 0 to NumProfiles - 1 by 1</l>
<l>        read_image (ImageSearch, 'sheet_of_light/metal_part_' + (SceneIndex + 1) + '_disparity_line_' + Index$'03d')</l>
<l>        get_grayval (ImageSearch, gen_tuple_const(ProfileWidth,0), [0:ProfileWidth - 1], Grayval)</l>
<l>        set_grayval (Image, gen_tuple_const(ProfileWidth,Index), [0:ProfileWidth - 1], Grayval)</l>
<l>        if (Index % 10 == 0)</l>
<l>            dev_display (Image)</l>
<l>        endif</l>
<l>        Message := 'Measure sample #' + SceneIndex</l>
<l>        Message[1] := 'Profile #' + (Index + 1)</l>
<l>        disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<c>        * Add the next profile to the sheet-of-light model</c>
<c>        * The offset is considered constant (= ScaleY)</c>
<l>        set_profile_sheet_of_light (ImageSearch, SheetOfLightModelID, [])</l>
<l>    endfor</l>
<c>    * Select the relevant part from the scene</c>
<l>    get_sheet_of_light_result_object_model_3d (SheetOfLightModelID, Scene3DAll)</l>
<l>    select_points_object_model_3d (Scene3DAll, 'point_coord_z', Clip, 800, Scene3D)</l>
<c>    * Clean up memory</c>
<l>    clear_object_model_3d (Scene3DAll)</l>
<c>    * Match the two objects</c>
<l>    disp_message (WindowHandle, 'Match model and scene ...', 'window', 60, 12, 'black', 'true')</l>
<l>    find_surface_model (SurfaceModelID, Scene3D, 0.02, 0.2, 0, 'false', [], [], Pose, Score, NotUsed)</l>
<l>    pose_invert (Pose, PosesInvert)</l>
<c>    * Transform the scene to match the reference object</c>
<l>    rigid_trans_object_model_3d (Scene3D, PosesInvert, ObjectModel3DRigidTrans)</l>
<c>    * Measure the distances between the scene and the model</c>
<l>    distance_object_model_3d (ObjectModel3DRigidTrans, Model3DSampled, [], 0.0, [], [])</l>
<c>    * Select points with a high distance</c>
<l>    select_points_object_model_3d (ObjectModel3DRigidTrans, '&amp;distance', ScaleY * 1.5, 1000, ObjectModel3DThresholded)</l>
<c>    * Calculate connected components, the distance threshold should</c>
<c>    * be greater than the distance between two scan lines (&gt; ScaleY)</c>
<l>    connection_object_model_3d (ObjectModel3DThresholded, 'distance_3d', ScaleY + 5, ObjectModel3DConnected)</l>
<c>    * Keep the large components, discard small ones as noise</c>
<l>    select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and', 200, 1000000, ObjectModel3DSelected)</l>
<c>    * Show the errorneous regions</c>
<l>    NumErrors := |ObjectModel3DSelected|</l>
<l>    VisParamNames := ['point_size','point_size_' + (NumErrors + 1),'color','color_' + NumErrors,'color_' + (NumErrors + 1),'alpha_' + NumErrors]</l>
<l>    VisParamValues := [5.0,2.0,'red','white','green',0.8]</l>
<l>    Title[0] := 'Sample #' + SceneIndex</l>
<l>    Title[1] := 'Found ' + NumErrors + ' error(s)'</l>
<l>    disp_object_model_3d_safe (WindowHandle, [ObjectModel3DSelected,TriangulatedObjectModel3D,ObjectModel3DRigidTrans], [], PoseDisplay, VisParamNames, VisParamValues)</l>
<l>    disp_message (WindowHandle, Title, 'window', 12, 12, 'black', 'true')</l>
<l>    wait_seconds (3)</l>
<c>    * Clean up memory</c>
<l>    clear_object_model_3d ([Scene3D,ObjectModel3DConnected,ObjectModel3DSelected,ObjectModel3DRigidTrans])</l>
<l>endfor</l>
<c>* Clean up memory</c>
<l>clear_object_model_3d ([Model3DSampled,TriangulatedObjectModel3D])</l>
<l>clear_sheet_of_light_model (SheetOfLightModelID)</l>
<l>clear_surface_model (SurfaceModelID)</l>
<l>return ()</l>
</body>
<docu id="p_do_compare_surface_sheet_of_light">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_aztec">
<interface/>
<body>
<c>* </c>
<c>* *****************************************************************************</c>
<c>* Example program for demonstrating the 2d data code operators</c>
<c>* *****************************************************************************</c>
<c>* This example program runs through an image sequence looking for</c>
<c>* 2d data code symbols (Aztec code).</c>
<c>* The model is adapted according to the searched symbols.</c>
<c>* The symbol size, the module size and an estimation concerning the gap between</c>
<c>* two modules are set.</c>
<c>* For normal dark-on-light symbols the improvement of the run time,</c>
<c>* that can be achieved by adapting the model is not very high -</c>
<c>* if the symbol is found, however, at big images,</c>
<c>* or if the symbol is not readable, the time saving may be significant.</c>
<c>* Furthermore, for some symbols it may be necessary to set some</c>
<c>* model parameters to be able to read the symbols at all.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>list_image_files ('datacode/aztec', 'default', [], ImageFiles)</l>
<l>SelectedImageFiles := regexp_select(ImageFiles,'(smartphone)|(ticket)|(ticket_machine)')</l>
<l>read_image (Image, SelectedImageFiles[0])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 512, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<c>* Create a 2d data code model.</c>
<c>* --------------------------------------------------</c>
<c>* This model describes the symbol class that is searched and serves as a</c>
<c>* container for collecting the results during the symbol search in order to</c>
<c>* access them later by the get_data_code_2d_* operators.</c>
<c>* </c>
<l>create_data_code_2d_model ('Aztec Code', [], [], DataCodeHandle)</l>
<l>set_data_code_2d_param (DataCodeHandle, ['module_size_min','module_size_max'], [3,11])</l>
<l>set_data_code_2d_param (DataCodeHandle, 'module_gap', 'no')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'polarity', 'any')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'mirrored', 'no')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'contrast_min', 20)</l>
<l>set_data_code_2d_param (DataCodeHandle, 'symbol_size_min', 19)</l>
<l>set_data_code_2d_param (DataCodeHandle, 'symbol_size_max', 143)</l>
<l>set_data_code_2d_param (DataCodeHandle, 'small_modules_robustness', 'high')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'finder_pattern_tolerance', 'high')</l>
<c>* </c>
<c>* Query a list of all supported model parameters, alphanumeric results,</c>
<c>* and iconic result objects; The operator query_data_code_2d_params</c>
<c>* returns a list of the generic parameter names that can be used</c>
<c>* in the get_ or set_data_code_2d_* operators.</c>
<c>* </c>
<l>query_data_code_2d_params (DataCodeHandle, 'get_model_params', GenParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_params', ResultParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_objects', ResultObjectNames)</l>
<c>* </c>
<c>* Within a loop:</c>
<c>* + read the next image</c>
<c>* + try to recognize the data code symbol(s)</c>
<c>* + for every image display the recognized symbol, the decoded string,</c>
<c>* and some data about the symbol and the search process</c>
<c>* </c>
<l>for ImageIndex := 0 to |SelectedImageFiles| - 1 by 1</l>
<c>    * </c>
<c>    * Read the next image</c>
<c>    * </c>
<l>    read_image (Image, SelectedImageFiles[ImageIndex])</l>
<c>    * </c>
<c>    * Look for the 2d data code symbols and measure the run time</c>
<c>    * of find_data_code_2d</c>
<c>    * </c>
<l>    count_seconds (T1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (T2)</l>
<l>    Time := 1000 * (T2 - T1)</l>
<c>    * </c>
<c>    * Get some interesting information about the search in general</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'result_num', ResultNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'candidate_num', CandNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'pass_num', Passes)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'undecoded_num', UndecNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', ['search_level','min_search_level','max_search_level'], SL)</l>
<l>    Message := 'Aztec code found and decoded in ' + Time$'.1f' + 'ms'</l>
<c>    * </c>
<c>    * Get some interesting information about all successfully detected symbols</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_rows', SymbolRows)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_cols', SymbolCols)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_height', ModuleHeight)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_width', ModuleWidth)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mirrored', Mirrored)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'contrast', Contrast)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'decoding_error', DecodingError)</l>
<c>    * </c>
<c>    * Display some of the general information (runtime, number of found symbols and passes).</c>
<c>    * </c>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (4)</l>
<l>    dev_display (SymbolXLDs)</l>
<c>    * </c>
<c>    * For all symbols display the encoded data string and some</c>
<c>    * info about the symbol and the reading process</c>
<c>    * </c>
<l>    for I := 0 to |ResultHandles| - 1 by 1</l>
<l>        select_obj (SymbolXLDs, SymbolXLD, I + 1)</l>
<l>        get_contour_xld (SymbolXLD, Row, Column)</l>
<l>        Message := DecodedDataStrings[I]</l>
<l>        get_string_extents (WindowHandle, Message + ' ', Ascent, Descent, MessageWidth, MessageHeight)</l>
<l>        gen_cross_contour_xld (Cross, Row, Column, 6, 0.785398)</l>
<l>        TRow := max(Row)</l>
<l>        TColumn := max([0,mean(Column) - MessageWidth / 2])</l>
<l>        if (TColumn == 0)</l>
<l>            Message[1] := '...'</l>
<l>        endif</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow - 1, TColumn - 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow - 1, TColumn + 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow + 1, TColumn - 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow + 1, TColumn + 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow, TColumn, 'green', 'false')</l>
<l>        Message := 'Decoding info:'</l>
<l>        Message[1] := 'Symbols:     ' + SymbolRows[I] + ' x ' + SymbolCols[I]</l>
<l>        Message[2] := 'Module size: ' + ModuleHeight[I]$'.1f' + ' x ' + ModuleWidth[I]$'.1f'</l>
<l>        Message[3] := 'Mirrored:    ' + Mirrored[I]</l>
<l>        Message[4] := 'Contrast:    ' + Contrast[I]$'.1f'</l>
<l>        Message[5] := 'Decode-err:  ' + DecodingError[I]</l>
<l>        disp_message (WindowHandle, Message, 'window', 41, 13, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 39, 11, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 41, 11, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 39, 13, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 40, 12, 'orange', 'false')</l>
<l>    endfor</l>
<l>    if (ImageIndex &lt; 2)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* Cleanup: close the 2d data code model</c>
<c>* </c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<l>return ()</l>
</body>
<docu id="p_do_aztec">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_microqr">
<interface/>
<body>
<c>* </c>
<c>* *****************************************************************************</c>
<c>* Example program for demonstrating the 2d data code operators</c>
<c>* *****************************************************************************</c>
<c>* This example program runs through an image sequence looking for</c>
<c>* 2d data code symbols (Micro QR code).</c>
<c>* The model is adapted according to the searched symbols.</c>
<c>* The symbol size, the module size and an estimation concerning the gap between</c>
<c>* two modules are set.</c>
<c>* For normal dark-on-light symbols the improvement of the run time,</c>
<c>* that can be achieved by adapting the model is not very high -</c>
<c>* if the symbol is found, however, at big images,</c>
<c>* or if the symbol is not readable, the time saving may be significant.</c>
<c>* Furthermore, for some symbols it may be necessary to set some</c>
<c>* model parameters to be able to read the symbols at all.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>list_image_files ('datacode/micro_qr', 'default', [], ImageFiles)</l>
<l>SelectedImageFiles := regexp_select(ImageFiles,'(cell_phone)|(board)')</l>
<l>read_image (Image, SelectedImageFiles[0])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<c>* Create a 2d data code model.</c>
<c>* --------------------------------------------------</c>
<c>* This model describes the symbol class that is searched and serves as a</c>
<c>* container for collecting the results during the symbol search in order to</c>
<c>* access them later by the get_data_code_2d_* operators.</c>
<c>* </c>
<l>create_data_code_2d_model ('Micro QR Code', [], [], DataCodeHandle)</l>
<l>set_data_code_2d_param (DataCodeHandle, ['module_size_min','module_size_max'], [3,8])</l>
<l>set_data_code_2d_param (DataCodeHandle, 'module_gap', 'no')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'polarity', 'any')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'mirrored', 'no')</l>
<l>set_data_code_2d_param (DataCodeHandle, 'contrast_min', 20)</l>
<l>set_data_code_2d_param (DataCodeHandle, 'symbol_size_min', 13)</l>
<l>set_data_code_2d_param (DataCodeHandle, 'symbol_size_max', 15)</l>
<c>* </c>
<c>* Query a list of all supported model parameters, alphanumeric results,</c>
<c>* and iconic result objects; The operator query_data_code_2d_params</c>
<c>* returns a list of the generic parameter names that can be used</c>
<c>* in the get_ or set_data_code_2d_* operators.</c>
<c>* </c>
<l>query_data_code_2d_params (DataCodeHandle, 'get_model_params', GenParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_params', ResultParamNames)</l>
<l>query_data_code_2d_params (DataCodeHandle, 'get_result_objects', ResultObjectNames)</l>
<c>* </c>
<c>* Within a loop:</c>
<c>* + read the next image</c>
<c>* + try to recognize the data code symbol(s)</c>
<c>* + for every image display the recognized symbol, the decoded string,</c>
<c>* and some data about the symbol and the search process</c>
<c>* </c>
<l>for ImageIndex := 0 to |SelectedImageFiles| - 2 by 1</l>
<c>    * </c>
<c>    * Read the next image</c>
<c>    * </c>
<l>    read_image (Image, SelectedImageFiles[ImageIndex])</l>
<c>    * </c>
<c>    * Look for the 2d data code symbols and measure the run time</c>
<c>    * of find_data_code_2d</c>
<c>    * </c>
<l>    count_seconds (T1)</l>
<l>    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandles, DecodedDataStrings)</l>
<l>    count_seconds (T2)</l>
<l>    Time := 1000 * (T2 - T1)</l>
<c>    * </c>
<c>    * Get some interesting information about the search in general</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'result_num', ResultNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'candidate_num', CandNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'pass_num', Passes)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', 'undecoded_num', UndecNum)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'general', ['search_level','min_search_level','max_search_level'], SL)</l>
<l>    Message := 'Micro QR code found\nand decoded in ' + Time$'.1f' + 'ms'</l>
<c>    * </c>
<c>    * Get some interesting information about all successfully detected symbols</c>
<c>    * </c>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_rows', SymbolRows)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'symbol_cols', SymbolCols)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_height', ModuleHeight)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'module_width', ModuleWidth)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'mirrored', Mirrored)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'contrast', Contrast)</l>
<l>    get_data_code_2d_results (DataCodeHandle, 'all_results', 'decoding_error', DecodingError)</l>
<c>    * </c>
<c>    * Display some of the general information (runtime, number of found symbols and passes).</c>
<c>    * </c>
<l>    dev_display (Image)</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (4)</l>
<l>    dev_display (SymbolXLDs)</l>
<c>    * </c>
<c>    * For all symbols display the encoded data string and some</c>
<c>    * info about the symbol and the reading process</c>
<c>    * </c>
<l>    for I := 0 to |ResultHandles| - 1 by 1</l>
<l>        select_obj (SymbolXLDs, SymbolXLD, I + 1)</l>
<l>        get_contour_xld (SymbolXLD, Row, Column)</l>
<l>        Message := DecodedDataStrings[I]</l>
<l>        get_string_extents (WindowHandle, Message + ' ', Ascent, Descent, MessageWidth, MessageHeight)</l>
<l>        gen_cross_contour_xld (Cross, Row, Column, 6, 0.785398)</l>
<l>        TRow := max(Row)</l>
<l>        TColumn := max([0,mean(Column) - MessageWidth / 2])</l>
<l>        if (TColumn == 0)</l>
<l>            Message[1] := '...'</l>
<l>        endif</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow - 1, TColumn - 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow - 1, TColumn + 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow + 1, TColumn - 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow + 1, TColumn + 1, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'image', TRow, TColumn, 'green', 'false')</l>
<l>        Message := 'Decoding info:'</l>
<l>        Message[1] := 'Symbols:     ' + SymbolRows[I] + ' x ' + SymbolCols[I]</l>
<l>        Message[2] := 'Module size: ' + ModuleHeight[I]$'.1f' + ' x ' + ModuleWidth[I]$'.1f'</l>
<l>        Message[3] := 'Mirrored:    ' + Mirrored[I]</l>
<l>        Message[4] := 'Contrast:    ' + Contrast[I]$'.1f'</l>
<l>        Message[5] := 'Decode-err:  ' + DecodingError[I]</l>
<l>        disp_message (WindowHandle, Message, 'window', 61, 13, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 59, 11, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 61, 11, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 59, 13, 'black', 'false')</l>
<l>        disp_message (WindowHandle, Message, 'window', 60, 12, 'orange', 'false')</l>
<l>    endfor</l>
<l>    if (ImageIndex &lt; 2)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (3)</l>
<l>    endif</l>
<l>endfor</l>
<l>wait_seconds (2)</l>
<c>* </c>
<c>* Cleanup: close the 2d data code model</c>
<c>* </c>
<l>clear_data_code_2d_model (DataCodeHandle)</l>
<l>return ()</l>
</body>
<docu id="p_do_microqr">
<parameters/>
</docu>
</procedure>
<procedure name="close_parallels">
<interface>
<io>
<par name="ParallelContours1" base_type="iconic" dimension="0"/>
<par name="ParallelContours2" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Contour" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>count_obj (ParallelContours1, Number)</l>
<l>gen_empty_obj (Contour)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (ParallelContours1, Parallel1, Index)</l>
<l>    select_obj (ParallelContours2, Parallel2, Index)</l>
<l>    get_contour_xld (Parallel1, Row1, Col1)</l>
<l>    get_contour_xld (Parallel2, Row2, Col2)</l>
<l>    gen_contour_polygon_xld (ClosedContour, [Row1,inverse(Row2),Row1[0]], [Col1,inverse(Col2),Col1[0]])</l>
<l>    concat_obj (Contour, ClosedContour, Contour)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="close_parallels">
<parameters>
<parameter id="Contour"/>
<parameter id="ParallelContours1"/>
<parameter id="ParallelContours2"/>
</parameters>
</docu>
</procedure>
<procedure name="align_bead">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageAligned" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="RowT" base_type="ctrl" dimension="0"/>
<par name="ColumnT" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Align the test image with the reference image using</c>
<c>* planar deformable matching</c>
<l>find_planar_uncalib_deformable_model (Image, ModelID, -0.39, 0.78, 1, 1, 1, 1, 0.5, 1, 1, 0, 0.9, [], [], HomMat2D1, Score)</l>
<l>hom_mat2d_invert (HomMat2D1, HomMat2DInvert)</l>
<l>hom_mat2d_translate (HomMat2DInvert, RowT, ColumnT, HomMat2DTranslate)</l>
<l>projective_trans_image (Image, ImageAligned, HomMat2DTranslate, 'bilinear', 'false', 'false')</l>
<l>return ()</l>
</body>
<docu id="align_bead">
<parameters>
<parameter id="ColumnT"/>
<parameter id="Image"/>
<parameter id="ImageAligned"/>
<parameter id="ModelID"/>
<parameter id="RowT"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_display_segments">
<interface>
<io>
<par name="TooThinSegments" base_type="iconic" dimension="0"/>
<par name="LeftContour" base_type="iconic" dimension="0"/>
<par name="RightContour" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ContoursIntersection" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* Construct contours used to visualize the error segments</c>
<c>* returned by the bead inspection</c>
<l>gen_parallel_contour_xld (TooThinSegments, ParallelContours1, 'regression_normal', 50)</l>
<l>gen_parallel_contour_xld (TooThinSegments, ParallelContours2, 'regression_normal', -50)</l>
<l>close_parallels (ParallelContours1, ParallelContours2, Contour)</l>
<l>close_parallels (LeftContour, RightContour, Contour1)</l>
<l>intersection_closed_contours_xld (Contour, Contour1, ContoursIntersection)</l>
<l>return ()</l>
</body>
<docu id="gen_display_segments">
<parameters>
<parameter id="ContoursIntersection"/>
<parameter id="LeftContour"/>
<parameter id="RightContour"/>
<parameter id="TooThinSegments"/>
</parameters>
</docu>
</procedure>
<procedure name="prepare_alignment">
<interface>
<oo>
<par name="RegionPart" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="RowT" base_type="ctrl" dimension="0"/>
<par name="ColumnT" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Set image coordinates of four points used to determine</c>
<c>* a projective transformation to rectify the reference</c>
<c>* image</c>
<l>Row := [658.232,291.923,314.817,691.533]</l>
<l>Col := [330.071,316.617,971.032,947.008]</l>
<c>* Set respective point coordinates to which the above</c>
<c>* defined points will be rectified</c>
<l>W := 5.4</l>
<l>H := 3.4</l>
<l>Row1 := 300 + [H,0,0,H] * 120.0</l>
<l>Col1 := 300 + [0,0,W,W] * 120.0</l>
<l>vector_to_proj_hom_mat2d (Row, Col, Row1, Col1, 'normalized_dlt', [], [], [], [], [], [], HomMat2D, Covariance)</l>
<c>* </c>
<c>* Read the reference image (image withou adhesive bead)</c>
<l>read_image (ImageRef, 'bead/adhesive_bead_ref')</l>
<c>* </c>
<c>* Rectify the reference image</c>
<l>projective_trans_image (ImageRef, ImageRefTrans, HomMat2D, 'bilinear', 'false', 'false')</l>
<c>* </c>
<c>* Determine a region that contains the planar</c>
<c>* part on which the adhesive bead will be applied.</c>
<c>* This planar part will also be used to align the</c>
<c>* test images with the reference image.</c>
<l>binary_threshold (ImageRefTrans, Region, 'smooth_histo', 'light', UsedThreshold)</l>
<l>opening_circle (Region, RegionOpening, 5.5)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>area_center (ConnectedRegions, AreaCR, RowCR, ColumnCR)</l>
<l>select_obj (ConnectedRegions, ObjectSelected, sort_index(-AreaCR)[0] + 1)</l>
<l>fill_up (ObjectSelected, RegionFillUp)</l>
<l>dilation_circle (RegionFillUp, RegionPart, 5.5)</l>
<l>reduce_domain (ImageRefTrans, RegionPart, ImageReduced)</l>
<l>area_center (RegionPart, AreaT, RowT, ColumnT)</l>
<l>create_planar_uncalib_deformable_model (ImageReduced, 'auto', -0.39, 0.79, 'auto', 1, 1, 'auto', 1, 1, 'auto', 'none', 'use_polarity', 'auto', 'auto', [], [], ModelID)</l>
<l>return ()</l>
</body>
<docu id="prepare_alignment">
<parameters>
<parameter id="ColumnT"/>
<parameter id="ModelID"/>
<parameter id="RegionPart"/>
<parameter id="RowT"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_bead_inspection">
<interface/>
<body>
<c>* This example shows how to use bead inspection to verify</c>
<c>* adhesive beads. Bead inspection can be used to detect the</c>
<c>* following errors:</c>
<c>*  - segments where adhesive is missing</c>
<c>*  - segments with too much or too little adhesive</c>
<c>*  - segments where adhesive is too far from its destined</c>
<c>*    position</c>
<c>* </c>
<c>* apply_bead_inspection_model requires that the images to inspect</c>
<c>* are already aligned with the reference contour. In this example,</c>
<c>* the alignment is based on planar deformable matching.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Create the planar deformable model to align images with the</c>
<c>* reference contour</c>
<l>prepare_alignment (RegionPart, RowT, ColumnT, ModelID)</l>
<l>smallest_rectangle1 (RegionPart, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<c>* </c>
<c>* Define the reference path of the adhesive beads. This path could</c>
<c>* also be generated by drawing it on a reference image with, e.g.,</c>
<c>* draw_nurbs.</c>
<l>gen_contour_nurbs_xld (ContourRef, [701.767,626.953,538.867,443.54,390.447,360.28,354.247,363.9,400.1,458.02,509.907,588.34,659.533,696.94], [319.24,336.133,367.507,431.46,489.38,546.093,646.247,722.267,776.567,826.04,869.48,912.92,934.64,929.813], 'auto', [15,15,15,15,15,15,15,15,15,15,15,15,15,15], 3, 1, 5)</l>
<c>* </c>
<c>* Create a new bead inspection model with the following parameters</c>
<l>TargetWidth := 14</l>
<l>WidthTolerance := 7</l>
<l>PositionTolerance := 30</l>
<l>Polarity := 'dark'</l>
<l>Threshold := 30</l>
<l>create_bead_inspection_model (ContourRef, TargetWidth, WidthTolerance, PositionTolerance, Polarity, 'threshold', Threshold, BeadInspectionModel)</l>
<c>* </c>
<c>* Show a correct adhesive bead together with the reference contour</c>
<l>read_image (Image, 'bead/adhesive_bead_01')</l>
<l>align_bead (Image, ImageAligned, ModelID, RowT, ColumnT)</l>
<c>* </c>
<c>* Create two parallel contours to give an impression of how</c>
<c>* thick a correct adhesive bead should be</c>
<l>gen_parallel_contour_xld (ContourRef, ModelSide1, 'regression_normal', TargetWidth * 0.5)</l>
<l>gen_parallel_contour_xld (ContourRef, ModelSide2, 'regression_normal', -TargetWidth * 0.5)</l>
<l>concat_obj (ModelSide1, ModelSide2, ModelSides)</l>
<c>* </c>
<c>* Create two parallel contours to give an impression of where</c>
<c>* a correct adhesive bead should be located</c>
<l>gen_parallel_contour_xld (ContourRef, PositionToleranceSide1, 'regression_normal', PositionTolerance)</l>
<l>gen_parallel_contour_xld (ContourRef, PositionToleranceSide2, 'regression_normal', -PositionTolerance)</l>
<l>concat_obj (PositionToleranceSide1, PositionToleranceSide2, PositionToleranceSides)</l>
<l>dev_close_window ()</l>
<l>dev_open_window_fit_size (0, 0, PartColumn2 - PartColumn1 + 1, PartRow2 - PartRow1 + 41, 640, -1, WindowHandle)</l>
<l>p_set_font (WindowHandle)</l>
<l>dev_set_part (PartRow1 - 20, PartColumn1, PartRow2 + 20, PartColumn2)</l>
<l>dev_display (ImageAligned)</l>
<l>dev_set_line_width (2)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (ContourRef)</l>
<l>dev_set_line_width (1)</l>
<l>dev_display (ModelSides)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (PositionToleranceSides)</l>
<l>Message := 'Correct adhesive bead and the reference contour. The'</l>
<l>Message[1] := 'yellow contours indicate the range of position tolerance.'</l>
<l>disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* Now, perform the inspection task</c>
<l>TextOffset := 20</l>
<l>NumImages := 7</l>
<l>for J := 1 to 3 by 1</l>
<l>    for Index := 1 to NumImages by 1</l>
<l>        read_image (Image, 'bead/adhesive_bead_' + Index$'02')</l>
<c>        * </c>
<c>        * Align the input image with the reference image</c>
<l>        align_bead (Image, ImageAligned, ModelID, RowT, ColumnT)</l>
<c>        * </c>
<c>        * Apply the bead inspection model to the aligned image</c>
<l>        apply_bead_inspection_model (ImageAligned, LeftContour, RightContour, ErrorSegment, BeadInspectionModel, ErrorType)</l>
<c>        * </c>
<c>        * Display the segmented adhesive bead with its error segments</c>
<l>        dev_display (ImageAligned)</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_set_color ('white')</l>
<l>        dev_display (ContourRef)</l>
<l>        dev_display (ModelSides)</l>
<l>        dev_display (PositionToleranceSides)</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (LeftContour)</l>
<l>        dev_display (RightContour)</l>
<l>        dev_set_color ('red')</l>
<l>        dev_display (ErrorSegment)</l>
<l>        if (|ErrorType| == 0)</l>
<c>            * No errors detected</c>
<l>            Message := 'Adhesive bead is OK'</l>
<l>            disp_message (WindowHandle, Message, 'window', 12, 12, 'white', 'forest green')</l>
<l>        else</l>
<c>            * Display errors by error class</c>
<l>            Message[0] := 'Adhesive bead is not OK:'</l>
<c>            * </c>
<l>            ErrorClasses := ['no bead','too thin','too thick','incorrect position']</l>
<l>            for ClassIndex := 0 to |ErrorClasses| - 1 by 1</l>
<l>                Class := ErrorClasses[ClassIndex]</l>
<l>                ErrorIndices := find(ErrorType,Class)</l>
<l>                if (ErrorIndices != -1)</l>
<l>                    select_obj (ErrorSegment, SelectedSegments, ErrorIndices + 1)</l>
<l>                    dev_set_color ('red')</l>
<l>                    dev_set_line_width (3)</l>
<l>                    if (Class != 'no bead')</l>
<l>                        gen_display_segments (SelectedSegments, LeftContour, RightContour, ErrorParts)</l>
<l>                        dev_display (ErrorParts)</l>
<l>                    else</l>
<l>                        dev_display (SelectedSegments)</l>
<l>                    endif</l>
<l>                    area_center_points_xld (SelectedSegments, Area, Row, Column)</l>
<l>                    for E := 0 to |ErrorIndices| - 1 by 1</l>
<l>                        disp_message (WindowHandle, ErrorIndices[E] + 1, 'image', Row[E], Column[E] - TextOffset, 'white', 'red')</l>
<l>                        TextOffset := 20 - TextOffset</l>
<l>                    endfor</l>
<l>                endif</l>
<l>            endfor</l>
<l>            disp_message (WindowHandle, Message, 'window', 12, 12, 'white', 'red')</l>
<l>            disp_message (WindowHandle, [1:|ErrorType|] + ': ' + ErrorType, 'image', 500, 500, 'red', 'false')</l>
<l>        endif</l>
<l>        if (J == 1)</l>
<l>            p_disp_pause_sign (WindowHandle, 2)</l>
<l>            wait_seconds (1.5)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* Release all allocated memory</c>
<l>clear_bead_inspection_model (BeadInspectionModel)</l>
<l>clear_deformable_model (ModelID)</l>
<l>return ()</l>
</body>
<docu id="p_do_bead_inspection">
<parameters/>
</docu>
</procedure>
<procedure name="show_setup">
<interface>
<io>
<par name="ImagePart" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Generate image of the scene</c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>* get_window_extents (WindowHandle, WRow, WColumn, WindowWidth, WindowHeight)</l>
<l>WindowWidth := 500</l>
<l>WindowHeight := 400</l>
<l>dev_set_part (0, 0, 399, 499)</l>
<l>S := [340,10]</l>
<l>LP := [170,210]</l>
<l>OP := [S[0],410]</l>
<l>L := 240</l>
<l>Phi1 := rad(135)</l>
<l>Phi2 := rad(155)</l>
<l>CP := [S[0] + L * cos(Phi2),S[1] + L * sin(Phi2)]</l>
<l>gen_rectangle1 (Obstacle, 0, 258, 173, WindowWidth - 1)</l>
<l>gen_contour_polygon_xld (LensPlane, [S[0],LP[0]], [S[1],LP[1]])</l>
<l>gen_contour_polygon_xld (ImagePlane, [S[0],CP[0]], [S[1],CP[1]])</l>
<l>gen_contour_polygon_xld (ObjectPlane, [S[0],S[0]], [0,WindowWidth - 1])</l>
<l>gen_circle (ScheimpflugAxis, S[0], S[1], 4.5)</l>
<l>LL := 30</l>
<l>gen_region_polygon_filled (Lens, [LP[0],LP[0] + LL,LP[0],LP[0]] - 7, [LP[1],LP[1],LP[1] + LL,LP[1]] - 7)</l>
<l>gen_contour_polygon_xld (Lens1, [LP[0],LP[0] + LL,LP[0],LP[0]] - 7, [LP[1],LP[1],LP[1] + LL,LP[1]] - 7)</l>
<l>gen_rectangle2 (CameraTilt, CP[0] + 15, CP[1] + 45, Phi2, 50, 30)</l>
<l>gen_rectangle2 (Camera, LP[0] - 40, LP[1] - 40, Phi1, 45, 30)</l>
<l>gen_contour_polygon_xld (OpticalAxis, [LP[0],LP[0] + L * cos(Phi1 - rad(90))], [LP[1],LP[1] + L * sin(Phi1 - rad(90))])</l>
<c>* </c>
<l>Row := [134,134,1000,1000] - 134</l>
<l>Column := [6,1280,6,1280] - 6</l>
<l>RowNew := [OP[0] - 20,OP[0] - 20,OP[0] + 20,OP[0] + 20]</l>
<l>ColumnNew := [OP[1] - 45,OP[1] + 55,OP[1] - 90,OP[1] + 35]</l>
<l>vector_to_proj_hom_mat2d (Row, Column, RowNew, ColumnNew, 'normalized_dlt', [], [], [], [], [], [], HomMat2D, Covariance)</l>
<l>projective_trans_image_size (ImagePart, TransImage, HomMat2D, 'bilinear', 500, 400, 'false')</l>
<c>* </c>
<l>dev_clear_window ()</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_color ('gray')</l>
<l>dev_set_draw ('fill')</l>
<c>* </c>
<l>if (Tilt)</l>
<l>    dev_display (CameraTilt)</l>
<l>    dev_set_color ('forest green')</l>
<l>    dev_display (LensPlane)</l>
<l>    dev_display (ImagePlane)</l>
<l>    dev_display (ScheimpflugAxis)</l>
<l>    dev_display (ObjectPlane)</l>
<l>    disp_message (WindowHandle[0], 'object plane', 'image', S[0], S[1] + 100, 'forest green', 'false')</l>
<l>    disp_message (WindowHandle[0], 'S', 'image', S[0], S[1], 'forest green', 'false')</l>
<l>    disp_message (WindowHandle[0], 'image plane', 'image', (S[0] + CP[0]) / 2 - 180, (S[1] + CP[1]) / 2 - 40, 'forest green', 'false')</l>
<l>    disp_message (WindowHandle[0], 'lens plane', 'image', (S[0] + LP[0]) / 2, (S[1] + LP[1]) / 2, 'forest green', 'false')</l>
<l>else</l>
<l>    dev_display (Camera)</l>
<l>    dev_set_color ('black')</l>
<l>    dev_display (ObjectPlane)</l>
<c>    * </c>
<l>endif</l>
<l>dev_display (TransImage)</l>
<l>dev_display (OpticalAxis)</l>
<l>dev_set_color ('gray')</l>
<l>dev_display (Obstacle)</l>
<l>dev_display (Lens)</l>
<l>disp_message (WindowHandle[0], 'optical axis', 'image', (LP[0] + OP[0]) / 2 - 20, (LP[1] + OP[1]) / 2, 'black', 'false')</l>
<l>disp_message (WindowHandle[0], 'lens', 'image', LP[0] + 25, LP[1] - 30, 'black', 'false')</l>
<l>disp_message (WindowHandle[0], 'obstacle', 'image', 60, 300, 'black', 'false')</l>
<l>disp_message (WindowHandle[0], 'camera', 'image', CP[0], CP[1], 'black', 'false')</l>
<l>return ()</l>
</body>
<docu id="show_setup">
<parameters>
<parameter id="ImagePart"/>
<parameter id="Tilt"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="open_two_windows_setup">
<interface>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="Scale" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure opens two windows in order to display</c>
<c>* the images and results for this example</c>
<c>* </c>
<l>dev_open_window_fit_size (0, 0, Width, Height, 640, -1, WindowHandle2)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_color ('green')</l>
<l>set_display_font (WindowHandle2, 14, 'mono', 'true', 'false')</l>
<c>* </c>
<l>get_window_extents (WindowHandle2, Row, Column, Width1, Height1)</l>
<l>dev_open_window (Height1 - 200, 0, 250, 200, 'white', WindowHandle1)</l>
<l>dev_set_part (0, 0, 399, 499)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_color ('green')</l>
<l>set_display_font (WindowHandle1, 14, 'mono', 'true', 'false')</l>
<c>* </c>
<l>WindowHandles := [WindowHandle1,WindowHandle2]</l>
</body>
<docu id="open_two_windows_setup">
<parameters>
<parameter id="Height"/>
<parameter id="Scale"/>
<parameter id="Width"/>
<parameter id="WindowHandles"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_calibrate_cameras_telecentric_tilt">
<interface/>
<body>
<c>* </c>
<c>* This example demonstrates the benefit of a tilt lens</c>
<c>* and calibrates a camera with a telecentric tilt lens.</c>
<c>* Some peculiarities for telecentric tilt lenses are</c>
<c>* pointed out.</c>
<c>* </c>
<c>* Prepare windows</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>read_image (ImageBlurred, 'caliper/caliper_no_tilt')</l>
<l>get_image_size (ImageBlurred, Width, Height)</l>
<l>open_two_windows_setup (Width, Height, 1, WindowHandles)</l>
<c>* </c>
<c>* When the optical axis is not perpendicular to the</c>
<c>* measurement plane, the volume of the depth of focus</c>
<c>* is not parallel to the measurement plane.</c>
<c>* As a consequence of this camera setup, a part of an object</c>
<c>* lying in the measurement plane appears blurred in the image.</c>
<l>dev_set_window (WindowHandles[0])</l>
<l>read_image (ImageBlurred, 'caliper/caliper_no_tilt')</l>
<l>get_image_size (ImageBlurred, Width, Height)</l>
<l>crop_rectangle1 (ImageBlurred, ImagePart, 134, 134, 1000, 1000)</l>
<c>* Generate image of the scene</c>
<l>Message := 'If the optical axis is not perpendicular to the measurement plane,'</l>
<l>dev_set_window (WindowHandles[1])</l>
<l>gen_rectangle1 (ROIBlurredL, 231, 844, 897, 1276)</l>
<l>gen_rectangle1 (ROIBlurredR, 231, 7, 897, 170)</l>
<l>dev_display (ImageBlurred)</l>
<l>dev_set_color ('red')</l>
<l>dev_set_line_width (2)</l>
<l>dev_display (ROIBlurredR)</l>
<l>dev_display (ROIBlurredL)</l>
<l>Message[1] := 'parts of the object in the measurement plane are blurred in the image.'</l>
<l>disp_message (WindowHandles[1], Message, 'window', 12, 12, 'black', 'true')</l>
<l>show_setup (ImagePart, WindowHandles[0], 0)</l>
<l>dev_set_window (WindowHandles[0])</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* If the camera is equipped with a tilt lens,</c>
<c>* the lens can be tilted so that the whole measurement</c>
<c>* plane is in focus.</c>
<l>read_image (ImageSharp, 'caliper/caliper_with_tilt')</l>
<l>dev_set_window (WindowHandles[1])</l>
<l>dev_display (ImageSharp)</l>
<l>Message := 'If the camera is equipped with a tilt lens, the lens can be tilted'</l>
<l>Message[1] := 'so that the entire measurement plane is in focus.'</l>
<l>disp_message (WindowHandles[1], Message, 'window', 12, 12, 'black', 'true')</l>
<l>show_setup (ImagePart, WindowHandles[0], 1)</l>
<l>* disp_continue_message (WindowHandles[1], 'black', 'true')</l>
<l>wait_seconds (3)</l>
<c>* </c>
<c>* Calibration of a camera with telecentric tilt lens</c>
<l>dev_set_window (WindowHandles[0])</l>
<l>dev_close_window ()</l>
<l>Message := 'Calibrate camera with a telecentric tilt lens'</l>
<l>dev_set_window (WindowHandles[1])</l>
<l>dev_set_color ('green')</l>
<c>* Specify initial camera parameter.</c>
<c>* The tilt angle defines the angle by which the</c>
<c>* lens is tilted.</c>
<l>Tilt := 8.5</l>
<c>* The rotation angle defines the orientation of</c>
<c>* the axis around which the tilt is performed.</c>
<c>* It is the angle between the x-axis of</c>
<c>* the sensor and the tilt axis of the lens.</c>
<l>Rot := 270</l>
<c>* Define size of a pixel in world coordinates</c>
<l>Sx := 1.54e-5</l>
<l>Sy := Sx</l>
<l>StartCamParam := [0,0.0,Tilt,Rot,Sx,Sy,Width / 2,Height / 2,Width,Height]</l>
<l>DescrFile := 'calplate_40mm.cpd'</l>
<c>* </c>
<c>* Create the calibration data model</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, 'area_scan_telecentric_tilt_division', StartCamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, DescrFile)</l>
<c>* </c>
<c>* Input calibration data into the calibration model</c>
<l>for Index := 1 to 8 by 1</l>
<l>    read_image (Image, 'stereo/telecentric_tilt/cam_0_calib_plate_' + Index$'02')</l>
<l>    find_calib_object (Image, CalibDataID, 0, 0, Index, 'sigma', 2.5)</l>
<l>    get_calib_data_observ_contours (Caltab, CalibDataID, 'caltab', 0, 0, Index)</l>
<l>    get_calib_data_observ_contours (Circles, CalibDataID, 'marks', 0, 0, Index)</l>
<c>    * Visualize calibration object found in the current image</c>
<l>    dev_display (Image)</l>
<l>    dev_display (Caltab)</l>
<l>    dev_display (Circles)</l>
<l>    disp_message (WindowHandles[1], Message, 'window', 12, 12, 'black', 'true')</l>
<l>    wait_seconds (0.1)</l>
<l>endfor</l>
<c>* </c>
<c>* Calibrate the cameras</c>
<l>calibrate_cameras (CalibDataID, Error)</l>
<c>* Inspect the calibration results</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam)</l>
<c>* Get the names of the camera parameters for this model</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params_labels', ParLabels)</l>
<l>Message := 'Measure the mean distance of the pitch lines'</l>
<l>Message[1] := 'of a caliper with high accuracy.'</l>
<l>dev_set_line_width (2)</l>
<c>* </c>
<c>* Extract measurement plane using the optimized</c>
<c>* camera parameters</c>
<l>read_image (ImageMeasurementPlane, 'caliper/caliper_measurement_plane')</l>
<l>find_calib_object (ImageMeasurementPlane, CalibDataID, 0, 0, 0, 'sigma', 0.5)</l>
<l>get_calib_data_observ_points (CalibDataID, 0, 0, 0, RowCoor, ColumnCoord, Indices, Poses)</l>
<c>* </c>
<c>* Note that for telecentric cameras the distance z</c>
<c>* to the camera does not have an effect on the appearance of</c>
<c>* the calibration plate in the image. Therefore cannot be</c>
<c>* determined. Another consequence is that the pose of the</c>
<c>* measurement plane does not need to be compensated</c>
<c>* for the plate thickness.</c>
<c>* </c>
<c>* Measure the mean distance between the pitch lines</c>
<l>gen_measure_rectangle2 (670, 640, rad(0), 635, 31, Width, Height, 'bilinear', MeasureHandle)</l>
<l>gen_rectangle2 (Rectangle, 670, 640, rad(0), 635, 31)</l>
<c>* </c>
<c>* Determine the image positions of the pitch lines</c>
<l>measure_pairs (ImageSharp, MeasureHandle, 2, 50, 'all', 'all', RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)</l>
<l>Row := (RowEdgeFirst + RowEdgeSecond) / 2.0</l>
<l>Col := (ColumnEdgeFirst + ColumnEdgeSecond) / 2.0</l>
<l>gen_cross_contour_xld (Cross, Row, Col, 20, 0.785398)</l>
<l>dev_display (ImageSharp)</l>
<l>dev_display (Cross)</l>
<c>* </c>
<c>* Determine the positions of the pitch lines in camera coordinates</c>
<l>image_points_to_world_plane (CamParam, Poses, Row, Col, 'mm', X1, Y1)</l>
<l>distance_pp (X1[0:2], Y1[0:2], X1[1:3], Y1[1:3], Distance)</l>
<c>* </c>
<c>* Compute the mean and the deviation of the distances.</c>
<l>MeanDistance := mean(Distance)</l>
<l>DeviationDistance := deviation(Distance)</l>
<l>disp_message (WindowHandles[1], [Message,'Mean distance: ' + MeanDistance$'.3f' + ' mm','Deviation:'$'-15' + DeviationDistance$'.3f' + ' mm'], 'window', 12, 12, 'black', 'true')</l>
<l>wait_seconds (5)</l>
<l>close_measure (MeasureHandle)</l>
<c>* </c>
<c>* Delete calibration data model</c>
<l>clear_calib_data (CalibDataID)</l>
<l>return ()</l>
</body>
<docu id="p_do_calibrate_cameras_telecentric_tilt">
<parameters/>
</docu>
</procedure>
<procedure name="display_side">
<interface>
<ic>
<par name="WindowHandleDisp" base_type="ctrl" dimension="0"/>
<par name="SideString" base_type="ctrl" dimension="0"/>
<par name="Finished" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displayes a regular cube with the Side (Input control parameter)</c>
<c>* highlighted. If Finished is true, then the corresponding is highlighted</c>
<c>* in green, otherwise in red. The cube consists of 6 single planar object</c>
<c>* model 3D.</c>
<l>Pose := [-0.595188,-0.424915,120,8.36578,10.6173,358.628,0]</l>
<l>Alpha := 0.2</l>
<c>* </c>
<l>Color := 'red'</l>
<c>* </c>
<l>DisplayColor := [Color,Color,Color,Color,Color,Color,'yellow']</l>
<l>DisplayAlpha := [Alpha,Alpha,Alpha,Alpha,Alpha,Alpha,1.0]</l>
<l>DisplayLines := ['1.0 1.0 1.0','0.0 0.0 0.0','0.5 0.5 0.5 0.0','true','black',6.0]</l>
<c>* </c>
<l>Side := find(['front','left','back','right','bottom','top'],SideString)</l>
<l>SideStringCapital := ['Front','Left','Back','Right','Bottom','Top']</l>
<c>* </c>
<l>if (Finished)</l>
<l>    DisplayColor[Side] := 'green'</l>
<l>endif</l>
<c>* </c>
<l>DisplayAlpha[Side] := 1.0</l>
<c>* </c>
<l>DisplayValues := [DisplayColor,DisplayAlpha,DisplayLines]</l>
<c>* </c>
<c>* Generate cube points</c>
<l>X := [0,0,1,1,0,0,1,1]</l>
<l>Y := [0,1,1,0,0,1,0,1]</l>
<l>Z := [0,0,0,0,1,1,1,1]</l>
<c>* </c>
<c>* Generate the side planes of the cube</c>
<l>gen_plane_object_model_3d ([0,0,0,0,0,0,0], X[0:3], Y[0:3], OM3DFront)</l>
<l>gen_plane_object_model_3d ([0,0,1,0,0,0,0], X[0:3], Y[0:3], OM3DBack)</l>
<l>gen_plane_object_model_3d ([0,0,0,0,-90,0,0], X[0:3], Y[0:3], OM3DLeft)</l>
<l>gen_plane_object_model_3d ([0,1,0,90,0,0,0], X[0:3], Y[0:3], OM3DBottom)</l>
<l>gen_plane_object_model_3d ([1,0,0,0,-90,0,0], X[0:3], Y[0:3], OM3DRight)</l>
<l>gen_plane_object_model_3d ([1,0,0,90,0,90,0], X[0:3], Y[0:3], OM3DTop)</l>
<c>* </c>
<c>* To optimize the display for different systems</c>
<l>if (Side != 0)</l>
<l>    gen_empty_object_model_3d (OM3DFront)</l>
<l>endif</l>
<l>if (Side != 3)</l>
<l>    gen_empty_object_model_3d (OM3DRight)</l>
<l>endif</l>
<c>* </c>
<c>* Generate 3D model of the corners and their connecting lines</c>
<l>gen_object_model_3d_from_points (X, Y, Z, OM3DCorners)</l>
<l>set_object_model_3d_attrib (OM3DCorners, 'lines', [], [2,0,1,2,1,2,2,2,3,2,3,0,2,0,4,2,4,5,2,5,1,2,6,3,2,7,2,2,4,5,2,5,7,2,7,6,2,6,4], OM3DLines)</l>
<c>* </c>
<c>* Display object models 3D</c>
<l>DisplayOptions := ['color_0','color_1','color_2','color_3','color_4','color_5','color_6','alpha_0','alpha_1','alpha_2','alpha_3','alpha_4','alpha_5','alpha_6','light_ambient','light_diffuse','light_position','disp_lines','line_color','point_size']</l>
<l>disp_object_model_3d (WindowHandleDisp, [OM3DFront,OM3DLeft,OM3DBack,OM3DRight,OM3DBottom,OM3DTop,OM3DCorners,OM3DLines], [], Pose, DisplayOptions, DisplayValues)</l>
<c>* </c>
<l>clear_object_model_3d (OM3DFront)</l>
<l>clear_object_model_3d (OM3DBack)</l>
<l>clear_object_model_3d (OM3DLeft)</l>
<l>clear_object_model_3d (OM3DBottom)</l>
<l>clear_object_model_3d (OM3DRight)</l>
<l>clear_object_model_3d (OM3DTop)</l>
<l>clear_object_model_3d (OM3DCorners)</l>
<l>clear_object_model_3d (OM3DLines)</l>
<c>* </c>
<l>disp_message (WindowHandleDisp, SideStringCapital[Side], 'window', 12, 12, 'black', 'true')</l>
<l>return ()</l>
</body>
<docu id="display_side">
<parameters>
<parameter id="Finished"/>
<parameter id="SideString"/>
<parameter id="WindowHandleDisp"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_find_text_expiration_date">
<interface/>
<body>
<c>* This example shows how find_text can be used to find and read</c>
<c>* expiration dates from medication packages. In general, the</c>
<c>* expiration dates of medication packages from different manufacteurs</c>
<c>* are located on different sides of the package. The following example</c>
<c>* reads the text of each side of different medication packages</c>
<c>* and searches for an expiry date. As soon as an expiration date is</c>
<c>* found, the next package is processed.</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<c>* Initialize window handle</c>
<l>dev_open_window_fit_size (0, 0, 960, 768, 640, 600, WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Create the text model using the pre-trained 'Industrial_Rej' font</c>
<l>create_text_model_reader ('auto', 'Industrial_Rej', TextModel)</l>
<c>* </c>
<c>* Determine the order with which to search for the expiration date</c>
<c>* in the medical packages:</c>
<l>Order := ['front','left','back','right','bottom','top']</l>
<c>* </c>
<c>* Initialize window handle to help display the package side</c>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_open_window (Height - 150, 0, 150, 150, 'black', WindowHandleBox)</l>
<l>set_display_font (WindowHandleBox, 16, 'mono', 'true', 'false')</l>
<l>for J := 1 to 1 by 1</l>
<l>    for BoxIdx := 0 to 2 by 1</l>
<c>        * Search for the date on each side of the medicine package</c>
<l>        Dates := ''</l>
<l>        Finished := 0</l>
<l>        for ImageIdx := 0 to 5 by 1</l>
<l>            ImageString := 'ocr/medication_package_' + (BoxIdx + 1)$'0.2d' + '_' + Order[ImageIdx]</l>
<l>            read_image (Image, ImageString)</l>
<c>            * </c>
<l>            find_text (Image, TextModel, TextResult)</l>
<c>            * </c>
<c>            * Read all text lines from TextResult</c>
<l>            get_text_object (TextLines, TextResult, 'all_lines')</l>
<l>            get_text_result (TextResult, 'num_lines', NumLines)</l>
<c>            * </c>
<c>            * Read the text lines one after the other and check for dates</c>
<l>            select_expiry_date (Date, NumLines, TextResult, Dates, ImageIdx, DateIdx, Dates)</l>
<l>            clear_text_result (TextResult)</l>
<c>            * </c>
<c>            * Display results</c>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_set_colored (12)</l>
<l>            dev_display (Image)</l>
<l>            dev_display (TextLines)</l>
<c>            * </c>
<c>            * Show what is happening step by step</c>
<l>            disp_steps (Date, BoxIdx, WindowHandle, Dates, Finished)</l>
<c>            * </c>
<c>            * Display cube current side</c>
<l>            display_side (WindowHandleBox, Order[ImageIdx], Finished)</l>
<c>            * </c>
<c>            * For the first iteration, show what is happening in each step</c>
<l>            if (BoxIdx == 0 and J == 1)</l>
<l>                p_disp_pause_sign (WindowHandle, 2)</l>
<l>                wait_seconds (1)</l>
<l>            endif</l>
<l>            if (Finished)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>        wait_seconds (1)</l>
<l>    endfor</l>
<l>endfor</l>
<l>dev_set_window (WindowHandleBox)</l>
<l>dev_close_window ()</l>
<l>clear_text_model (TextModel)</l>
<l>return ()</l>
</body>
<docu id="p_do_find_text_expiration_date">
<parameters/>
</docu>
</procedure>
<procedure name="p_do_find_barcode">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 512, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>IndustrialFiles := '25industrial/25industrial0' + [1:4]</l>
<l>InterleavedFiles := '25interleaved/25interleaved' + [[1:16]$'02','_exposure_0' + [1:5],'_zeiss1']</l>
<l>CodabarFiles := 'codabar/codabar0' + [1:6]</l>
<l>Code128Files := 'code128/code12801'</l>
<l>Code39Files := 'code39/code390' + [2:4]</l>
<l>EAN13Files := 'ean13/' + ['ean13' + [[1:12]$'02','_label','_to_preprocess_0' + [2:3]],'tea_box_' + [1:8]$'02']</l>
<l>EAN13Addon5Files := 'ean13addon5/ean13addon501'</l>
<l>EAN8Files := 'ean8/ean801'</l>
<l>MixedFiles := 'mixed/barcode_mixed_' + [[1:2]$'02','quiet_zone']</l>
<l>GS1_128Files := 'gs1_128/gs1_128_' + 'generated_0' + [1:3]</l>
<l>GS1CompositeFiles := 'gs1databar_composite/gs1databar_limited_composite_01'</l>
<l>GS1ExpandedFiles := 'gs1databar_expanded/gs1databar_expanded_calibration_' + ['01','aperture_focus','init_position']</l>
<l>GS1ExpandedStackedFiles := 'gs1databar_expanded_stacked/gs1databar_expanded_stacked_0' + [1:2]</l>
<l>GS1LimitedFiles := 'gs1databar_limited/gs1databar_limited_no_deform'</l>
<l>GS1OmnidirFiles := 'gs1databar_omnidir/gs1databar_omnidir_0' + [1:2]</l>
<l>GS1StackedFiles := 'gs1databar_stacked/gs1databar_stacked_01'</l>
<l>GS1StackedOmnidirFiles := 'gs1databar_stacked_omnidir/gs1databar_stacked_omnidir_0' + [1:2]</l>
<l>GS1TruncatedFiles := 'gs1databar_truncated/gs1databar_truncated_02'</l>
<l>ImageFiles := 'barcode/' + [IndustrialFiles,InterleavedFiles,CodabarFiles,Code128Files,Code39Files,EAN13Files,MixedFiles]</l>
<l>ImageFiles := [ImageFiles,'barcode/' + [EAN8Files,GS1_128Files,GS1CompositeFiles,GS1ExpandedFiles,GS1ExpandedStackedFiles]]</l>
<l>ImageFiles := [ImageFiles,'barcode/' + [GS1LimitedFiles,GS1OmnidirFiles,GS1StackedFiles,GS1StackedOmnidirFiles,GS1TruncatedFiles]]</l>
<l>ShuffledIndices := sort_index(rand(|ImageFiles|))</l>
<l>create_bar_code_model ('min_identical_scanlines', 2, BarCodeHandle)</l>
<l>for I := 0 to |ImageFiles| - 1 by 1</l>
<l>    read_image (Image, ImageFiles[ShuffledIndices[I]])</l>
<l>    get_image_size (Image, Width, Height)</l>
<l>    if (Width &lt; Height)</l>
<l>        rotate_image (Image, Image, 90, 'constant')</l>
<l>    endif</l>
<l>    count_seconds (S1)</l>
<l>    find_bar_code (Image, SymbolRegions, BarCodeHandle, 'auto', DecodedDataStrings)</l>
<l>    count_seconds (S2)</l>
<l>    dev_resize_window_fit_image (Image, 0, 0, [640,640], -1)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_line_width (3)</l>
<l>    dev_display (SymbolRegions)</l>
<l>    area_center (SymbolRegions, Area, Row, Column)</l>
<l>    get_bar_code_result (BarCodeHandle, 'all', 'decoded_types', BarCodeResults)</l>
<l>    Message := 'Found ' + |Row| + ' code(s) in ' + ((S2 - S1) * 1000)$'0.2' + ' ms'</l>
<l>    disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>    for J := 0 to |Row| - 1 by 1</l>
<l>        String := BarCodeResults[J] + ': ' + DecodedDataStrings[J]</l>
<l>        disp_message (WindowHandle, String, 'image', Row[J], Column[J] - 50, 'black', 'true')</l>
<l>    endfor</l>
<l>    if (I &lt; 6)</l>
<l>        p_disp_pause_sign (WindowHandle, 2)</l>
<l>        wait_seconds (1)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="p_do_find_barcode">
<parameters/>
</docu>
</procedure>
<procedure name="project_xy_to_image">
<interface>
<ic>
<par name="XC1" base_type="ctrl" dimension="0"/>
<par name="YC1" base_type="ctrl" dimension="0"/>
<par name="MeasurementPlaneAdjusted" base_type="ctrl" dimension="0"/>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>pose_to_hom_mat3d (MeasurementPlaneAdjusted, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, XC1, YC1, 0 * XC1, Qx, Qy, Qz)</l>
<l>project_3d_point (Qx, Qy, Qz, CameraParam, Row1, Column1)</l>
<l>return ()</l>
</body>
<docu id="project_xy_to_image">
<parameters>
<parameter id="CameraParam"/>
<parameter id="Column1"/>
<parameter id="MeasurementPlaneAdjusted"/>
<parameter id="Row1"/>
<parameter id="XC1"/>
<parameter id="YC1"/>
</parameters>
</docu>
</procedure>
<procedure name="p_do_metrology_model">
<interface/>
<body>
<c>* This program shows how the metrology model can be used to</c>
<c>* obtain calibrated measurements for various geometric forms</c>
<c>* lying in a plane. The parameters of the geometric forms are</c>
<c>* derived from a model image.</c>
<c>* </c>
<c>* To find the objects to be measured in a new image,</c>
<c>* shape-based matching is used.</c>
<c>* </c>
<c>* The results of a measurement are returned as contours</c>
<c>* and as adjusted parameters of the given geometric objects</c>
<c>* </c>
<c>* </c>
<c>* Initialize visualization</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_set_draw ('margin')</l>
<l>gen_empty_obj (EmptyObject)</l>
<l>read_image (Image, 'metal-parts/circle_plate_01')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_open_window_fit_image (Image, 0, 0, 640, -1, WindowHandle)</l>
<l>p_set_font (WindowHandle)</l>
<c>* </c>
<c>* Part I:</c>
<c>* </c>
<c>* Initialize metrology model</c>
<c>* </c>
<c>* Define camera parameter</c>
<l>CameraParam := [0.0128649,-661.434,5.30004e-006,5.3e-006,620.043,497.402,Width,Height]</l>
<c>* The pose of the measurement plane was derived by placing a</c>
<c>* calibration plate in the plane of the object to be measured</c>
<c>* and by determining its pose</c>
<l>MeasurementPlane := [0.00940956,-0.00481017,0.29128,0.478648,359.65,0.785,0]</l>
<c>* Adjust the pose of the measurement plane</c>
<c>* for the height of the part and the height of the calibration plate</c>
<c>* </c>
<c>* Thickness of the calibration plate</c>
<l>CalibPlateThickness := 0.006</l>
<c>* Thickness of the object to be measured</c>
<l>PartHeight := 0.005</l>
<l>AdjustThickness := CalibPlateThickness - PartHeight</l>
<l>set_origin_pose (MeasurementPlane, 0, 0, AdjustThickness, MeasurementPlaneAdjusted)</l>
<c>* </c>
<c>* Create the metrology model and prepare it for</c>
<c>* calibrated measurements</c>
<l>create_metrology_model (MetrologyHandle)</l>
<c>* Set the image size in advance to speed up the</c>
<c>* first call of apply_metrology_model.</c>
<l>set_metrology_model_image_size (MetrologyHandle, Width, Height)</l>
<c>* Set the camera parameters</c>
<l>set_metrology_model_param (MetrologyHandle, 'camera_param', CameraParam)</l>
<c>* Set the plane in which the measured object lies</c>
<l>set_metrology_model_param (MetrologyHandle, 'plane_pose', MeasurementPlaneAdjusted)</l>
<c>* </c>
<c>* Add the objects to be measured to the metrology model</c>
<c>* </c>
<c>* Add several full circles</c>
<l>CircleParam := [354,274,53]</l>
<l>CircleParam := [CircleParam,350,519,53]</l>
<l>CircleParam := [CircleParam,345,764,52]</l>
<l>CircleParam := [CircleParam,596,523,53]</l>
<l>add_metrology_object_generic (MetrologyHandle, 'circle', CircleParam, 20, 5, 1, 30, [], [], CircleIndices1)</l>
<c>* </c>
<c>* Add two partial circles</c>
<l>CircleParam1 := [583,1010,79]</l>
<l>CircleParam2 := [336,1005,77]</l>
<l>add_metrology_object_generic (MetrologyHandle, 'circle', CircleParam1, 20, 5, 1, 30, ['start_phi','end_phi'], [0,rad(185)], CircleIndices2)</l>
<l>add_metrology_object_generic (MetrologyHandle, 'circle', CircleParam2, 20, 5, 1, 30, ['start_phi','end_phi'], [rad(45),rad(185)], Index3)</l>
<l>CircleIndices2 := [CircleIndices2,Index3]</l>
<c>* </c>
<c>* Add a retangle</c>
<l>RectangleParam := [599,279,rad(90),62,51]</l>
<l>add_metrology_object_generic (MetrologyHandle, 'rectangle2', RectangleParam, 20, 5, 1, 30, [], [], RectIndices)</l>
<c>* Add two lines</c>
<l>Line1 := [143,1122,709,1132]</l>
<l>Line2 := [151,153,136,1115]</l>
<l>add_metrology_object_generic (MetrologyHandle, 'line', [Line1,Line2], 20, 5, 1, 30, [], [], LineIndices)</l>
<c>* Inspect the shapes that have been added to the metrology model</c>
<l>get_metrology_object_model_contour (ModelContour, MetrologyHandle, 'all', 1.5)</l>
<l>get_metrology_object_measures (MeasureContour, MetrologyHandle, 'all', 'all', Row, Column)</l>
<c>* </c>
<c>* Part 2:</c>
<c>* </c>
<c>* Prepare the alignment</c>
<c>* </c>
<c>* </c>
<c>* Create the shape model for the alignment</c>
<c>* of the metrology model in images where the</c>
<c>* object occurs in positions and orientations different</c>
<c>* from the ones in the image used for creating the model</c>
<l>get_system ('border_shape_models', BorderShapeModel)</l>
<l>set_system ('border_shape_models', 'true')</l>
<l>threshold (Image, Region, 0, 50)</l>
<l>dilation_rectangle1 (Region, ModelRegion, 5, 5)</l>
<l>reduce_domain (Image, ModelRegion, ImageReduced)</l>
<l>create_shape_model (ImageReduced, 6, 0, rad(360), 'auto', 'auto', 'use_polarity', 'auto', 20, ShapeModelID)</l>
<c>* The origin of the shape model is the center of the</c>
<c>* input region used in create_shape_model</c>
<l>area_center (ModelRegion, Area, RowModel, ColumnModel)</l>
<l>get_shape_model_contours (ShapeModelContours, ShapeModelID, 1)</l>
<c>* </c>
<c>* Change the reference system in which the metrology model is</c>
<c>* defined to correspond to the one used by the shape model.</c>
<c>* This is necessary to be able to directly use the results of</c>
<c>* find_shape_model to align the metrology model</c>
<l>set_metrology_model_param (MetrologyHandle, 'reference_system', [RowModel,ColumnModel,0])</l>
<l>get_metrology_object_model_contour (ModelContour, MetrologyHandle, 'all', 1.5)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<c>* </c>
<c>* Online phase</c>
<l>for Loop := 1 to 3 by 1</l>
<l>    for I := 1 to 5 by 1</l>
<l>        read_image (CurrentImage, 'metal-parts/circle_plate_' + I$'02d')</l>
<l>        dev_display (CurrentImage)</l>
<c>        * </c>
<c>        * </c>
<c>        * Measure the position and orientation of the object in the</c>
<c>        * current image using the shape model</c>
<l>        find_shape_model (CurrentImage, ShapeModelID, 0, rad(360), 0.5, 1, 0, 'least_squares', 5, 0.9, RowAlign, ColumnAlign, AngleAlign, Score)</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_display_shape_matching_results (ShapeModelID, 'white', RowAlign, ColumnAlign, AngleAlign, 1, 1, 0)</l>
<c>        * </c>
<c>        * Use the computed position and orientation to</c>
<c>        * align the metrology model with its current occurrence</c>
<l>        align_metrology_model (MetrologyHandle, RowAlign, ColumnAlign, AngleAlign)</l>
<c>        * </c>
<c>        * Perform the measurement for all metrology objects in one call</c>
<l>        apply_metrology_model (CurrentImage, MetrologyHandle)</l>
<c>        * Get measure regions for visualization</c>
<l>        get_metrology_object_measures (Contour, MetrologyHandle, 'all', 'all', Row, Column)</l>
<c>        * Get the edge points that were actually used to fit the</c>
<c>        * geometric forms</c>
<l>        get_metrology_object_result (MetrologyHandle, 'all', 'all', 'used_edges', 'row', UsedRow)</l>
<l>        get_metrology_object_result (MetrologyHandle, 'all', 'all', 'used_edges', 'column', UsedColumn)</l>
<l>        gen_cross_contour_xld (UsedEdges, UsedRow, UsedColumn, 10, rad(45))</l>
<c>        * </c>
<c>        * Access the results of the measurement</c>
<c>        * Since camera parameters were set, all results are given in</c>
<c>        * metric coordinates relative to the coordinate system</c>
<c>        * defined by the measurement plane</c>
<c>        * </c>
<c>        * Get a visualization of the measured geometric forms</c>
<l>        get_metrology_object_result_contour (ResultContours, MetrologyHandle, 'all', 'all', 1.5)</l>
<c>        * Extract the radius of the smaller circles</c>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices1, 'all', 'result_type', 'radius', RadiusC1)</l>
<c>        * Extract the radius of the larger incomplete circles</c>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices2, 'all', 'result_type', 'radius', RadiusC2)</l>
<c>        * Extract the lengths of the rectangle sides</c>
<l>        get_metrology_object_result (MetrologyHandle, RectIndices, 'all', 'result_type', 'length1', Length1R)</l>
<l>        get_metrology_object_result (MetrologyHandle, RectIndices, 'all', 'result_type', 'length2', Length2R)</l>
<c>        * Get the start and end point of each measured line</c>
<l>        get_metrology_object_result (MetrologyHandle, LineIndices[0], 'all', 'result_type', 'all_param', ParamLine1)</l>
<l>        get_metrology_object_result (MetrologyHandle, LineIndices[1], 'all', 'result_type', 'all_param', ParamLine2)</l>
<c>        * Display the results</c>
<l>        dev_set_line_width (1)</l>
<l>        dev_set_color ('light gray')</l>
<l>        dev_display (Contour)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_display (ResultContours)</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_set_color ('white')</l>
<l>        dev_display (UsedEdges)</l>
<c>        * </c>
<c>        * Display the radii for each circle at the circle centers</c>
<c>        * Obtain the metric coordinates of the circle centers</c>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices1, 'all', 'result_type', 'x', XC1)</l>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices1, 'all', 'result_type', 'y', YC1)</l>
<c>        * Project the metric coordinates of the circle centers</c>
<c>        * into the image to get the image coordinates of the</c>
<c>        * circle centers</c>
<l>        project_xy_to_image (XC1, YC1, MeasurementPlaneAdjusted, CameraParam, Row1, Column1)</l>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices2, 'all', 'result_type', 'x', XC2)</l>
<l>        get_metrology_object_result (MetrologyHandle, CircleIndices2, 'all', 'result_type', 'y', YC2)</l>
<l>        project_xy_to_image (XC2, YC2, MeasurementPlaneAdjusted, CameraParam, Row2, Column2)</l>
<l>        for J := 0 to |RadiusC1| - 1 by 1</l>
<l>            disp_message (WindowHandle, 'r=' + (RadiusC1[J] * 1000)$'.2f', 'image', Row1[J], Column1[J] - 80, 'black', 'true')</l>
<l>        endfor</l>
<l>        for J := 0 to |RadiusC2| - 1 by 1</l>
<l>            disp_message (WindowHandle, 'r=' + (RadiusC2[J] * 1000)$'.2f', 'image', Row2[J], Column2[J] - 80, 'black', 'true')</l>
<l>        endfor</l>
<l>        get_metrology_object_result (MetrologyHandle, RectIndices, 'all', 'result_type', 'x', XRectangle)</l>
<l>        get_metrology_object_result (MetrologyHandle, RectIndices, 'all', 'result_type', 'y', YRectangle)</l>
<l>        project_xy_to_image (XRectangle, YRectangle, MeasurementPlaneAdjusted, CameraParam, RowR, ColumnR)</l>
<l>        Area := Length1R * Length2R * 4 * 1000 * 1000</l>
<l>        disp_message (WindowHandle, 'area=' + Area$'.2f', 'image', RowR, ColumnR - 120, 'black', 'true')</l>
<l>        Message := 'Measured metric results (r in mm, area in mm^2)'</l>
<c>        * </c>
<l>        disp_message (WindowHandle, Message, 'window', 12, 12, 'black', 'true')</l>
<l>        if (Loop == 1)</l>
<l>            p_disp_pause_sign (WindowHandle, 2)</l>
<l>            wait_seconds (1)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* Clean up memory</c>
<l>clear_metrology_model (MetrologyHandle)</l>
<l>clear_shape_model (ShapeModelID)</l>
<l>set_system ('border_shape_models', BorderShapeModel)</l>
<l>return ()</l>
</body>
<docu id="p_do_metrology_model">
<parameters/>
</docu>
</procedure>
<procedure name="disp_steps">
<interface>
<io>
<par name="DateLine" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="BoxIdx" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Dates" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Finished" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps display the current text segmentation results.</c>
<l>count_obj (DateLine, Number)</l>
<l>if (Number == 0)</l>
<l>    disp_message (WindowHandle, 'No Date found', 'window', 12, 12, 'red', 'true')</l>
<l>    Finished := 0</l>
<l>else</l>
<l>    union1 (DateLine, RegionUnion)</l>
<l>    smallest_rectangle1 (RegionUnion, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row1 - 10, Column1 - 10, Row2 + 10, Column2 + 10)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_set_line_width (5)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_display (Rectangle)</l>
<l>    disp_message (WindowHandle, 'Date found: ' + Dates, 'window', 12, 12, 'black', 'true')</l>
<l>    dev_set_color ('black')</l>
<l>    Finished := 1</l>
<l>endif</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_colored (12)</l>
<l>dev_set_draw ('fill')</l>
<l>return ()</l>
</body>
<docu id="disp_steps">
<parameters>
<parameter id="BoxIdx"/>
<parameter id="DateLine"/>
<parameter id="Dates"/>
<parameter id="Finished"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="select_expiry_date">
<interface>
<oo>
<par name="Date" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="NumLines" base_type="ctrl" dimension="0"/>
<par name="TextResult" base_type="ctrl" dimension="0"/>
<par name="Dates" base_type="ctrl" dimension="0"/>
<par name="ImageIdx" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DateIdx" base_type="ctrl" dimension="0"/>
<par name="DatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure searches for date-like structures in the found text.</c>
<c>* Dates of the form MM/YYYY are extracted. Different forms of expiry</c>
<c>* dates could also be set. As an alternative, text_line_structures and</c>
<c>* the corresponding text_line_separators could also be set.</c>
<l>DatesOut := Dates</l>
<l>gen_empty_obj (Date)</l>
<l>for LineIdx := 0 to NumLines - 1 by 1</l>
<c>    * Read text line jdx</c>
<l>    get_text_result (TextResult, ['class_line',LineIdx], Characters)</l>
<c>    * The similarity of 0's and O's leads to the fact, that they are</c>
<c>    * occasionaliy misclassified. Ergo, we convert all O's to 0's,</c>
<c>    * just to be sure</c>
<l>    tuple_regexp_replace (Characters, 'O', '0', TextLineChars)</l>
<l>    tuple_sum (TextLineChars, SelectedDigits)</l>
<c>    * The dates on the medical packages have the form MM/YYYY</c>
<l>    tuple_regexp_match (SelectedDigits, '\\d\\d/\\d\\d\\d\\d', Match)</l>
<c>    * Do we have a match?</c>
<l>    tuple_strlen (Match, Length)</l>
<l>    if (Length == 7)</l>
<l>        DatesOut := DatesOut + Match</l>
<l>        DateIdx := ImageIdx</l>
<c>        * Get the corresponding text line from TextResultID</c>
<l>        get_text_object (TextLine, TextResult, ['line',LineIdx])</l>
<c>        * Find the exact position of the date within the text line</c>
<l>        tuple_strstr (SelectedDigits, Match, Pos)</l>
<l>        select_obj (TextLine, Date, Pos + [1:7])</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="select_expiry_date">
<parameters>
<parameter id="Date"/>
<parameter id="DateIdx"/>
<parameter id="Dates"/>
<parameter id="DatesOut"/>
<parameter id="ImageIdx"/>
<parameter id="NumLines"/>
<parameter id="TextResult"/>
</parameters>
</docu>
</procedure>
</hdevelop>
